<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Darius Foo</title><link>https://dariusf.github.io/</link><description>Recent content on Darius Foo</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><copyright>Copyright Â© 2022, Darius Foo.</copyright><lastBuildDate>Tue, 01 Aug 2023 14:17:22 +0800</lastBuildDate><atom:link href="https://dariusf.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Research</title><link>https://dariusf.github.io/research/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dariusf.github.io/research/</guid><description> Publications Semantic Scholar, Google Scholar, CSAuthors
Staged Specifications for Automated Verification of Higher-Order Imperative Programs Under submission (2023) pdf code Extending Separation Logic for Unrestricted Algebraic Effects and Handling Under submission (2023) code Protocol Conformance with Choreographic PlusCal TASE 2023 pdf code Automated Temporal Verification for Algebraic Effects APLAS 2022 video slides pdf code Tracing OCaml Programs OCaml 2022 video slides pdf code Automating Continuous Planning in SAFe RCoSE 2020 slides pdf code poster The Dynamics of Software Composition Analysis ASE LBR 2019 pdf poster Efficient Static Checking of Library Updates FSE 2018 slides pdf SGL: A DSL for large-scale analysis of open-source code SecDev 2018 slides pdf Higher-Order Debugging and Logging for OCaml Undergraduate thesis (2016) slides pdf code</description></item><item><title>Work</title><link>https://dariusf.github.io/work/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dariusf.github.io/work/</guid><description>Work My resume and extended CV.
Most of my work can be found on my GitHub profile.
Teaching CS1101S Programming Methodology, (2013-2015, 2023) CS2030S Programming Methodology II (2021, 2023) CS2102 Database Systems (2020, 2022; slides) CS2103T Software Engineering (2022) CS3281/CS3282 Software Engineering in Live Projects (2016) Service Artifact evaluation committee: ESOP 2022 Subreviewer: POPL 2022, CAV 2022 Student volunteer: PLDI 2021, SPLASH 2022 Talks Answer Set Programming: Into the Multiverse, 2020, Veracode Coding like a DJ, 2023, BTC Writing Test Lean and Ship Healthy: A Handbook on Delivering High Quality Software in the DevOps World (HTML, Kindle)</description></item><item><title>Other</title><link>https://dariusf.github.io/other/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dariusf.github.io/other/</guid><description> Games Logophile, a small game about words Shrink Simulator, Global Game Jam 2015 Vigilante, an artsy game for Global Game Jam 2014 Getzapp, a puzzle platformer Tower of Myr: Crystal Stream, a turn-based strategy game</description></item><item><title>Jump-to-definition in PL papers</title><link>https://dariusf.github.io/latex-notation/</link><pubDate>Tue, 01 Aug 2023 14:17:22 +0800</pubDate><guid>https://dariusf.github.io/latex-notation/</guid><description>PL papers tend to use lots of notation. To manage this, paper sources usually include a &amp;quot;macros.tex&amp;quot; containing a slew of \newcommands, defining wonderful languages of terms and naming all the clever judgments and syntactic sugar.
While notation can increase clarity, it can cause difficulty to readers, who haven't had the hundreds of hours of practice the authors have had using and reading those intricate strings of symbols, and internalizing their precedences and meaning.</description></item><item><title>Ordering events across live loops in Sonic Pi</title><link>https://dariusf.github.io/sonic-pi-time/</link><pubDate>Sat, 03 Jun 2023 14:50:17 +0800</pubDate><guid>https://dariusf.github.io/sonic-pi-time/</guid><description>Sonic Pi has an elegant and well-thought temporal semantics. Using the following program as an example,
sample :drum_bass_hard play :c sleep 1 sample :drum_cowbell The drum sample and note can be thought of as starting simultaneously, and the cowbell will play precisely one second1 after. In other words, sleep there isn't actually POSIX's sleep - it can be thought of as delimiting a section on a virtual timeline, a section which does not include the time taken to start playing the sample and note.</description></item><item><title>Satisfying Music Theory</title><link>https://dariusf.github.io/drafts/satisfying-music-theory/</link><pubDate>Fri, 30 Dec 2022 10:41:06 +0800</pubDate><guid>https://dariusf.github.io/drafts/satisfying-music-theory/</guid><description>This post is about my experiments in generating music using SMT.
As a teaser, here is a procedurally-generated harmonization of the first line of Joy to the World. Given the melody (in the soprano voice), the system produces the other three voices in a way that makes harmonic sense.
X: 1 T: Joy to the World L: 1/16 K: C M: 4/4 Q: 1/4=110 V: sop name="S" V: alto name="</description></item><item><title>Trees with holes</title><link>https://dariusf.github.io/trees-with-holes/</link><pubDate>Mon, 16 May 2022 16:28:10 +0800</pubDate><guid>https://dariusf.github.io/trees-with-holes/</guid><description>While working on a top-down synthesis prototype, I got distracted by the issue of how to represent incomplete program fragments, with holes to be filled in.
The simple way:
type expr = | One | Plus of expr * expr | Hole let (__) = Hole let hypothesis = Plus (__, __) and this would probably have worked, but with quadratic-time substitution, since all the holes would be at the bottom of the tree.</description></item><item><title>Visualizing Z3's proofs</title><link>https://dariusf.github.io/z3-proofs/</link><pubDate>Sun, 21 Mar 2021 12:00:06 +0800</pubDate><guid>https://dariusf.github.io/z3-proofs/</guid><description>A writeup of a presentation I gave in class.
SMT solvers like Z3 are often also called automated theorem provers. Why? What do their proofs look like?
An SMT solver tells us if a formula in first-order logic (augmented with various theories) is satisfiable1: there is some assignment of variables that makes the formula true. Z3 can even produce such an assignment.
from z3 import * i = Int(&amp;#39;i&amp;#39;) solve(i &amp;gt; 0) [i = 1] Not every formula is satisfiable, though.</description></item><item><title>Pretty stack-and-heap diagrams</title><link>https://dariusf.github.io/stack-heap/</link><pubDate>Sun, 07 Feb 2021 00:13:31 +0800</pubDate><guid>https://dariusf.github.io/stack-heap/</guid><description>I'm teaching an introductory programming class this semester, which introduced students to the runtime stack and the heap in one of the early tutorials.
For consistency across face-to-face and online classes, I decided to have the diagrams in my slides instead of drawing them terribly over and over.
While there were lots of references for drawing such diagrams by hand, there didn't seem to be any small and simple tools for generating them.</description></item><item><title>Mouseover Minesweeper</title><link>https://dariusf.github.io/minesweeper/</link><pubDate>Tue, 29 Sep 2020 20:03:28 +0800</pubDate><guid>https://dariusf.github.io/minesweeper/</guid><description>Automation in puzzle games is tricky to balance. The issue is that puzzle games can involve some busywork, e.g. keeping track of the possibilities for each cell in Sudoku, and that removing the tedious parts allows the player to focus on the &amp;quot;interesting&amp;quot; parts of the puzzle.
Unfortunately, the parts of the game that are core to its experience can be quite subjective. Automation can also quickly spiral out of control, where adding a single rule (e.</description></item><item><title>Transparent iOS backups</title><link>https://dariusf.github.io/ios-backups/</link><pubDate>Thu, 30 Jul 2020 17:49:26 +0800</pubDate><guid>https://dariusf.github.io/ios-backups/</guid><description>Backing up an iOS device is nice and simple: there's iCloud, or connecting your device, opening Finder, and clicking Back Up Now. Unfortunately this process is also rather opaque: all we can do in Finder is to create and restore backups, not view their contents. I'd like to be able to extract individual files and archive them elsewhere.
At the time of writing there are no up-to-date and polished open source apps for simply viewing backup data in an open format, so here we'll explore how iOS backups are structured and figure out how to extract the raw files.</description></item><item><title>SATB Bird</title><link>https://dariusf.github.io/drafts/bird/</link><pubDate>Thu, 24 Oct 2019 23:49:57 +0800</pubDate><guid>https://dariusf.github.io/drafts/bird/</guid><description>Flappy Bird and choral singing have a lot in common. Bird analogies, gestures, calls, and songs are common in warmups, and in both activities, you are trying to steer a small flapping thing along a fine line through (your) pipes, backed by a lush (musical) landscape.
To make that less of a reach, I cobbled together a prototype of a singing-powered Flappy Bird, based on an open source clone of the game.</description></item><item><title>Bags of puzzle pieces in ASP</title><link>https://dariusf.github.io/asp-puzzle-pieces/</link><pubDate>Sat, 25 Nov 2017 12:15:06 +0800</pubDate><guid>https://dariusf.github.io/asp-puzzle-pieces/</guid><description>Answer set programming is an offshoot of traditional logic programming with a number of nice properties: programs always terminate, are fully declarative (i.e. clause ordering doesn't matter and search is complete, unlike Prolog), and have a well-defined semantics. Modelling a domain with relations is a wonderfully high-level way to reason about things, allowing complex rules to be represented concisely.
ASP is typically applied to hard search problems, but can model pretty much anything.</description></item><item><title>CV</title><link>https://dariusf.github.io/cv/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dariusf.github.io/cv/</guid><description>Professional Experience National University of Singapore
PhD Student
Aug 2020 &amp;ndash; Present Started my PhD! SourceClear (and, by acquisition, Veracode)
Senior Software Engineer
May 2016 &amp;ndash; Jul 2020 Worked on the SourceClear Agent, a tool which uses a combination of static analysis and instrumentation to discover and automatically upgrade library dependencies from CI/CD pipelines. Maintained a code analysis pipeline for precomputing partial static analysis results for large numbers of open source libraries.</description></item></channel></rss>