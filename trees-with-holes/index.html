<!doctype html><html lang=en-US><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://dariusf.github.io/images/favicon.png><title>Trees with holes | Darius Foo</title>
<meta name=title content="Trees with holes"><meta name=description content="While working on a top-down synthesis prototype, I got distracted by the issue of how to represent incomplete program fragments, with holes to be filled in.
The simple way:
type expr =
  | One
  | Plus of expr * expr
  | Hole

let (__) = Hole

let hypothesis = Plus (__, __)
and this would probably have worked, but with quadratic-time substitution, since all the holes would be at the bottom of the tree.
How could we do better?1
Difference lists
Difference lists originate in Prolog folklore.2
Unlike regular lists, they end with a logic variable instead of an empty list.
When unified, the logic variable allows something to be appended to the list quickly, without rebuilding it."><meta name=keywords content><meta property="og:url" content="https://dariusf.github.io/trees-with-holes/"><meta property="og:site_name" content="Darius Foo"><meta property="og:title" content="Trees with holes"><meta property="og:description" content="While working on a top-down synthesis prototype, I got distracted by the issue of how to represent incomplete program fragments, with holes to be filled in.
The simple way:
type expr = | One | Plus of expr * expr | Hole let (__) = Hole let hypothesis = Plus (__, __) and this would probably have worked, but with quadratic-time substitution, since all the holes would be at the bottom of the tree.
How could we do better?1
Difference lists Difference lists originate in Prolog folklore.2 Unlike regular lists, they end with a logic variable instead of an empty list. When unified, the logic variable allows something to be appended to the list quickly, without rebuilding it."><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-05-16T16:28:10+08:00"><meta property="article:modified_time" content="2022-05-16T16:28:10+08:00"><meta property="og:image" content="https://dariusf.github.io/images/favicon.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dariusf.github.io/images/favicon.png"><meta name=twitter:title content="Trees with holes"><meta name=twitter:description content="While working on a top-down synthesis prototype, I got distracted by the issue of how to represent incomplete program fragments, with holes to be filled in.
The simple way:
type expr = | One | Plus of expr * expr | Hole let (__) = Hole let hypothesis = Plus (__, __) and this would probably have worked, but with quadratic-time substitution, since all the holes would be at the bottom of the tree.
How could we do better?1
Difference lists Difference lists originate in Prolog folklore.2 Unlike regular lists, they end with a logic variable instead of an empty list. When unified, the logic variable allows something to be appended to the list quickly, without rebuilding it."><meta itemprop=name content="Trees with holes"><meta itemprop=description content="While working on a top-down synthesis prototype, I got distracted by the issue of how to represent incomplete program fragments, with holes to be filled in.
The simple way:
type expr = | One | Plus of expr * expr | Hole let (__) = Hole let hypothesis = Plus (__, __) and this would probably have worked, but with quadratic-time substitution, since all the holes would be at the bottom of the tree.
How could we do better?1
Difference lists Difference lists originate in Prolog folklore.2 Unlike regular lists, they end with a logic variable instead of an empty list. When unified, the logic variable allows something to be appended to the list quickly, without rebuilding it."><meta itemprop=datePublished content="2022-05-16T16:28:10+08:00"><meta itemprop=dateModified content="2022-05-16T16:28:10+08:00"><meta itemprop=wordCount content="1121"><meta itemprop=image content="https://dariusf.github.io/images/favicon.png"><meta name=referrer content="no-referrer-when-downgrade"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Code"><style>@media(prefers-color-scheme:light){:root{--bright-text-color:#222;--link-color:#3273dc;--link-visited-color:#6e4bbe;--background-color:#fff;--text-color:#444;--faded-text-color:#777;--blockquote-text-color:var(--bright-text-color);--faint-color:#ccc}.chroma{background-color:#fff}.chroma .x{}.chroma .err{color:#000}.chroma .lntd{vertical-align:top;padding:0;margin:0;border:0}.chroma .lntable{border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block}.chroma .hl{display:block;width:100%;background-color:#ffc}.chroma .lnt{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .ln{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .k{color:#a90d91}.chroma .kc{color:#a90d91}.chroma .kd{color:#a90d91}.chroma .kn{color:#a90d91}.chroma .kp{color:#a90d91}.chroma .kr{color:#a90d91}.chroma .kt{color:#a90d91}.chroma .n{color:#000}.chroma .na{color:#836c28}.chroma .nb{color:#a90d91}.chroma .bp{color:#5b269a}.chroma .nc{color:#3f6e75}.chroma .no{color:#000}.chroma .nd{color:#000}.chroma .ni{color:#000}.chroma .ne{color:#000}.chroma .nf{color:#000}.chroma .fm{color:#000}.chroma .nl{color:#000}.chroma .nn{color:#000}.chroma .nx{color:#000}.chroma .py{color:#000}.chroma .nt{color:#000}.chroma .nv{color:#000}.chroma .vc{color:#000}.chroma .vg{color:#000}.chroma .vi{color:#000}.chroma .vm{color:#000}.chroma .l{color:#1c01ce}.chroma .ld{color:#1c01ce}.chroma .s{color:#c41a16}.chroma .sa{color:#c41a16}.chroma .sb{color:#c41a16}.chroma .sc{color:#2300ce}.chroma .dl{color:#c41a16}.chroma .sd{color:#c41a16}.chroma .s2{color:#c41a16}.chroma .se{color:#c41a16}.chroma .sh{color:#c41a16}.chroma .si{color:#c41a16}.chroma .sx{color:#c41a16}.chroma .sr{color:#c41a16}.chroma .s1{color:#c41a16}.chroma .ss{color:#c41a16}.chroma .m{color:#1c01ce}.chroma .mb{color:#1c01ce}.chroma .mf{color:#1c01ce}.chroma .mh{color:#1c01ce}.chroma .mi{color:#1c01ce}.chroma .il{color:#1c01ce}.chroma .mo{color:#1c01ce}.chroma .o{color:#000}.chroma .ow{color:#000}.chroma .p{}.chroma .c{color:#177500}.chroma .ch{color:#177500}.chroma .cm{color:#177500}.chroma .c1{color:#177500}.chroma .cs{color:#177500}.chroma .cp{color:#633820}.chroma .cpf{color:#633820}.chroma .g{}.chroma .gd{}.chroma .ge{}.chroma .gr{}.chroma .gh{}.chroma .gi{}.chroma .go{}.chroma .gp{}.chroma .gs{}.chroma .gu{}.chroma .gt{}.chroma .gl{}.chroma .w{}}@media(prefers-color-scheme:dark){:root{--bright-text-color:#eee;--link-color:#8cc2dd;--link-visited-color:#b9a9e0;--background-color:#333;--text-color:#ddd;--faded-text-color:#aaa;--slightly-dimmer-text-color:#ccc;--blockquote-text-color:var(--slightly-dimmer-text-color);--faint-color:#666;color-scheme:dark}img.theme-affected{filter:invert(.8)}.chroma{color:#e2e4e5;background-color:#282a36}.chroma .x{}.chroma .err{color:#ff5c57}.chroma .lntd{vertical-align:top;padding:0;margin:0;border:0}.chroma .lntable{border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block}.chroma .hl{display:block;width:100%;background-color:#ffc}.chroma .lnt{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .ln{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .k{color:#ff6ac1}.chroma .kc{color:#ff6ac1}.chroma .kd{color:#ff5c57}.chroma .kn{color:#ff6ac1}.chroma .kp{color:#ff6ac1}.chroma .kr{color:#ff6ac1}.chroma .kt{color:#9aedfe}.chroma .n{}.chroma .na{color:#57c7ff}.chroma .nb{color:#ff5c57}.chroma .bp{}.chroma .nc{color:#f3f99d}.chroma .no{color:#ff9f43}.chroma .nd{color:#ff9f43}.chroma .ni{}.chroma .ne{}.chroma .nf{color:#57c7ff}.chroma .fm{}.chroma .nl{color:#ff5c57}.chroma .nn{}.chroma .nx{}.chroma .py{}.chroma .nt{color:#ff6ac1}.chroma .nv{color:#ff5c57}.chroma .vc{color:#ff5c57}.chroma .vg{color:#ff5c57}.chroma .vi{color:#ff5c57}.chroma .vm{}.chroma .l{}.chroma .ld{}.chroma .s{color:#5af78e}.chroma .sa{color:#5af78e}.chroma .sb{color:#5af78e}.chroma .sc{color:#5af78e}.chroma .dl{color:#5af78e}.chroma .sd{color:#5af78e}.chroma .s2{color:#5af78e}.chroma .se{color:#5af78e}.chroma .sh{color:#5af78e}.chroma .si{color:#5af78e}.chroma .sx{color:#5af78e}.chroma .sr{color:#5af78e}.chroma .s1{color:#5af78e}.chroma .ss{color:#5af78e}.chroma .m{color:#ff9f43}.chroma .mb{color:#ff9f43}.chroma .mf{color:#ff9f43}.chroma .mh{color:#ff9f43}.chroma .mi{color:#ff9f43}.chroma .il{color:#ff9f43}.chroma .mo{color:#ff9f43}.chroma .o{color:#ff6ac1}.chroma .ow{color:#ff6ac1}.chroma .p{}.chroma .c{color:#78787e}.chroma .ch{color:#78787e}.chroma .cm{color:#78787e}.chroma .c1{color:#78787e}.chroma .cs{color:#78787e}.chroma .cp{color:#78787e}.chroma .cpf{color:#78787e}.chroma .g{}.chroma .gd{color:#ff5c57}.chroma .ge{text-decoration:underline}.chroma .gr{color:#ff5c57}.chroma .gh{font-weight:700}.chroma .gi{font-weight:700}.chroma .go{color:#43454f}.chroma .gp{}.chroma .gs{font-style:italic}.chroma .gu{font-weight:700}.chroma .gt{}.chroma .gl{text-decoration:underline}.chroma .w{}}:root{--heading-font:ui-rounded, 'Hiragino Maru Gothic ProN', Quicksand, Comfortaa, Manjari, 'Arial Rounded MT', 'Arial Rounded MT Bold', Calibri, source-sans-pro, sans-serif;--text-font-size:17px;--text-font:system-ui, sans-serif}*{margin:0}body{}main{margin-top:.75em}sup{vertical-align:top;font-size:.7em}p{margin-bottom:1em}html{overflow-x:hidden;margin-right:calc(-1 * (100vw - 100%))}body{font-family:var(--text-font);font-size:var(--text-font-size);margin:auto;padding:20px;max-width:720px;text-align:left;background-color:var(--background-color);color:var(--text-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5}h1,h2,h3,h4,h5,h6{font-family:var(--heading-font);color:var(--bright-text-color);font-weight:400}.blog-content h1,.blog-content h2,.blog-content h3,.blog-content h4,.blog-content h5,.blog-content h6{margin-top:.5em}hr,ul,ol{margin-bottom:.5em}div>iframe{margin-bottom:.5em}.blog-timestamp{font-size:.9em}.blog-content{margin-top:1.5em}a{color:var(--link-color);text-decoration:none}.title{color:var(--text-color);font-size:1.5em;font-family:var(--heading-font);margin-right:10px}nav a{margin-right:8px;font-family:var(--heading-font)}.paper-item svg{width:16px;vertical-align:text-bottom}.menuactive{text-decoration:underline;text-decoration-thickness:2px}table{width:100%}img{max-width:100%;margin:auto;margin-bottom:.5em;display:block}code{padding:2px 5px;margin-bottom:1em;font-family:Fira Code,monospace;font-size:14px;line-height:1.4}pre code{display:block;padding:20px;white-space:pre-wrap;overflow-x:auto}pre{border-radius:10px}p code,ol code,ul code,summary code{border-radius:4px;border:solid var(--faint-color)1px;margin:0 2px;padding:1px 2px}blockquote{border-left:1px solid #999;color:var(--blockquote-text-color);padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.deemphasize{color:var(--faded-text-color)}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px;text-align:right;margin-right:20px}ul.blog-posts li a:visited{color:var(--link-visited-color)}</style></head><body><header><a href=/><span class=title>Darius Foo</span></a><nav style=display:inline-block><a href=/blog/>Blog</a>
<a href=/research/>Research</a>
<a href=/work/>Work</a>
<a href=/other/>Other</a></nav></header><main><h1>Trees with holes</h1><div><time class=blog-timestamp datetime=2022-05-16 pubdate>16 May, 2022</time></div><div class=blog-content><p>While working on a top-down synthesis prototype, I got distracted by the issue of how to represent incomplete program fragments, with holes to be filled in.</p><p>The simple way:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>type</span> <span class=n>expr</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>One</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Plus</span> <span class=k>of</span> <span class=n>expr</span> <span class=o>*</span> <span class=n>expr</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Hole</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=o>(__)</span> <span class=o>=</span> <span class=nc>Hole</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>hypothesis</span> <span class=o>=</span> <span class=nc>Plus</span> <span class=o>(__,</span> <span class=o>__)</span>
</span></span></code></pre></div><p>and this would probably have worked, but with quadratic-time substitution, since all the holes would be at the bottom of the tree.</p><p>How could we do better?<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><h2 id=difference-lists>Difference lists</h2><p><a href=https://en.wikibooks.org/wiki/Prolog/Difference_Lists>Difference lists</a> originate in Prolog folklore.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>
Unlike regular lists, they end with a logic variable instead of an empty list.
When unified, the logic variable allows something to be appended to the list quickly, without rebuilding it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>?- A = ([1,2|E],E), E = [3,4].
</span></span><span class=line><span class=cl>A =  ([1, 2, 3, 4], [3, 4]),
</span></span><span class=line><span class=cl>E = [3, 4].
</span></span></code></pre></div><p>The same idea works in functional languages:
a list like <code>[1; 2]</code> can be represented as the function <code>(fun x -> 1 :: 2 :: x)</code>.
Appending two lists is function composition, and once we apply the difference list to <code>[]</code> to recover a regular list, we only incur the cost of building it once, regardless of how the difference list was constructed. <a href=https://github.com/batsh-dev-team/Dlist>Here</a> is an implementation where you can see how other list operations are implemented.</p><p>What would work for us is a difference list with a variable number of holes that don't all appear at the end.</p><h2 id=difference-trees>Difference trees</h2><p>First, the type of our difference tree.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>type</span> <span class=n>t</span> <span class=o>=</span> <span class=kt>int</span> <span class=o>*</span> <span class=o>(</span><span class=n>expr</span> <span class=kt>list</span> <span class=o>-&gt;</span> <span class=n>expr</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>(* Plus (One, __) *)</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>example</span> <span class=o>=</span> <span class=o>(</span><span class=n>1</span><span class=o>,</span> <span class=k>fun</span> <span class=o>[</span><span class=n>e</span><span class=o>]</span> <span class=o>-&gt;</span> <span class=nc>Plus</span> <span class=o>(</span><span class=nc>One</span><span class=o>,</span> <span class=n>e</span><span class=o>))</span>
</span></span></code></pre></div><p>We now have a list of holes to fill, and we keep track of how many there are, since otherwise that information would be known only upon building the tree.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>concretize</span> <span class=o>((</span><span class=n>i</span><span class=o>,</span> <span class=n>t</span><span class=o>)</span> <span class=o>:</span> <span class=n>t</span><span class=o>)</span> <span class=o>:</span> <span class=n>expr</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=n>t</span> <span class=o>(</span><span class=nn>List</span><span class=p>.</span><span class=n>init</span> <span class=n>i</span> <span class=o>(</span><span class=k>fun</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=nc>Hole</span><span class=o>))</span>
</span></span></code></pre></div><p>Finally, the main operation of substituting <em>difference trees</em> into difference trees.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>sub</span> <span class=n>dts</span> <span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>t</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>assert</span> <span class=o>(</span><span class=nn>List</span><span class=p>.</span><span class=n>length</span> <span class=n>dts</span> <span class=o>=</span> <span class=n>i</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>f</span> <span class=n>r</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=o>_</span><span class=n>rem</span><span class=o>,</span> <span class=n>trees</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>      <span class=nn>List</span><span class=p>.</span><span class=n>fold_right</span>
</span></span><span class=line><span class=cl>        <span class=o>(</span><span class=k>fun</span> <span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>ct</span><span class=o>)</span> <span class=o>(</span><span class=n>tr</span><span class=o>,</span> <span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>          <span class=k>let</span> <span class=n>used</span><span class=o>,</span> <span class=n>rem</span> <span class=o>=</span> <span class=nn>List</span><span class=p>.</span><span class=n>take_drop</span> <span class=n>i</span> <span class=n>tr</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>          <span class=o>(</span><span class=n>rem</span><span class=o>,</span> <span class=n>ct</span> <span class=n>used</span> <span class=o>::</span> <span class=n>t</span><span class=o>))</span>
</span></span><span class=line><span class=cl>        <span class=n>dts</span> <span class=o>(</span><span class=n>r</span><span class=o>,</span> <span class=bp>[]</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>in</span>
</span></span><span class=line><span class=cl>    <span class=n>t</span> <span class=n>trees</span>
</span></span><span class=line><span class=cl>  <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>dts_arities</span> <span class=o>=</span> <span class=nn>List</span><span class=p>.</span><span class=n>fold_right</span> <span class=o>(</span><span class=k>fun</span> <span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=o>_)</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>i</span> <span class=o>+</span> <span class=n>t</span><span class=o>)</span> <span class=n>dts</span> <span class=n>0</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=o>(</span><span class=n>dts_arities</span><span class=o>,</span> <span class=n>f</span><span class=o>)</span>
</span></span></code></pre></div><p>If we substitute two trees with m and n holes into another with just two holes, the resulting tree should have (m + n) holes.
Furthermore, the holes <code>r</code> of the resulting tree <code>f</code> should be distributed amongst the child trees according to their arities.</p><p>We try a few examples and...</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>a</span> <span class=o>=</span> <span class=o>(</span><span class=n>1</span><span class=o>,</span> <span class=k>fun</span> <span class=o>[</span><span class=n>e</span><span class=o>]</span> <span class=o>-&gt;</span> <span class=nc>Plus</span> <span class=o>(</span><span class=n>e</span><span class=o>,</span> <span class=nc>One</span><span class=o>))</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>b</span> <span class=o>=</span> <span class=o>(</span><span class=n>1</span><span class=o>,</span> <span class=k>fun</span> <span class=o>[</span><span class=n>e</span><span class=o>]</span> <span class=o>-&gt;</span> <span class=nc>Plus</span> <span class=o>(</span><span class=nc>One</span><span class=o>,</span> <span class=n>e</span><span class=o>))</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>c</span> <span class=o>=</span> <span class=o>(</span><span class=n>2</span><span class=o>,</span> <span class=k>fun</span> <span class=o>[</span><span class=n>e1</span><span class=o>;</span> <span class=n>e2</span><span class=o>]</span> <span class=o>-&gt;</span> <span class=nc>Plus</span> <span class=o>(</span><span class=n>e1</span><span class=o>,</span> <span class=n>e2</span><span class=o>))</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>c&#39;</span> <span class=o>=</span> <span class=n>concretize</span> <span class=o>(</span><span class=n>sub</span> <span class=o>[</span><span class=n>a</span><span class=o>;</span> <span class=n>b</span><span class=o>]</span> <span class=n>c</span><span class=o>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=o>#</span> <span class=n>c</span><span class=o>;;</span>
</span></span><span class=line><span class=cl><span class=o>-</span> <span class=o>:</span> <span class=kt>int</span> <span class=o>*</span> <span class=o>(</span><span class=n>expr</span> <span class=kt>list</span> <span class=o>-&gt;</span> <span class=n>expr</span><span class=o>)</span> <span class=o>=</span> <span class=o>(</span><span class=n>2</span><span class=o>,</span> <span class=o>&lt;</span><span class=k>fun</span><span class=o>&gt;)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>#</span> <span class=n>c&#39;</span><span class=o>;;</span>
</span></span><span class=line><span class=cl><span class=o>-</span> <span class=o>:</span> <span class=n>expr</span> <span class=o>=</span> <span class=nc>Plus</span> <span class=o>(</span><span class=nc>Plus</span> <span class=o>(</span><span class=nc>Hole</span><span class=o>,</span> <span class=nc>One</span><span class=o>),</span> <span class=nc>Plus</span> <span class=o>(</span><span class=nc>One</span><span class=o>,</span> <span class=nc>Hole</span><span class=o>))</span>
</span></span></code></pre></div><p>... it works! A wrinkle is that we had to keep the <code>Hole</code> constructor around to be able to render the tree.</p><h2 id=partial-application>Partial application</h2><p>Holes are usually filled one by one, and it'd be nice if we didn't have to store all the arguments somewhere before using them.
We can extend substitution so that not all arguments have to be supplied upfront, and the remaining holes are preserved in the new tree.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>sub</span> <span class=n>dts</span> <span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>t</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>assert</span> <span class=o>(</span><span class=nn>List</span><span class=p>.</span><span class=n>length</span> <span class=n>dts</span> <span class=o>&lt;=</span> <span class=n>i</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>dts_arities</span> <span class=o>=</span> <span class=nn>List</span><span class=p>.</span><span class=n>fold_right</span> <span class=o>(</span><span class=k>fun</span> <span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=o>_)</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>i</span> <span class=o>+</span> <span class=n>t</span><span class=o>)</span> <span class=n>dts</span> <span class=n>0</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>remaining</span> <span class=o>=</span> <span class=n>i</span> <span class=o>-</span> <span class=nn>List</span><span class=p>.</span><span class=n>length</span> <span class=n>dts</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>f</span> <span class=n>r</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>assert</span> <span class=o>(</span><span class=nn>List</span><span class=p>.</span><span class=n>length</span> <span class=n>r</span> <span class=o>&lt;=</span> <span class=n>dts_arities</span> <span class=o>+</span> <span class=n>remaining</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=n>rem_trees</span><span class=o>,</span> <span class=n>r</span> <span class=o>=</span> <span class=nn>List</span><span class=p>.</span><span class=n>take_drop</span> <span class=n>remaining</span> <span class=n>r</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=o>_</span><span class=n>rem</span><span class=o>,</span> <span class=n>child_trees</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>      <span class=nn>List</span><span class=p>.</span><span class=n>fold_right</span>
</span></span><span class=line><span class=cl>        <span class=o>(</span><span class=k>fun</span> <span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>ct</span><span class=o>)</span> <span class=o>(</span><span class=n>tr</span><span class=o>,</span> <span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>          <span class=k>let</span> <span class=n>used</span><span class=o>,</span> <span class=n>rem</span> <span class=o>=</span> <span class=nn>List</span><span class=p>.</span><span class=n>take_drop</span> <span class=n>i</span> <span class=n>tr</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>          <span class=o>(</span><span class=n>rem</span><span class=o>,</span> <span class=n>ct</span> <span class=n>used</span> <span class=o>::</span> <span class=n>t</span><span class=o>))</span>
</span></span><span class=line><span class=cl>        <span class=n>dts</span> <span class=o>(</span><span class=n>r</span><span class=o>,</span> <span class=bp>[]</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>in</span>
</span></span><span class=line><span class=cl>    <span class=n>t</span> <span class=o>(</span><span class=n>child_trees</span> <span class=o>@</span> <span class=n>rem_trees</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=o>(</span><span class=n>dts_arities</span> <span class=o>+</span> <span class=n>remaining</span><span class=o>,</span> <span class=n>f</span><span class=o>)</span>
</span></span></code></pre></div><p>This version is rather subtle: given a difference tree <code>(i, t)</code>, it produces another difference tree which knows how to rearrange its arguments so the complete application of <code>(i, t)</code> occurs (which is why we didn't have to handle partial application of child trees).
It also ensures that all the holes of parent trees are filled before those of child trees.<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p><p>Now we're able to supply arguments to <code>c</code> one at a time:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>c&#39;</span> <span class=o>=</span> <span class=n>concretize</span> <span class=o>(</span><span class=n>sub</span> <span class=o>[</span><span class=n>b</span><span class=o>]</span> <span class=o>(</span><span class=n>sub</span> <span class=o>[</span><span class=n>a</span><span class=o>]</span> <span class=n>c</span><span class=o>))</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=o>#</span> <span class=n>c&#39;</span><span class=o>;;</span>
</span></span><span class=line><span class=cl><span class=o>-</span> <span class=o>:</span> <span class=n>expr</span> <span class=o>=</span> <span class=nc>Plus</span> <span class=o>(</span><span class=nc>Plus</span> <span class=o>(</span><span class=nc>Hole</span><span class=o>,</span> <span class=nc>One</span><span class=o>),</span> <span class=nc>Plus</span> <span class=o>(</span><span class=nc>One</span><span class=o>,</span> <span class=nc>Hole</span><span class=o>))</span>
</span></span></code></pre></div><h2 id=representing-holes-statically>Representing holes statically?</h2><p>Having to write the arity separately when it could be given in the type of the function is another wrinkle.
We could try to use a GADT to <a href=https://drup.github.io/2016/08/02/difflists/>constrain</a> the holes.
First, a type for the number of holes that a difference tree contains.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>type</span> <span class=n>z</span> <span class=o>=</span> <span class=nc>Z</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>s</span> <span class=o>=</span> <span class=nc>S</span> <span class=k>of</span> <span class=k>&#39;</span><span class=n>a</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=o>_</span> <span class=n>holes</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>S</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>holes</span> <span class=o>-&gt;</span> <span class=o>(</span><span class=n>expr</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span><span class=o>)</span> <span class=n>holes</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Z</span> <span class=o>:</span> <span class=n>expr</span> <span class=n>holes</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>t</span> <span class=o>=</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>holes</span> <span class=o>*</span> <span class=k>&#39;</span><span class=n>a</span>
</span></span></code></pre></div><p>The arity of the function is now determined by the number of holes.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>a</span> <span class=o>:</span> <span class=o>(</span><span class=n>expr</span> <span class=o>-&gt;</span> <span class=n>expr</span><span class=o>)</span> <span class=n>t</span> <span class=o>=</span> <span class=o>(</span><span class=nc>S</span> <span class=nc>Z</span><span class=o>,</span> <span class=k>fun</span> <span class=n>e</span> <span class=o>-&gt;</span> <span class=nc>Plus</span> <span class=o>(</span><span class=n>e</span><span class=o>,</span> <span class=nc>One</span><span class=o>))</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>b</span> <span class=o>:</span> <span class=o>(</span><span class=n>expr</span> <span class=o>-&gt;</span> <span class=n>expr</span><span class=o>)</span> <span class=n>t</span> <span class=o>=</span> <span class=o>(</span><span class=nc>S</span> <span class=nc>Z</span><span class=o>,</span> <span class=k>fun</span> <span class=n>e</span> <span class=o>-&gt;</span> <span class=nc>Plus</span> <span class=o>(</span><span class=nc>One</span><span class=o>,</span> <span class=n>e</span><span class=o>))</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>c</span> <span class=o>:</span> <span class=o>(</span><span class=n>expr</span> <span class=o>-&gt;</span> <span class=n>expr</span> <span class=o>-&gt;</span> <span class=n>expr</span><span class=o>)</span> <span class=n>t</span> <span class=o>=</span> <span class=o>(</span><span class=nc>S</span> <span class=o>(</span><span class=nc>S</span> <span class=nc>Z</span><span class=o>),</span> <span class=k>fun</span> <span class=n>e1</span> <span class=n>e2</span> <span class=o>-&gt;</span> <span class=nc>Plus</span> <span class=o>(</span><span class=n>e1</span><span class=o>,</span> <span class=n>e2</span><span class=o>))</span>
</span></span></code></pre></div><p>We can even write <code>concretize</code>, using a locally abstract type, and pattern-matching on the number of holes remaining.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>concretize</span> <span class=o>:</span> <span class=k>type</span> <span class=n>a</span><span class=o>.</span> <span class=n>a</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>expr</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>fun</span> <span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>match</span> <span class=n>i</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>S</span> <span class=n>i</span> <span class=o>-&gt;</span> <span class=n>concretize</span> <span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>t</span> <span class=nc>Hole</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Z</span> <span class=o>-&gt;</span> <span class=n>t</span>
</span></span></code></pre></div><p>Unfortunately that was as far as I was able (and motivated) to go: it's unclear to me how to build an <code>f</code> with a number of arguments that depends on <code>(i, t)</code>, even if we change <code>dts</code> from a list to a single argument.
Even if we overcame that, all the folding and rearranging of arguments would certainly cause difficulty down the line.</p><h2 id=hoas>HOAS?</h2><p>This is a much more coarse-grained notion of binding than what, say, <a href=https://github.com/rlepigre/ocaml-bindlib>bindlib</a> implements, so if your trees have not just holes but free variables, or even binders lower in the tree instead of all at the top, definitely check that out.</p><h2 id=conclusion>Conclusion</h2><p>Code <a href=https://gist.github.com/dariusf/f22f9c121e42f5bb9c2c85520baaba52>here</a>.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Ignoring the fact that our goal with top-down synthesis is not to let the trees get too large...&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://www.cs.cmu.edu/~fp/courses/lp/lectures/11-diff.pdf>Difference Lists</a>, section 11.6&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>This is currently the only order we can perform substitutions in. We could allow skipping arguments positionally using a placeholder difference tree value, or some (dynamic) way to address holes.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><p></p></main><footer></footer></body></html>