<!doctype html><html lang=en-US><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://dariusf.github.io/images/favicon.png><title>Verifying effectful higher-order programs with staged logic | Darius Foo</title>
<meta name=title content="Verifying effectful higher-order programs with staged logic"><meta name=description content="

Text version of a talk given at the NUS PLSE Seminar and FM 2024 in Milan.

Effectful higher-order functions
Specifying higher-order functions today

Example 1: mutating the list
Example 2: stronger precondition
Example 3: effects outside metalogic


Staged logic

Effectful placeholders
Recursion
Re-summarization
Compaction via biabduction


Solutions to problematic examples

Example 1
Example 2
Example 3


Conclusion

Effectful higher-order functions
Most programming languages in use today are higher-order, and allow programmers to perform effects (primitive state, exceptions, or algebraic effects) in any context."><meta name=keywords content><meta property="og:url" content="https://dariusf.github.io/staged-logic/"><meta property="og:site_name" content="Darius Foo"><meta property="og:title" content="Verifying effectful higher-order programs with staged logic"><meta property="og:description" content="Text version of a talk given at the NUS PLSE Seminar and FM 2024 in Milan.
Effectful higher-order functions Specifying higher-order functions today Example 1: mutating the list Example 2: stronger precondition Example 3: effects outside metalogic Staged logic Effectful placeholders Recursion Re-summarization Compaction via biabduction Solutions to problematic examples Example 1 Example 2 Example 3 Conclusion Effectful higher-order functions Most programming languages in use today are higher-order, and allow programmers to perform effects (primitive state, exceptions, or algebraic effects) in any context."><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-08-16T11:59:39+08:00"><meta property="article:modified_time" content="2024-08-16T11:59:39+08:00"><meta property="og:image" content="https://dariusf.github.io/images/favicon.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dariusf.github.io/images/favicon.png"><meta name=twitter:title content="Verifying effectful higher-order programs with staged logic"><meta name=twitter:description content="Text version of a talk given at the NUS PLSE Seminar and FM 2024 in Milan.
Effectful higher-order functions Specifying higher-order functions today Example 1: mutating the list Example 2: stronger precondition Example 3: effects outside metalogic Staged logic Effectful placeholders Recursion Re-summarization Compaction via biabduction Solutions to problematic examples Example 1 Example 2 Example 3 Conclusion Effectful higher-order functions Most programming languages in use today are higher-order, and allow programmers to perform effects (primitive state, exceptions, or algebraic effects) in any context."><meta itemprop=name content="Verifying effectful higher-order programs with staged logic"><meta itemprop=description content="Text version of a talk given at the NUS PLSE Seminar and FM 2024 in Milan.
Effectful higher-order functions Specifying higher-order functions today Example 1: mutating the list Example 2: stronger precondition Example 3: effects outside metalogic Staged logic Effectful placeholders Recursion Re-summarization Compaction via biabduction Solutions to problematic examples Example 1 Example 2 Example 3 Conclusion Effectful higher-order functions Most programming languages in use today are higher-order, and allow programmers to perform effects (primitive state, exceptions, or algebraic effects) in any context."><meta itemprop=datePublished content="2024-08-16T11:59:39+08:00"><meta itemprop=dateModified content="2024-08-16T11:59:39+08:00"><meta itemprop=wordCount content="3884"><meta itemprop=image content="https://dariusf.github.io/images/favicon.png"><meta name=referrer content="no-referrer-when-downgrade"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Code"><style>@media(prefers-color-scheme:light){:root{--bright-text-color:#222;--link-color:#3273dc;--link-visited-color:#6e4bbe;--background-color:#fff;--text-color:#444;--faded-text-color:#777;--blockquote-text-color:var(--bright-text-color);--faint-color:#ccc}.chroma{background-color:#fff}.chroma .x{}.chroma .err{color:#000}.chroma .lntd{vertical-align:top;padding:0;margin:0;border:0}.chroma .lntable{border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block}.chroma .hl{display:block;width:100%;background-color:#ffc}.chroma .lnt{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .ln{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .k{color:#a90d91}.chroma .kc{color:#a90d91}.chroma .kd{color:#a90d91}.chroma .kn{color:#a90d91}.chroma .kp{color:#a90d91}.chroma .kr{color:#a90d91}.chroma .kt{color:#a90d91}.chroma .n{color:#000}.chroma .na{color:#836c28}.chroma .nb{color:#a90d91}.chroma .bp{color:#5b269a}.chroma .nc{color:#3f6e75}.chroma .no{color:#000}.chroma .nd{color:#000}.chroma .ni{color:#000}.chroma .ne{color:#000}.chroma .nf{color:#000}.chroma .fm{color:#000}.chroma .nl{color:#000}.chroma .nn{color:#000}.chroma .nx{color:#000}.chroma .py{color:#000}.chroma .nt{color:#000}.chroma .nv{color:#000}.chroma .vc{color:#000}.chroma .vg{color:#000}.chroma .vi{color:#000}.chroma .vm{color:#000}.chroma .l{color:#1c01ce}.chroma .ld{color:#1c01ce}.chroma .s{color:#c41a16}.chroma .sa{color:#c41a16}.chroma .sb{color:#c41a16}.chroma .sc{color:#2300ce}.chroma .dl{color:#c41a16}.chroma .sd{color:#c41a16}.chroma .s2{color:#c41a16}.chroma .se{color:#c41a16}.chroma .sh{color:#c41a16}.chroma .si{color:#c41a16}.chroma .sx{color:#c41a16}.chroma .sr{color:#c41a16}.chroma .s1{color:#c41a16}.chroma .ss{color:#c41a16}.chroma .m{color:#1c01ce}.chroma .mb{color:#1c01ce}.chroma .mf{color:#1c01ce}.chroma .mh{color:#1c01ce}.chroma .mi{color:#1c01ce}.chroma .il{color:#1c01ce}.chroma .mo{color:#1c01ce}.chroma .o{color:#000}.chroma .ow{color:#000}.chroma .p{}.chroma .c{color:#177500}.chroma .ch{color:#177500}.chroma .cm{color:#177500}.chroma .c1{color:#177500}.chroma .cs{color:#177500}.chroma .cp{color:#633820}.chroma .cpf{color:#633820}.chroma .g{}.chroma .gd{}.chroma .ge{}.chroma .gr{}.chroma .gh{}.chroma .gi{}.chroma .go{}.chroma .gp{}.chroma .gs{}.chroma .gu{}.chroma .gt{}.chroma .gl{}.chroma .w{}}@media(prefers-color-scheme:dark){:root{--bright-text-color:#eee;--link-color:#8cc2dd;--link-visited-color:#b9a9e0;--background-color:#333;--text-color:#ddd;--faded-text-color:#aaa;--slightly-dimmer-text-color:#ccc;--blockquote-text-color:var(--slightly-dimmer-text-color);--faint-color:#666;color-scheme:dark}img.theme-affected{filter:invert(.8)}.chroma{color:#e2e4e5;background-color:#282a36}.chroma .x{}.chroma .err{color:#ff5c57}.chroma .lntd{vertical-align:top;padding:0;margin:0;border:0}.chroma .lntable{border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block}.chroma .hl{display:block;width:100%;background-color:#ffc}.chroma .lnt{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .ln{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .k{color:#ff6ac1}.chroma .kc{color:#ff6ac1}.chroma .kd{color:#ff5c57}.chroma .kn{color:#ff6ac1}.chroma .kp{color:#ff6ac1}.chroma .kr{color:#ff6ac1}.chroma .kt{color:#9aedfe}.chroma .n{}.chroma .na{color:#57c7ff}.chroma .nb{color:#ff5c57}.chroma .bp{}.chroma .nc{color:#f3f99d}.chroma .no{color:#ff9f43}.chroma .nd{color:#ff9f43}.chroma .ni{}.chroma .ne{}.chroma .nf{color:#57c7ff}.chroma .fm{}.chroma .nl{color:#ff5c57}.chroma .nn{}.chroma .nx{}.chroma .py{}.chroma .nt{color:#ff6ac1}.chroma .nv{color:#ff5c57}.chroma .vc{color:#ff5c57}.chroma .vg{color:#ff5c57}.chroma .vi{color:#ff5c57}.chroma .vm{}.chroma .l{}.chroma .ld{}.chroma .s{color:#5af78e}.chroma .sa{color:#5af78e}.chroma .sb{color:#5af78e}.chroma .sc{color:#5af78e}.chroma .dl{color:#5af78e}.chroma .sd{color:#5af78e}.chroma .s2{color:#5af78e}.chroma .se{color:#5af78e}.chroma .sh{color:#5af78e}.chroma .si{color:#5af78e}.chroma .sx{color:#5af78e}.chroma .sr{color:#5af78e}.chroma .s1{color:#5af78e}.chroma .ss{color:#5af78e}.chroma .m{color:#ff9f43}.chroma .mb{color:#ff9f43}.chroma .mf{color:#ff9f43}.chroma .mh{color:#ff9f43}.chroma .mi{color:#ff9f43}.chroma .il{color:#ff9f43}.chroma .mo{color:#ff9f43}.chroma .o{color:#ff6ac1}.chroma .ow{color:#ff6ac1}.chroma .p{}.chroma .c{color:#78787e}.chroma .ch{color:#78787e}.chroma .cm{color:#78787e}.chroma .c1{color:#78787e}.chroma .cs{color:#78787e}.chroma .cp{color:#78787e}.chroma .cpf{color:#78787e}.chroma .g{}.chroma .gd{color:#ff5c57}.chroma .ge{text-decoration:underline}.chroma .gr{color:#ff5c57}.chroma .gh{font-weight:700}.chroma .gi{font-weight:700}.chroma .go{color:#43454f}.chroma .gp{}.chroma .gs{font-style:italic}.chroma .gu{font-weight:700}.chroma .gt{}.chroma .gl{text-decoration:underline}.chroma .w{}}:root{--heading-font:ui-rounded, 'Hiragino Maru Gothic ProN', Quicksand, Comfortaa, Manjari, 'Arial Rounded MT', 'Arial Rounded MT Bold', Calibri, source-sans-pro, sans-serif;--text-font-size:17px;--text-font:system-ui, sans-serif}*{margin:0}body{}main{margin-top:.75em}sup{vertical-align:top;font-size:.7em}p{margin-bottom:1em}html{overflow-x:hidden;margin-right:calc(-1 * (100vw - 100%))}body{font-family:var(--text-font);font-size:var(--text-font-size);margin:auto;padding:20px;max-width:720px;text-align:left;background-color:var(--background-color);color:var(--text-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5}h1,h2,h3,h4,h5,h6{font-family:var(--heading-font);color:var(--bright-text-color);font-weight:400}.blog-content h1,.blog-content h2,.blog-content h3,.blog-content h4,.blog-content h5,.blog-content h6{margin-top:.5em}hr,ul,ol{margin-bottom:.5em}div>iframe{margin-bottom:.5em}.blog-timestamp{font-size:.9em}.blog-content{margin-top:1.5em}a{color:var(--link-color);text-decoration:none}.title{color:var(--text-color);font-size:1.5em;font-family:var(--heading-font);margin-right:10px}nav a{margin-right:8px;font-family:var(--heading-font)}.paper-item svg{width:16px;vertical-align:text-bottom}.menuactive{text-decoration:underline;text-decoration-thickness:2px}table{width:100%}img{max-width:100%;margin:auto;margin-bottom:.5em;display:block}code{padding:2px 5px;margin-bottom:1em;font-family:Fira Code,monospace;font-size:14px;line-height:1.4}pre code{display:block;padding:20px;white-space:pre-wrap;overflow-x:auto}pre{border-radius:10px}p code,ol code,ul code,summary code{border-radius:4px;border:solid var(--faint-color)1px;margin:0 2px;padding:1px 2px}blockquote{border-left:1px solid #999;color:var(--blockquote-text-color);padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.deemphasize{color:var(--faded-text-color)}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px;text-align:right;margin-right:20px}ul.blog-posts li a:visited{color:var(--link-visited-color)}</style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script>const macros={};function render(){renderMathInElement(document.body,{trust:!0,strict:!1,throwOnError:!1,delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros})}</script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=render()></script></head><body><header><a href=/><span class=title>Darius Foo</span></a><nav style=display:inline-block><a href=/blog/>Blog</a>
<a href=/research/>Research</a>
<a href=/work/>Work</a>
<a href=/other/>Other</a></nav></header><main><h1>Verifying effectful higher-order programs with staged logic</h1><div><time class=blog-timestamp datetime=2024-08-16 pubdate>16 Aug, 2024</time></div><div class=blog-content><p><em>Text version of a talk given at the <a href=https://nus-plse.github.io/seminars.html>NUS PLSE Seminar</a> and <a href="https://www.fm24.polimi.it/?page_id=612">FM 2024</a> in Milan.</em></p><ul><li><a href=#effectful-higher-order-functions>Effectful higher-order functions</a></li><li><a href=#specifying-higher-order-functions-today>Specifying higher-order functions today</a><ul><li><a href=#example-1-mutating-the-list>Example 1: mutating the list</a></li><li><a href=#example-2-stronger-precondition>Example 2: stronger precondition</a></li><li><a href=#example-3-effects-outside-metalogic>Example 3: effects outside metalogic</a></li></ul></li><li><a href=#staged-logic>Staged logic</a><ul><li><a href=#effectful-placeholders>Effectful placeholders</a></li><li><a href=#recursion>Recursion</a></li><li><a href=#re-summarization>Re-summarization</a></li><li><a href=#compaction-via-biabduction>Compaction via biabduction</a></li></ul></li><li><a href=#solutions-to-problematic-examples>Solutions to problematic examples</a><ul><li><a href=#example-1>Example 1</a></li><li><a href=#example-2>Example 2</a></li><li><a href=#example-3>Example 3</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul><h1 id=effectful-higher-order-functions>Effectful higher-order functions</h1><p>Most programming languages in use today are higher-order, and allow programmers to perform <em>effects</em> (primitive state, exceptions, or algebraic effects) in any context.</p><p>This enables expressive programming patterns, e.g. using state in a closure to avoid traversing a list twice:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=c>(* sum a list, and also count the number of elements *)</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>count</span> <span class=o>=</span> <span class=n>ref</span> <span class=n>0</span> <span class=k>in</span>
</span></span><span class=line><span class=cl><span class=n>foldr</span> <span class=o>(</span><span class=k>fun</span> <span class=n>c</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>incr</span> <span class=n>count</span><span class=o>;</span> <span class=n>c</span><span class=o>+</span><span class=n>t</span><span class=o>)</span> <span class=n>xs</span> <span class=n>0</span>
</span></span></code></pre></div><p>or using a continuation to return multiple solutions when backtracking, and allowing the continuation to throw an exception to end the search efficiently:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>stop</span> <span class=o>=</span> <span class=k>raise</span> <span class=nc>Stop</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=k>rec</span> <span class=n>search</span> <span class=n>xs</span> <span class=n>k</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>try</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>found</span> <span class=k>then</span> <span class=n>k</span> <span class=n>answer</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=c>(* ... keep searching *)</span>
</span></span><span class=line><span class=cl>  <span class=k>with</span> <span class=nc>Stop</span> <span class=o>-&gt;</span> <span class=bp>()</span>
</span></span><span class=line><span class=cl><span class=k>in</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>result</span> <span class=o>=</span> <span class=n>search</span> <span class=n>xs</span> <span class=o>(</span><span class=k>fun</span> <span class=n>answer</span> <span class=o>-&gt;</span> <span class=k>if</span> <span class=n>good</span> <span class=n>answer</span> <span class=k>then</span> <span class=n>stop</span> <span class=bp>()</span><span class=o>)</span>
</span></span></code></pre></div><p>Using a <a href=https://github.com/ocaml-multicore/picos#why>modern I/O library</a> also makes algebraic effects pervasive.</p><p>Reasoning about effectful higher-order functions does not seem particularly difficult - we certainly do it informally every time we use them in programs!
However, support for such functions in automated verifiers varies greatly:</p><ul><li><em>Most automated verifiers require function arguments to be pure</em>. Examples include Dafny, Why3, and Cameleer. This is because they lift these functions into the underlying logic (usually the first-order logic of SMT) and are restricted by what can be expressed in it.</li><li><em>Other automated verifiers rely on type system guarantees</em>. Examples include Prusti and Creusot, which target Rust and can exploit the fact that closures can maintain invariants over their captured state via ownership. This makes the problem simpler, with the tradeoff that this approach does not work in languages with weaker type systems.</li><li><em>Most verifiers which do support such functions are interactive</em>. Examples include Iris, CFML, and Steel/Pulse (F*), which are built on proof assistants. In practice, this means that they support varying levels of automation, with the tradeoff being that they are more expressive.</li></ul><p>A second issue is that even when higher-order functions are supported, they tend to be specified <em>imprecisely</em>. We'll see an example of this shortly.</p><p>The question we're concerned with in this work is: is there a <em>precise</em> and <em>general</em> way to support effectful higher-order functions in <em>automated</em> program verifiers?</p><h1 id=specifying-higher-order-functions-today>Specifying higher-order functions today</h1><p>$\gdef\m#1{\mathit{#1}}$</p><p>$\gdef\foldr{\m{foldr}}$
$\gdef\xs{\m{xs}}$
$\gdef\ys{\m{ys}}$
$\gdef\res{\m{res}}$
$\gdef\inv{\m{Inv}}$
$\gdef\islist{\m{isList}}$
$\gdef\list{\m{List}}$
$\gdef\emp{\m{emp}}$</p><p>$\gdef\req#1{\mathbf{req}\ #1}$
$\gdef\ens#1{\mathbf{ens}\ #1}$</p><p>We'll use the classic $\foldr$ function as a running example.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>foldr</span> <span class=n>f</span> <span class=n>a</span> <span class=n>l</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>match</span> <span class=n>l</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span> <span class=o>=&gt;</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>h</span> <span class=o>::</span> <span class=n>t</span> <span class=o>=&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span> <span class=n>h</span> <span class=o>(</span><span class=n>foldr</span> <span class=n>f</span> <span class=n>a</span> <span class=n>t</span><span class=o>)</span>
</span></span></code></pre></div><p>$f$ is <em>effectful</em> - it may have state, exceptions, or algebraic effects.
$\foldr$ is hence an <em>effectful higher-order function</em>.</p><p>We would like to specify $\foldr$ in a way that allows a wide range of clients to be verified, including the one we saw earlier, which calls $\foldr$ with a closure.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>count</span> <span class=o>=</span> <span class=n>ref</span> <span class=n>0</span> <span class=k>in</span>
</span></span><span class=line><span class=cl><span class=n>foldr</span> <span class=o>(</span><span class=k>fun</span> <span class=n>c</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>incr</span> <span class=n>count</span><span class=o>;</span> <span class=n>c</span> <span class=o>+</span> <span class=n>t</span><span class=o>)</span> <span class=n>0</span> <span class=n>xs</span>
</span></span></code></pre></div><p>Here is a specification one might write today in a modern program logic<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p>$$
\forall \htmlClass{ppred}{P}, \htmlClass{foldrinv}{\inv}, f, \xs, l. \left\{ \begin{array}{l}
\htmlClass{triple}{(\forall x, a', \ys.\ \{\htmlClass{ppred}{P\ x} * \htmlClass{preserve}{\inv\ \ys\ a'} \}\ f(x, a')\ \{r.\ \htmlClass{preserve}{\inv\ (x::\ys)\ r} \})} \\
*\ \htmlClass{shape}{\islist\ l\ \xs} * \htmlClass{ppred}{\m{all}\ P\ \xs} * \htmlClass{foldrinv}{\inv\ []\ a}
\end{array} \right\} \\
\foldr\ f\ a\ l \\
\{r.\ \htmlClass{shape}{\islist\ l\ \xs} * \htmlClass{foldrinv}{\inv\ \xs\ r} \}
$$<ol><li><div class=trigger data-id=inv>The most salient feature of this specification is that it is parameterized over an *invariant* $\inv$, a (separation logic) *property* whose purpose is to describe the result of $\foldr$. It does this by relating the suffix of the list traversed so far - initially empty, and finally $\xs$ - with the result of the fold.</div></li><li><div class=trigger data-id=finv>Next, we use a nested triple to require that $f$ must preserve the invariant - assuming that the invariant holds of the portion of the list that has been folded $\ys$ and the result of the recursive call $a'$, $f$ must reestablish it for $x::\ys$ and its result $r$. This is fair, as $\foldr$ contains a call to $f$, and so we need the knowledge that $f$ preserves the invariant to ensure that $\foldr$ does. As the invariant is a separation logic property, it may also be seen as a way to describe the effect of $f$.</div></li><li><div class=trigger data-id=ppred>Anticipating that some clients may want to operate only on certain kinds of lists, the specification is further parameterized over a unary predicate $P$. A precondition $\m{all}\ P\ \xs$, which must be proved at each call site, allows $f$ to then rely on $P\ x$ in its precondition.</div></li><li><div class=trigger data-id=shape>A shape predicate $\islist$ relating the structure $l$ to its content $\xs$ appears in both pre- and postcondition. This is to say that $\foldr$ should not change the list.</div></li></ol><style>.highlight{color:orange}</style><script>const foldrHighlightData={inv:"foldrinv",shape:"shape",ppred:"ppred",finv:"preserve"};document.addEventListener("mouseover",function(e){let t=e.target.closest(".trigger");t!==null&&document.querySelectorAll("."+foldrHighlightData[t.dataset.id]).forEach(e=>e.classList.add("highlight"))}),document.addEventListener("mouseout",function(e){let t=e.target.closest(".trigger");t!==null&&document.querySelectorAll("."+foldrHighlightData[t.dataset.id]).forEach(e=>e.classList.remove("highlight"))})</script><p>This specification elegantly solves the problem for the client we presented earlier (using an invariant to relate the value of $\m{count}$ and $t$, and an identity $P$).
We argue, however, that it is <em>imprecise</em>: there are many clients that <em>cannot be verified</em> using it <em>without significant changes</em>.</p><p>The authors of the specification say as much<sup id=fnref1:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>:</p><blockquote><p>Different clients may instantiate foldr with some very different functions, hence it can be hard to give a specification for f that is reasonable and general enough to support all these choices.</p></blockquote><p>The problem is that due to the use of abstract properties, this specification commits somewhat prematurely to an <em>abstraction</em> of $f$'s behavior, and this abstraction may not be precise enough to verify a given client.</p><p>We'll look at three examples of such clients.</p><h2 id=example-1-mutating-the-list>Example 1: mutating the list</h2><p>Suppose we allowed $f$ to mutate the list.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>foldr_ex1</span> <span class=n>l</span> <span class=o>=</span> <span class=n>foldr</span> <span class=o>(</span><span class=k>fun</span> <span class=n>x</span> <span class=n>r</span> <span class=o>-&gt;</span> <span class=k>let</span> <span class=n>v</span> <span class=o>=</span> <span class=o>!</span><span class=n>x</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>                                    <span class=n>x</span> <span class=o>:=</span> <span class=n>v</span><span class=o>+</span><span class=n>1</span><span class=o>;</span> <span class=n>v</span><span class=o>+</span><span class=n>r</span><span class=o>)</span> <span class=n>l</span> <span class=n>0</span>
</span></span></code></pre></div><p>This is not technically allowed by the shape predicate in the postcondition, but suppose we changed it to $\islist\ l\ \xs'$.</p><p>The problem is that $\inv\ \xs\ r$ tells us nothing about $\xs'$.
The use of invariants required us to <em>commit to a parameterization</em>, and this particular one is insufficient.</p><p>To fix this, we would have to add $\xs'$ as a parameter to every occurrence of $\inv$.
While adding results in a more general specification, it would also be cluttered with more anticipated client use cases.</p><h2 id=example-2-stronger-precondition>Example 2: stronger precondition</h2><p>Suppose we would like to pass a function argument which relies on a property concerning intermediate results of the fold.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>foldr_ex2</span> <span class=n>l</span> <span class=o>=</span> <span class=n>foldr</span> <span class=o>(</span><span class=k>fun</span> <span class=n>x</span> <span class=n>r</span> <span class=o>-&gt;</span> <span class=k>assert</span><span class=o>(</span><span class=n>x</span><span class=o>+</span><span class=n>r</span><span class=o>&gt;=</span><span class=n>0</span><span class=o>);</span> <span class=n>x</span><span class=o>+</span><span class=n>r</span><span class=o>)</span> <span class=n>l</span> <span class=n>0</span>
</span></span></code></pre></div><p>The problem here is that we can't use $P$ to strengthen the precondition of $f$, as we need a property relating $x$ and $r$, and $P$ only constrains $x$. $\inv$ also cannot be used, as it only tells us about $r$, not $x$.</p><p>While it is possible to assume something stronger here, e.g. $x \geq 0 \wedge r \geq 0$, in general it would be awkward to decompose the property into two parts.</p><h2 id=example-3-effects-outside-metalogic>Example 3: effects outside metalogic</h2><p>This example illustrates a different problem with invariants: suppose we allowed the function to throw an exception.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>foldr_ex3</span> <span class=n>l</span> <span class=o>=</span> <span class=n>foldr</span> <span class=o>(</span><span class=k>fun</span> <span class=n>x</span> <span class=n>r</span> <span class=o>-&gt;</span> <span class=k>if</span> <span class=n>x</span><span class=o>&gt;=</span><span class=n>0</span> <span class=k>then</span> <span class=n>x</span><span class=o>+</span><span class=n>r</span>
</span></span><span class=line><span class=cl>                                    <span class=k>else</span> <span class=k>raise</span> <span class=nc>Exc</span><span class=bp>()</span><span class=o>)</span> <span class=n>l</span> <span class=n>0</span>
</span></span></code></pre></div><p>The problem is that our specification requires $f$ to <em>return</em> to preserve the invariant, and does not say anything about exceptions.</p><p>The more general issue is that we are trying to abstract $f$'s behavior into a predicate of the underlying logic, and that limits expressiveness to that of the underlying logic.</p><p>This is the reason that, as mentioned earlier, many automated verifiers do not handle closures, because they lift function arguments into the pure, first-order logic of SMT, which cannot abstract over heap manipulation.
While separation logic can, it says nothing about exceptions/effects.
One would need some kind of (monadic) encoding or <a href=https://devilhena-paulo.github.io/thesis/de-vilhena-thesis.pdf>protocol</a>, a fundamentally different specification.</p><h1 id=staged-logic>Staged logic</h1><p>Taking a step back, why did we have to abstract away the behavior of $f$ to begin with?</p><p>The problem was that it was difficult to represent (1) unknown higher-order effectful calls and (2) ordering of effects precisely in pre/post specifications.
Our idea is thus to generalize Hoare triples with the ingredients required to represent them.</p><p>Suppose we think of the traditional $\mathbf{req}$ and $\mathbf{ens}$ as propositions in some new logical language $\varphi$ for describing effectful behavior.</p>$$\varphi ::= \req{P} \mid \ens{Q} \mid ...$$<p>$P$ and $Q$ are symbolic-heap separation logic formulae,</p>$$D,P,Q ::= \sigma{\wedge}\pi \quad \quad \quad \sigma ::= \emp \mid x{\mapsto}y \mid \sigma * \sigma \mid ...$$<p>and $\mathbf{req}$ may be thought of as a separation logic <em>assert</em> (or <em>exhale</em>, in Viper terms, which requires the presence of a portion of heap and consumes it), and $\mathbf{ens}$ as the dual notion of <em>assume</em> (or <em>inhale</em>, which produces a portion of heap).</p><p>We then extend this language with two new constructs: sequencing and (un)interpreted relations.</p>$$\varphi ::= \req{P} \mid \ens{Q} \mid \varphi; \varphi \mid f(x, r) \mid \exists x.\ \varphi \mid \varphi \vee \varphi$$<p>What is the semantics of such formulae? We defer a detailed answer to our paper<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>, but a first approximation is the following generalization, starting from the (partial correctness) semantics of Hoare triples.</p>$$
\begin{align*}
\{ P \}\ e\ \{ Q \} \equiv & \ \forall s, s'. \langle s, e \rangle \longrightarrow \langle s', v \rangle \wedge (s\vDash P) \Rightarrow \langle s',v \rangle \vDash Q \\
\{ P \}\ e\ \{ Q \} \equiv & \ \textbf{\{} \ens{\emp} \textbf{\}}\ e\ \textbf{\{} \req{P}; \ens{Q} \textbf{\}} \\
\end{align*}
$$<p>Suppose we redefined Hoare triples in terms of a new "bold" kind of triple, with the new formula type on both sides.
Intuitively, the formula on the left describes a "history", while the formula on the right describes the behavior of $e$ on top of that history.</p><p>This th a specific case of this new kind of triple.
The more general case could have its semantics defined as follows.</p>$$
\begin{align*}
\textbf{\{} \ens{\emp} \textbf{\}}\ e\ \textbf{\{} \varphi \textbf{\}} \equiv & \ \forall s, s'. \langle s, e \rangle \longrightarrow \langle s', v \rangle \Rightarrow \langle s, s', v \rangle \vDash \varphi
\end{align*}
$$<p>Now we can clearly see how this new kind of triple generalizes the standard one: where we previously had a precondition $P$ constraining the initial state $s$, and a postcondition $Q$ constraining the final state $s'$ and result $v$, we now have a formula constraining the same three things, with the ability to have an arbitrary number of assertions.</p><p>To give a flavour of some reasoning rules, here is the standard separation logic rule for load/deference, followed by our new one.</p>$$
\frac{}{\{x \mapsto y\}\ !x\ \{ r.\ x\mapsto y \wedge r =y \}} \text{\scriptsize SLDeref}
$$$$
\frac{}{\textbf{\{} \varphi \textbf{\}}\ !x\ \textbf{\{}\varphi; \exists y, r.\ \req{x\mapsto y}; \ens{r.\ x\mapsto y \wedge r=y} \textbf{\}}} \text{\scriptsize StDeref}
$$<p>It shouldn't be too surprising, as it mostly follows the schema we just presented.</p><p>The advantage of having the precondition on the right becomes clearer with the rule for function application, which is the first place where our new logic fundamentally differs.</p>$$
\frac{(\forall y.\ \{P_f\}\ f(y)\ \{ r.\ Q_f \}) \quad P \vdash P_f[x/y] * F}{\{P\}\ f(x)\ \{ r.\ Q_f[x/y] * F \} } \text{\scriptsize SLApp}
$$$$
\frac{}{\textbf{\{} \varphi \textbf{\}}\ f(x)\ \textbf{\{} \varphi; \exists r.\ f(x,r) \textbf{\}}} \text{\scriptsize StApp}
$$<p>First, we have the standard separation logic rule for function application. The key part is that some <em>knowledge</em> or <em>specification</em> of $f$ is required to prove that it is safe to call in a state satisfying $P$. Once this is done via the entailment on the right, a postcondition $Q_f$ (with appropriate substitutions) and frame $F$ are produced, allowing us to continue.</p><p>On the other hand, the new rule requires no knowledge of the function being called, and can hence work even when $f$ is completely unknown, as is the case when it is a possibly effectful function parameter.
Placing the precondition on the right essentially allows us to defer checking it until a later.</p><p>We call this new language of formulae <em>staged logic</em>. It consists of the following ingredients.</p><ol><li>Sequencing and uninterpreted relations</li><li>Recursive formulae</li><li>Re-summarization of recursion (lemmas)</li><li>Compact sequences of pre/post stages using biabduction</li></ol><p>The insight is that these allow us to <em>defer abstraction</em> until appropriate.</p><p>We go over each in turn using examples, then present solutions to the clients we couldn't verify earlier before concluding.</p><h2 id=effectful-placeholders>Effectful placeholders</h2><p>Consider the following toy heap-manipulating program. $hello$ is an effectful higher-order function, as it calls an unknown function $f$.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>hello</span> <span class=n>f</span> <span class=n>x</span> <span class=n>y</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=n>x</span> <span class=o>:=</span> <span class=o>!</span><span class=n>x</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>r</span> <span class=o>=</span> <span class=n>f</span> <span class=n>y</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>r2</span> <span class=o>=</span> <span class=o>!</span><span class=n>x</span> <span class=o>+</span> <span class=n>r</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=n>y</span> <span class=o>:=</span> <span class=n>r2</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>r2</span>
</span></span></code></pre></div><p>Here is a possible specification for it.</p>$$
\begin{array}{l}
\m{hello}(f, x, y, res) = \\
\quad \exists a.\ \req{x{\mapsto}a}; \ens{x{\mapsto}a{+}1} \\
\quad \exists r.\ f(y, r); \\
\quad \exists b.\ \req{x{\mapsto}b * y{\mapsto}\_}; \\
\quad \phantom{\exists b.\ } \ens{x{\mapsto}b * y{\mapsto}\m{res}{\wedge}\m{res}{=}b{+}r} \\
\end{array}
$$<p>Sequencing and uninterpreted relations together allow us to leave placeholders for unknown function parameters, to represent their effects.</p><p>Stateful behavior is otherwise <em>compacted</em> into a single $\textbf{req}$/$\textbf{ens}$ pair.</p><p>One might wonder why we must require the presence of $x$ and $y$ after the call to $f$.
For $y$, this is easy, as it is passed as an argument to $f$, and we have to require that it is not, e.g., deallocated.
Interestingly, we also cannot assume anything about $x$ after the call to $f$. As $f$ is unknown and arbitrary, it is possible that it may capture $x$ and cause it to have a potentially different value after, $b$.</p><p>Another detail is that this specification assumes that $x$ and $y$ are not aliased. Details on how to relax this assumption are in the paper<sup id=fnref1:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><h2 id=recursion>Recursion</h2><p>Recursive programs are naturally represented by recursive specifications.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>foldr</span> <span class=n>f</span> <span class=n>a</span> <span class=n>l</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>match</span> <span class=n>l</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span> <span class=o>=&gt;</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>h</span> <span class=o>::</span> <span class=n>t</span> <span class=o>=&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span> <span class=n>h</span> <span class=o>(</span><span class=n>foldr</span> <span class=n>f</span> <span class=n>a</span> <span class=n>t</span><span class=o>)</span>
</span></span></code></pre></div><p>here is a staged logic specification for it:</p>$$
\begin{array}{l}
\foldr(f, a, l, \m{res}) = \\
\quad \phantom{\vee\ } \ens{l{=}[]{\wedge}\m{res}{=}a} \\
\quad \vee\ \exists r, l_1.\ \ens{l{=}x{::}l_1}; \foldr(f, a, l_1, r); f(x, r, \m{res})
\end{array}
$$<p>Most importantly, the call to $f$ can be represented directly, without abstraction.</p><p>This specification looks very much like the program, because there is no state that could benefit from being expressed with separation logic.
However, it is still an abstraction of the program.</p><p>Comparing this to the previous specification, this time expressed as a single $\mathbf{req}$/$\mathbf{ens}$ pair in staged logic,</p>$$
\begin{array}{l}
\foldr(f, a, l, \m{res}) = \\
\quad \exists P, \inv, \xs.\ \req{\m{List(l, \xs)} * \inv([], a) \wedge \m{all}(P, \xs)} \\
\qquad \wedge f(x, a', r) \sqsubseteq (\exists ys.\ \req{\inv(\ys, a') \wedge P(x)}; \ens{\inv(x{::}\ys, r)}); \\
\quad \ens{\m{List}(l, \xs) * \inv(\xs, \m{res})}
\end{array}
$$<p>we see that it is longer and more complex, and contains all kinds of paramterization to make up for the inability to speak simply about ordering.
Leaving the recursion in the specification <em>before</em> we are aware of what clients expect (and thus, what kind of abstraction is appropriate) is what allows staged specifications to be more precise.</p><h2 id=re-summarization>Re-summarization</h2><p>We previously saw function calls represented without any abstraction in specifications, which probably wouldn't work well in large programs.
We would hence like to recover abstraction at some appropriate time.
That time tends to be at calls;
given a use of $\foldr$ such as the following, which passes a closure as an argument,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>foldr_sum_state</span> <span class=n>x</span> <span class=n>xs</span> <span class=n>init</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>g</span> <span class=n>c</span> <span class=n>t</span> <span class=o>=</span> <span class=n>x</span> <span class=o>:=</span> <span class=n>x</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span> <span class=n>c</span> <span class=o>+</span> <span class=n>t</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=n>foldr</span> <span class=n>g</span> <span class=n>xs</span> <span class=n>init</span>
</span></span></code></pre></div><p>and a user-provided specification (below), we can verify the above program by proving the following entailment.</p>$$
\begin{array}{rl}
& \forall x, \xs, \m{init}, \res.\ \m{foldr\_sum\_state}(x, \xs, \m{init}, \res) \\
\sqsubseteq & \exists i,r.\ \req{x{\mapsto}i}; \ens{x{\mapsto}i{+}r{\wedge}\res{=}r{+}\m{init}{\wedge}r{=}\m{sum}(\xs)}
\end{array}
$$<p>This may also be seen as a means of <em>recovering abstraction</em>,
or <em>re-summarizing</em> the relatively low-level staged specification,
to get rid of recursion and explicit occurrences of unknown functions
and produce a simpler, non-recursive summary of its behavior.</p><p>This example also demonstrates the utility of staged logic,
which allows us to very plainly state the effectful behavior of the program,
and also <em>prove the entailment automatically</em>.</p><p>In the paper<sup id=fnref2:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>, we define a set of syntactic proof rules for reducing $\sqsubseteq$-entailments (modulo <em>compaction</em>) into separation logic proof obligations,
which can be discharged using an off-the-shelf SL prover and SMT.
This particular proof uses an inferred (or provided, in general) induction hypothesis.</p><h2 id=compaction-via-biabduction>Compaction via biabduction</h2><p>The final piece is <em>compaction</em>, which allows us to have the expressiveness of stages, but also the <em>succinctness</em> of triples when the extra expressiveness is not needed.
In short, it allows any staged formula to always be transformed into the following normal form.</p>$$
\big(\req{\sigma{\wedge}\pi}; \ens{\sigma{\wedge}\pi}; f(x, r); \big)^* \req{\sigma{\wedge}\pi}; \ens{\sigma{\wedge}\pi}
$$<p>Compaction can be seen as a normalization procedure for (programs represented as) staged formulae.
This is key not only for entailment proofs, but for automation:
in our prototype, users only need to provide essential lemmas, and all other intermediate specifications are derived mechanically.
In this way, compaction functions as a means of specification inference in a verification setting.</p><p>We'll illustrate it by example on the heap-manipulating $\m{hello}$ program we saw earlier.</p>$$
\begin{array}{l}
\m{hello}(f, x, y, res) = \\
\quad \exists a.\ \req{x{\mapsto}a}; \ens{x{\mapsto}a{+}1} \\
\quad \exists r.\ f(y, r); \\
\quad \exists b.\ \req{x{\mapsto}b * y{\mapsto}\_}; \\
\quad \phantom{\exists b.\ } \ens{x{\mapsto}b * y{\mapsto}\m{res}{\wedge}\m{res}{=}b{+}r} \\
\end{array}
$$<p>This specification is already in normal form, but suppose we find out an interpretation for $f$, for example, from the following client.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>z</span> <span class=o>=</span> <span class=n>ref</span> <span class=n>0</span> <span class=k>in</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>y</span> <span class=o>=</span> <span class=n>ref</span> <span class=n>1</span> <span class=k>in</span>
</span></span><span class=line><span class=cl><span class=n>hello</span> <span class=o>(</span><span class=k>fun</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=n>incr</span> <span class=n>z</span><span class=o>;</span> <span class=n>0</span><span class=o>)</span> <span class=n>z</span> <span class=n>y</span>
</span></span></code></pre></div><p>Now we have the following interpretation for $f$.</p>$$f(\_,\res) = \exists c.\ \req{z{\mapsto}c}; \ens{z{\mapsto}c{\wedge}\res{=}0}$$<p>Unfolding $f$ in $\m{hello}$ (and doing some renaming),</p>$$
\begin{array}{l}
\m{hello}(f, z, y, res) = \\
\quad \exists a.\ \req{z{\mapsto}a}; \boxed{\ens{z{\mapsto}a{+}1}} \\
\quad \exists r,c.\ \boxed{\req{z{\mapsto}c}}; \ens{z{\mapsto}c{\wedge}r{=}0} \\
\quad \exists b.\ \req{z{\mapsto}b * y{\mapsto}\_}; \\
\quad \phantom{\exists b.\ } \ens{z{\mapsto}b * y{\mapsto}\m{res}{\wedge}\m{res}{=}b{+}r} \\
\end{array}
$$<p>This specification is not in normal form.
Focusing on the boxed portions, we see an $\mathbf{ens}$ followed by a $\mathbf{req}$.
We can apply the following normalization rule.</p>$$
\frac{D_A * D_1 \vdash D_2 * D_F}{\ens{D_1};\req{D_2} \Rightarrow \req{D_A}; \ens{D_F}}
$$<p>In other words, it suffices to solve a <a href=https://fbinfer.com/docs/separation-logic-and-bi-abduction/>biabductive entailment</a> to infer a pair of <em>frame</em> (in the separation logic sense) and <em>antiframe</em> (an additional condition $D_A$ required for $D_1$ to entail $D_2$).
We can then use these in place of the original conditions, "swapping" them around, or "pushing" the $\mathbf{req}$ "through" the $\mathbf{ens}$.</p><p>For this example, one solution is:</p>$$
z{\mapsto}a{+}1 * (a{+}1{=}c) \vdash z{\mapsto}c * \emp
$$<p>We can thus transform $\m{hello}$ as follow.</p>$$
\begin{array}{l}
\m{hello}(f, z, y, res) = \\
\quad \exists a.\ \boxed{\req{z{\mapsto}a}; \exists c.\ \req{a{+}1{=}c}} \\
\quad \exists r.\ \boxed{\ens{\emp}; \ens{z{\mapsto}c{\wedge}r{=}0}} \\
\quad \exists b.\ \req{z{\mapsto}b * y{\mapsto}\_}; \\
\quad \phantom{\exists b.\ } \ens{z{\mapsto}b * y{\mapsto}\m{res}{\wedge}\m{res}{=}b{+}r} \\
\end{array}
$$<p>Now we have two consecutive $\mathbf{req}$ and $\mathbf{ens}$ stages.
We can normalize them using the following rules.</p>$$
\req{D_1}; \req{D_2} \Rightarrow \req{(D_1 * D_2)} \\
\ens{D_1}; \ens{D_2} \Rightarrow \ens{(D_1 * D_2)}
$$<p>Now we have this, and again we have another $\mathbf{ens}$/$\mathbf{req}$ pair.</p>$$
\begin{array}{l}
\m{hello}(f, z, y, res) = \\
\quad \exists a,c.\ \req{z{\mapsto}a * a{+}1{=}c}; \\
\quad \exists r.\ \boxed{\ens{z{\mapsto}c{\wedge}r{=}0}} \\
\quad \exists b.\ \boxed{\req{z{\mapsto}b * y{\mapsto}\_}}; \\
\quad \phantom{\exists b.\ } \ens{z{\mapsto}b * y{\mapsto}\m{res}{\wedge}\m{res}{=}b{+}r} \\
\end{array}
$$<p>Here's the solution...</p>$$
z{\mapsto}c{+}1{\wedge}r{=}0 * (c{+}1{=}b{\wedge}y{\mapsto}\_) \vdash z{\mapsto}b * y{\mapsto}\_ * r{=}0
$$<p>... and final state, after one more round of simplification (not shown).</p>$$
\begin{array}{l}
\m{hello}(f, z, y, res) = \\
\quad \exists a,c.\ \req{z{\mapsto}a * y{\mapsto}\_ \wedge a{+}1{=}c{\wedge}c{+}1{=}b}; \\
\quad \exists b.\ \ens{z{\mapsto}b * y{\mapsto}\m{res}{\wedge}\m{res}{=}b}
\end{array}
$$<p>Now the specification for this call to $\m{hello}$ is in normal form, and we can use it for subsequent reasoning.
We see also that it precisely captures the aggregate behavior of this call, including the state changes.</p><h1 id=solutions-to-problematic-examples>Solutions to problematic examples</h1><p>Going back to the problematic clients we highlighted previously,
how can we tackle them using staged logic,
and how does the approach differ from the invariant-based way of writing specifications given in the introduction?</p><p>All the following assume the specification for $\foldr$ is as given in the previous section.
Crucially, none have to change it to solve all problems.</p><h2 id=example-1>Example 1</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>foldr_ex1</span> <span class=n>l</span> <span class=o>=</span> <span class=n>foldr</span> <span class=o>(</span><span class=k>fun</span> <span class=n>x</span> <span class=n>r</span> <span class=o>-&gt;</span> <span class=k>let</span> <span class=n>v</span> <span class=o>=</span> <span class=o>!</span><span class=n>x</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>                                    <span class=n>x</span> <span class=o>:=</span> <span class=n>v</span><span class=o>+</span><span class=n>1</span><span class=o>;</span> <span class=n>v</span><span class=o>+</span><span class=n>r</span><span class=o>)</span> <span class=n>l</span> <span class=n>0</span>
</span></span></code></pre></div><p>An invariant to tell us about the content of the list is not needed.
Instead, we describe the final content of the list in terms of the initial content using a pure function $\m{mapinc}$, alongside the result.
The list is described using a shape predicate.</p>$$
\begin{array}{rl}
& \m{foldr\_ex1}(l,\res) \\
\sqsubseteq & \exists \xs, \ys.\ \req{\list(l,\xs)}; \ens{\list(l,\ys){\wedge}\m{mapinc}(\xs){=}\ys{\wedge}\m{sum}(\xs){=}\res}
\end{array}
$$<h2 id=example-2>Example 2</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>foldr_ex2</span> <span class=n>l</span> <span class=o>=</span> <span class=n>foldr</span> <span class=o>(</span><span class=k>fun</span> <span class=n>x</span> <span class=n>r</span> <span class=o>-&gt;</span> <span class=k>assert</span><span class=o>(</span><span class=n>x</span><span class=o>+</span><span class=n>r</span><span class=o>&gt;=</span><span class=n>0</span><span class=o>);</span> <span class=n>x</span><span class=o>+</span><span class=n>r</span><span class=o>)</span> <span class=n>l</span> <span class=n>0</span>
</span></span></code></pre></div><p>To enable the assertion in the function argument to be proved, we explicate the assumption that all suffix-sums of the list are positive using a pure function of $l$. This can be directly given as part of the user-provided specificaton on the right.</p>$$
\m{foldr\_ex2}(l,\res) \sqsubseteq \req{\m{allSPos}(l)}; \ens{\m{sum}(l,\res)}
$$<p>In this example, we are not concerned with shapes, and fittingly, shape predicates do not appear at all in the specification or lemma.</p><h2 id=example-3>Example 3</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>foldr_ex3</span> <span class=n>l</span> <span class=o>=</span> <span class=n>foldr</span> <span class=o>(</span><span class=k>fun</span> <span class=n>x</span> <span class=n>r</span> <span class=o>-&gt;</span> <span class=k>if</span> <span class=n>x</span><span class=o>&gt;=</span><span class=n>0</span> <span class=k>then</span> <span class=n>x</span><span class=o>+</span><span class=n>r</span>
</span></span><span class=line><span class=cl>                                    <span class=k>else</span> <span class=k>raise</span> <span class=nc>Exc</span><span class=bp>()</span><span class=o>)</span> <span class=n>l</span> <span class=n>0</span>
</span></span></code></pre></div><p>An exception can be modelled as an <em>interpreted</em> relation (more on the semantics of handlers in our ICFP 2024 paper<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>).</p><p>We can give a precise description of the conditions under which an exception is thrown via the following entailment.</p>$$
\m{foldr\_ex3}(l,\res) \sqsubseteq \ens{\m{allPos}(l){\wedge}\m{sum}(l,\res) \vee \ens{\neg\m{allPos}(l)}; \m{Exc}()}
$$<p>The underlying logic is still symbolic-heap separation logic; we do not delegate effects to it.
Staged logic may thus be seen as a behavioral layer on top of separation logic, which excels when one is describing individual program states.</p><h1 id=conclusion>Conclusion</h1><p>We have described <em>staged logic</em>, a generalization of Hoare triples for specifying effectful higher-order programs and verifying them in an automated setting.</p><p>It fits well into the standard workflow of automated program verifiers:
given a program and a property it should satisfy,
a staged formula is derived from the program,
and the resulting entailment is automatically proved,
with lemmas and induction hypotheses provided by the user.</p><p>Since staged logic generalizes Hoare logic,
one can easily "fall back" to triples in cases where the expressiveness of stages is not needed,
and employ abstraction, invariants, and all the other techniques which have been developed for program proofs.
There is no need to always specify programs as disjunctions of paths, or always capture the ordering of every function call and effect,
however the crucial thing is that <em>the option to do so is available</em> where it makes specifications more natural.</p><p>Check out our paper<sup id=fnref3:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> for the details.</p><p>These ideas have been implemented in a prototype verifier called <a href=https://github.com/hipsleek/heifer>Heifer</a>, which we hope will grow into a practical verification tool for real programs.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Taken from the <a href=https://iris-project.org/tutorial-pdfs/iris-lecture-notes.pdf>Iris lecture notes</a>, pg 32&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Our FM24 paper may be found <a href=https://raw.githubusercontent.com/hipsleek/Heifer/StagedSL/docs/FM2024_TR.pdf>here</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref2:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref3:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Our ICFP24 paper may be found <a href=https://www.comp.nus.edu.sg/~yahuis/ICFP24/ICFP2024.pdf>here</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><p></p></main><footer></footer></body></html>