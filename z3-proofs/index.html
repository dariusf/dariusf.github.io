<!doctype html><html lang=en-US><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://dariusf.github.io/images/favicon.png><title>Visualizing Z3's proofs | Darius Foo</title>
<meta name=title content="Visualizing Z3's proofs"><meta name=description content="A writeup of a presentation I gave in class.
SMT solvers like Z3 are often also called automated theorem provers. Why? What do their proofs look like?
An SMT solver tells us if a formula in first-order logic (augmented with various theories) is satisfiable1: there is some assignment of variables that makes the formula true. Z3 can even produce such an assignment.
from z3 import *

i = Int('i')
solve(i > 0)
[i = 1]
Not every formula is satisfiable, though. In that case, there are two possibilities."><meta name=keywords content><meta property="og:url" content="https://dariusf.github.io/z3-proofs/"><meta property="og:site_name" content="Darius Foo"><meta property="og:title" content="Visualizing Z3's proofs"><meta property="og:description" content="A writeup of a presentation I gave in class.
SMT solvers like Z3 are often also called automated theorem provers. Why? What do their proofs look like?
An SMT solver tells us if a formula in first-order logic (augmented with various theories) is satisfiable1: there is some assignment of variables that makes the formula true. Z3 can even produce such an assignment.
from z3 import * i = Int('i') solve(i > 0) [i = 1] Not every formula is satisfiable, though. In that case, there are two possibilities."><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-03-21T12:00:06+08:00"><meta property="article:modified_time" content="2021-03-21T12:00:06+08:00"><meta property="og:image" content="https://dariusf.github.io/images/favicon.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dariusf.github.io/images/favicon.png"><meta name=twitter:title content="Visualizing Z3's proofs"><meta name=twitter:description content="A writeup of a presentation I gave in class.
SMT solvers like Z3 are often also called automated theorem provers. Why? What do their proofs look like?
An SMT solver tells us if a formula in first-order logic (augmented with various theories) is satisfiable1: there is some assignment of variables that makes the formula true. Z3 can even produce such an assignment.
from z3 import * i = Int('i') solve(i > 0) [i = 1] Not every formula is satisfiable, though. In that case, there are two possibilities."><meta itemprop=name content="Visualizing Z3's proofs"><meta itemprop=description content="A writeup of a presentation I gave in class.
SMT solvers like Z3 are often also called automated theorem provers. Why? What do their proofs look like?
An SMT solver tells us if a formula in first-order logic (augmented with various theories) is satisfiable1: there is some assignment of variables that makes the formula true. Z3 can even produce such an assignment.
from z3 import * i = Int('i') solve(i > 0) [i = 1] Not every formula is satisfiable, though. In that case, there are two possibilities."><meta itemprop=datePublished content="2021-03-21T12:00:06+08:00"><meta itemprop=dateModified content="2021-03-21T12:00:06+08:00"><meta itemprop=wordCount content="602"><meta itemprop=image content="https://dariusf.github.io/images/favicon.png"><meta name=referrer content="no-referrer-when-downgrade"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Code"><style>@media(prefers-color-scheme:light){:root{--bright-text-color:#222;--link-color:#3273dc;--link-visited-color:#6e4bbe;--background-color:#fff;--text-color:#444;--faded-text-color:#777;--blockquote-text-color:var(--bright-text-color);--faint-color:#ccc}.chroma{background-color:#fff}.chroma .x{}.chroma .err{color:#000}.chroma .lntd{vertical-align:top;padding:0;margin:0;border:0}.chroma .lntable{border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block}.chroma .hl{display:block;width:100%;background-color:#ffc}.chroma .lnt{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .ln{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .k{color:#a90d91}.chroma .kc{color:#a90d91}.chroma .kd{color:#a90d91}.chroma .kn{color:#a90d91}.chroma .kp{color:#a90d91}.chroma .kr{color:#a90d91}.chroma .kt{color:#a90d91}.chroma .n{color:#000}.chroma .na{color:#836c28}.chroma .nb{color:#a90d91}.chroma .bp{color:#5b269a}.chroma .nc{color:#3f6e75}.chroma .no{color:#000}.chroma .nd{color:#000}.chroma .ni{color:#000}.chroma .ne{color:#000}.chroma .nf{color:#000}.chroma .fm{color:#000}.chroma .nl{color:#000}.chroma .nn{color:#000}.chroma .nx{color:#000}.chroma .py{color:#000}.chroma .nt{color:#000}.chroma .nv{color:#000}.chroma .vc{color:#000}.chroma .vg{color:#000}.chroma .vi{color:#000}.chroma .vm{color:#000}.chroma .l{color:#1c01ce}.chroma .ld{color:#1c01ce}.chroma .s{color:#c41a16}.chroma .sa{color:#c41a16}.chroma .sb{color:#c41a16}.chroma .sc{color:#2300ce}.chroma .dl{color:#c41a16}.chroma .sd{color:#c41a16}.chroma .s2{color:#c41a16}.chroma .se{color:#c41a16}.chroma .sh{color:#c41a16}.chroma .si{color:#c41a16}.chroma .sx{color:#c41a16}.chroma .sr{color:#c41a16}.chroma .s1{color:#c41a16}.chroma .ss{color:#c41a16}.chroma .m{color:#1c01ce}.chroma .mb{color:#1c01ce}.chroma .mf{color:#1c01ce}.chroma .mh{color:#1c01ce}.chroma .mi{color:#1c01ce}.chroma .il{color:#1c01ce}.chroma .mo{color:#1c01ce}.chroma .o{color:#000}.chroma .ow{color:#000}.chroma .p{}.chroma .c{color:#177500}.chroma .ch{color:#177500}.chroma .cm{color:#177500}.chroma .c1{color:#177500}.chroma .cs{color:#177500}.chroma .cp{color:#633820}.chroma .cpf{color:#633820}.chroma .g{}.chroma .gd{}.chroma .ge{}.chroma .gr{}.chroma .gh{}.chroma .gi{}.chroma .go{}.chroma .gp{}.chroma .gs{}.chroma .gu{}.chroma .gt{}.chroma .gl{}.chroma .w{}}@media(prefers-color-scheme:dark){:root{--bright-text-color:#eee;--link-color:#8cc2dd;--link-visited-color:#b9a9e0;--background-color:#333;--text-color:#ddd;--faded-text-color:#aaa;--slightly-dimmer-text-color:#ccc;--blockquote-text-color:var(--slightly-dimmer-text-color);--faint-color:#666;color-scheme:dark}img.theme-affected{filter:invert(.8)}.chroma{color:#e2e4e5;background-color:#282a36}.chroma .x{}.chroma .err{color:#ff5c57}.chroma .lntd{vertical-align:top;padding:0;margin:0;border:0}.chroma .lntable{border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block}.chroma .hl{display:block;width:100%;background-color:#ffc}.chroma .lnt{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .ln{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .k{color:#ff6ac1}.chroma .kc{color:#ff6ac1}.chroma .kd{color:#ff5c57}.chroma .kn{color:#ff6ac1}.chroma .kp{color:#ff6ac1}.chroma .kr{color:#ff6ac1}.chroma .kt{color:#9aedfe}.chroma .n{}.chroma .na{color:#57c7ff}.chroma .nb{color:#ff5c57}.chroma .bp{}.chroma .nc{color:#f3f99d}.chroma .no{color:#ff9f43}.chroma .nd{color:#ff9f43}.chroma .ni{}.chroma .ne{}.chroma .nf{color:#57c7ff}.chroma .fm{}.chroma .nl{color:#ff5c57}.chroma .nn{}.chroma .nx{}.chroma .py{}.chroma .nt{color:#ff6ac1}.chroma .nv{color:#ff5c57}.chroma .vc{color:#ff5c57}.chroma .vg{color:#ff5c57}.chroma .vi{color:#ff5c57}.chroma .vm{}.chroma .l{}.chroma .ld{}.chroma .s{color:#5af78e}.chroma .sa{color:#5af78e}.chroma .sb{color:#5af78e}.chroma .sc{color:#5af78e}.chroma .dl{color:#5af78e}.chroma .sd{color:#5af78e}.chroma .s2{color:#5af78e}.chroma .se{color:#5af78e}.chroma .sh{color:#5af78e}.chroma .si{color:#5af78e}.chroma .sx{color:#5af78e}.chroma .sr{color:#5af78e}.chroma .s1{color:#5af78e}.chroma .ss{color:#5af78e}.chroma .m{color:#ff9f43}.chroma .mb{color:#ff9f43}.chroma .mf{color:#ff9f43}.chroma .mh{color:#ff9f43}.chroma .mi{color:#ff9f43}.chroma .il{color:#ff9f43}.chroma .mo{color:#ff9f43}.chroma .o{color:#ff6ac1}.chroma .ow{color:#ff6ac1}.chroma .p{}.chroma .c{color:#78787e}.chroma .ch{color:#78787e}.chroma .cm{color:#78787e}.chroma .c1{color:#78787e}.chroma .cs{color:#78787e}.chroma .cp{color:#78787e}.chroma .cpf{color:#78787e}.chroma .g{}.chroma .gd{color:#ff5c57}.chroma .ge{text-decoration:underline}.chroma .gr{color:#ff5c57}.chroma .gh{font-weight:700}.chroma .gi{font-weight:700}.chroma .go{color:#43454f}.chroma .gp{}.chroma .gs{font-style:italic}.chroma .gu{font-weight:700}.chroma .gt{}.chroma .gl{text-decoration:underline}.chroma .w{}}:root{--heading-font:ui-rounded, 'Hiragino Maru Gothic ProN', Quicksand, Comfortaa, Manjari, 'Arial Rounded MT', 'Arial Rounded MT Bold', Calibri, source-sans-pro, sans-serif;--text-font-size:17px;--text-font:system-ui, sans-serif}*{margin:0}body{}main{margin-top:.75em}sup{vertical-align:top;font-size:.7em}p{margin-bottom:1em}html{overflow-x:hidden;margin-right:calc(-1 * (100vw - 100%))}body{font-family:var(--text-font);font-size:var(--text-font-size);margin:auto;padding:20px;max-width:720px;text-align:left;background-color:var(--background-color);color:var(--text-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5}h1,h2,h3,h4,h5,h6{font-family:var(--heading-font);color:var(--bright-text-color);font-weight:400}.blog-content h1,.blog-content h2,.blog-content h3,.blog-content h4,.blog-content h5,.blog-content h6{margin-top:.5em}hr,ul,ol{margin-bottom:.5em}div>iframe{margin-bottom:.5em}.blog-timestamp{font-size:.9em}.blog-content{margin-top:1.5em}a{color:var(--link-color);text-decoration:none}.title{color:var(--text-color);font-size:1.5em;font-family:var(--heading-font);margin-right:10px}nav a{margin-right:8px;font-family:var(--heading-font)}.paper-item svg{width:16px;vertical-align:text-bottom}.menuactive{text-decoration:underline;text-decoration-thickness:2px}table{width:100%}img{max-width:100%;margin:auto;margin-bottom:.5em;display:block}code{padding:2px 5px;margin-bottom:1em;font-family:Fira Code,monospace;font-size:14px;line-height:1.4}pre code{display:block;padding:20px;white-space:pre-wrap;overflow-x:auto}pre{border-radius:10px}p code,ol code,ul code,summary code{border-radius:4px;border:solid var(--faint-color)1px;margin:0 2px;padding:1px 2px}blockquote{border-left:1px solid #999;color:var(--blockquote-text-color);padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.deemphasize{color:var(--faded-text-color)}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px;text-align:right;margin-right:20px}ul.blog-posts li a:visited{color:var(--link-visited-color)}</style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script>const macros={};function render(){renderMathInElement(document.body,{trust:!0,strict:!1,throwOnError:!1,delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros})}</script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=render()></script></head><body><header><a href=/><span class=title>Darius Foo</span></a><nav style=display:inline-block><a href=/blog/>Blog</a>
<a href=/research/>Research</a>
<a href=/work/>Work</a>
<a href=/other/>Other</a></nav></header><main><h1>Visualizing Z3's proofs</h1><div><time class=blog-timestamp datetime=2021-03-21 pubdate>21 Mar, 2021</time></div><div class=blog-content><p><em>A writeup of a presentation I gave in class.</em></p><p>SMT solvers like Z3 are often also called automated theorem provers. Why? What do their proofs look like?</p><p>An SMT solver tells us if a formula in first-order logic (augmented with various theories) is <em>satisfiable</em><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>: there is some assignment of variables that makes the formula true. Z3 can even produce such an assignment.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>z3</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>i</span> <span class=o>=</span> <span class=n>Int</span><span class=p>(</span><span class=s1>&#39;i&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>solve</span><span class=p>(</span><span class=n>i</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=p>[</span><span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>]</span>
</span></span></code></pre></div><p>Not every formula is satisfiable, though. In that case, there are two possibilities.</p><p>Z3 can say <code>unknown</code>. This is the less interesting one. It means that Z3 ran out of time or memory, or the algorithm it uses to find the assignment is incomplete, or the problem itself is unsolvable in general. In other words, we don't know for sure if an assignment does not exist.</p><p>The other outcome is <code>unsat</code>.
This is a much stronger statement than satisfiability, as it means that <em>every</em> assignment of variables must not work.</p><p>This has something of the flavour of proving a theorem, where we aim to convince ourselves that a formula is true for <em>every</em> assignment of variables.</p><p>We can connect these two views by expressing the theorem we want to prove instead as the non-existence of a <em>refutation</em>, or counterexample, to it.
We do this by negating the formula and asking, "is it possible that there is some way for this formula not to be true?"
<code>unsat</code> means no, i.e. the theorem is always true.</p><h2 id=z3s-proofs>Z3's proofs</h2><p>Z3 has facilities for explaining its deductions, in the form of proofs.
Let's try them on a really simple theorem, $\exists a. a = a$.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>z3</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>set_param</span><span class=p>(</span><span class=n>proof</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>Solver</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Bool</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>f</span> <span class=o>=</span> <span class=n>a</span> <span class=o>==</span> <span class=n>a</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>Not</span><span class=p>(</span><span class=n>f</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>res</span> <span class=o>=</span> <span class=n>s</span><span class=o>.</span><span class=n>check</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>res</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>res</span> <span class=o>==</span> <span class=n>sat</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=nb>print</span><span class=p>(</span><span class=n>s</span><span class=o>.</span><span class=n>model</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span> <span class=o>=</span> <span class=n>s</span><span class=o>.</span><span class=n>proof</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=nb>print</span><span class=p>(</span><span class=n>p</span><span class=p>)</span>
</span></span></code></pre></div><p>Something to note that is that variables in SMT are implicitly existentially quantified. Therefore we are searching for a counterexample by seeing if $\forall a. a \neq a$ is satisfiable.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>unsat</span>
</span></span><span class=line><span class=cl><span class=n>mp</span><span class=p>(</span><span class=n>asserted</span><span class=p>(</span><span class=n>Not</span><span class=p>(</span><span class=n>a</span> <span class=o>==</span> <span class=n>a</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>   <span class=n>trans</span><span class=p>(</span><span class=n>monotonicity</span><span class=p>(</span><span class=n>rewrite</span><span class=p>((</span><span class=n>a</span> <span class=o>==</span> <span class=n>a</span><span class=p>)</span> <span class=o>==</span> <span class=kc>True</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                      <span class=n>Not</span><span class=p>(</span><span class=n>a</span> <span class=o>==</span> <span class=n>a</span><span class=p>)</span> <span class=o>==</span> <span class=n>Not</span><span class=p>(</span><span class=kc>True</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>         <span class=n>rewrite</span><span class=p>(</span><span class=n>Not</span><span class=p>(</span><span class=kc>True</span><span class=p>)</span> <span class=o>==</span> <span class=kc>False</span><span class=p>),</span>
</span></span><span class=line><span class=cl>         <span class=n>Not</span><span class=p>(</span><span class=n>a</span> <span class=o>==</span> <span class=n>a</span><span class=p>)</span> <span class=o>==</span> <span class=kc>False</span><span class=p>),</span>
</span></span><span class=line><span class=cl>   <span class=kc>False</span><span class=p>)</span>
</span></span></code></pre></div><p>Unsurprisingly, it is not.
Z3 outputs a <em>proof tree</em>, which we can traverse and pretty-print.</p><img src=/images/z3proof1.png class=theme-affected><p>Firstly, we see that the conclusion at the bottom is <code>False</code>.
This may seem odd, but recall that the goal is to show that negation of the original theorem cannot be proved, so this is the only conclusion which makes sense.</p><p>Next, we see some of Z3's inference rules<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> in action.
Our original goal is <code>asserted</code>.
We have two instances of <code>rewrite</code>, where built-in equalities are used to simplify terms.
There is an application of <code>monotonicity</code>, where we negate both sides.
Finally we use the <code>trans</code>itivity of equality and modus ponens to derive the conclusion.</p><p>Let's try $\exists a. a = \neg (\neg a)$.</p><img src=/images/z3proof2.png class=theme-affected><p>And here's another for the linear arithmetic formula $\exists x y. 2 x \leq 3 y, y > x, x > 0$.</p><img src=/images/z3proof3.png class=theme-affected><p>Clearly, these generated proofs quickly get too large to be comprehensible.
They're also largely mechanical and not very meaningful.
Still, it's intriguing to see the automated reasoning that Z3 performs.</p><p>A final point about the last one is the application of the rule <code>th-lemma</code> to derive the conclusion.</p><img src=/images/z3proof4.png class=theme-affected><p>This is a theory lemma, a placeholder rule for a possibly-opaque decision from a theory solver.</p><p>If you want to generate these proofs yourself, the code is <a href=https://gist.github.com/dariusf/1fbb17816bea7417e4a104d58d2053d8>here</a>.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>For a more thorough introduction to satisfiability, check out <a href=https://homes.cs.washington.edu/~emina/blog/2017-06-23-a-primer-on-sat.html#satisfiability-and-validity>this blog post</a>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>There's a more complete list of rules in Section 3.3 of <a href=https://www21.in.tum.de/~boehmes/proofrec.pdf>this paper</a>.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><p></p></main><footer></footer></body></html>