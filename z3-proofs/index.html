<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="shortcut icon" href="https://dariusf.github.io/images/favicon.png" />
<title>Visualizing Z3&#39;s proofs | Darius Foo</title>
<meta name="title" content="Visualizing Z3&#39;s proofs" />
<meta name="description" content="A writeup of a presentation I gave in class.
SMT solvers like Z3 are often also called automated theorem provers. Why? What do their proofs look like?
An SMT solver tells us if a formula in first-order logic (augmented with various theories) is satisfiable1: there is some assignment of variables that makes the formula true. Z3 can even produce such an assignment.
from z3 import * i = Int(&#39;i&#39;) solve(i &gt; 0) [i = 1] Not every formula is satisfiable, though." />
<meta name="keywords" content="" />


<meta property="og:title" content="Visualizing Z3&#39;s proofs" />
<meta property="og:description" content="A writeup of a presentation I gave in class.
SMT solvers like Z3 are often also called automated theorem provers. Why? What do their proofs look like?
An SMT solver tells us if a formula in first-order logic (augmented with various theories) is satisfiable1: there is some assignment of variables that makes the formula true. Z3 can even produce such an assignment.
from z3 import * i = Int(&#39;i&#39;) solve(i &gt; 0) [i = 1] Not every formula is satisfiable, though." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dariusf.github.io/z3-proofs/" /><meta property="og:image" content="https://dariusf.github.io/images/favicon.png"/><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2021-03-21T12:00:06+08:00" />
<meta property="article:modified_time" content="2021-03-21T12:00:06+08:00" /><meta property="og:site_name" content="Darius Foo" />




<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://dariusf.github.io/images/favicon.png"/>

<meta name="twitter:title" content="Visualizing Z3&#39;s proofs"/>
<meta name="twitter:description" content="A writeup of a presentation I gave in class.
SMT solvers like Z3 are often also called automated theorem provers. Why? What do their proofs look like?
An SMT solver tells us if a formula in first-order logic (augmented with various theories) is satisfiable1: there is some assignment of variables that makes the formula true. Z3 can even produce such an assignment.
from z3 import * i = Int(&#39;i&#39;) solve(i &gt; 0) [i = 1] Not every formula is satisfiable, though."/>



<meta itemprop="name" content="Visualizing Z3&#39;s proofs">
<meta itemprop="description" content="A writeup of a presentation I gave in class.
SMT solvers like Z3 are often also called automated theorem provers. Why? What do their proofs look like?
An SMT solver tells us if a formula in first-order logic (augmented with various theories) is satisfiable1: there is some assignment of variables that makes the formula true. Z3 can even produce such an assignment.
from z3 import * i = Int(&#39;i&#39;) solve(i &gt; 0) [i = 1] Not every formula is satisfiable, though."><meta itemprop="datePublished" content="2021-03-21T12:00:06+08:00" />
<meta itemprop="dateModified" content="2021-03-21T12:00:06+08:00" />
<meta itemprop="wordCount" content="602"><meta itemprop="image" content="https://dariusf.github.io/images/favicon.png"/>
<meta itemprop="keywords" content="" />
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>

  @media (prefers-color-scheme: light) {
    :root {
      --bright-text-color: #222;
      --link-color: #3273dc;
       
      --link-visited-color: #6e4bbe;
      --background-color: #fff;
      --text-color: #444;
      --faded-text-color: #777;
      --blockquote-text-color: var(--bright-text-color);
      --faint-color: #ccc;
    }

    /* Background */ .chroma { background-color: #ffffff }
/* Other */ .chroma .x {  }
/* Error */ .chroma .err { color: #000000 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%;background-color: #ffffcc }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em;color: #7f7f7f }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em;color: #7f7f7f }
/* Keyword */ .chroma .k { color: #a90d91 }
/* KeywordConstant */ .chroma .kc { color: #a90d91 }
/* KeywordDeclaration */ .chroma .kd { color: #a90d91 }
/* KeywordNamespace */ .chroma .kn { color: #a90d91 }
/* KeywordPseudo */ .chroma .kp { color: #a90d91 }
/* KeywordReserved */ .chroma .kr { color: #a90d91 }
/* KeywordType */ .chroma .kt { color: #a90d91 }
/* Name */ .chroma .n { color: #000000 }
/* NameAttribute */ .chroma .na { color: #836c28 }
/* NameBuiltin */ .chroma .nb { color: #a90d91 }
/* NameBuiltinPseudo */ .chroma .bp { color: #5b269a }
/* NameClass */ .chroma .nc { color: #3f6e75 }
/* NameConstant */ .chroma .no { color: #000000 }
/* NameDecorator */ .chroma .nd { color: #000000 }
/* NameEntity */ .chroma .ni { color: #000000 }
/* NameException */ .chroma .ne { color: #000000 }
/* NameFunction */ .chroma .nf { color: #000000 }
/* NameFunctionMagic */ .chroma .fm { color: #000000 }
/* NameLabel */ .chroma .nl { color: #000000 }
/* NameNamespace */ .chroma .nn { color: #000000 }
/* NameOther */ .chroma .nx { color: #000000 }
/* NameProperty */ .chroma .py { color: #000000 }
/* NameTag */ .chroma .nt { color: #000000 }
/* NameVariable */ .chroma .nv { color: #000000 }
/* NameVariableClass */ .chroma .vc { color: #000000 }
/* NameVariableGlobal */ .chroma .vg { color: #000000 }
/* NameVariableInstance */ .chroma .vi { color: #000000 }
/* NameVariableMagic */ .chroma .vm { color: #000000 }
/* Literal */ .chroma .l { color: #1c01ce }
/* LiteralDate */ .chroma .ld { color: #1c01ce }
/* LiteralString */ .chroma .s { color: #c41a16 }
/* LiteralStringAffix */ .chroma .sa { color: #c41a16 }
/* LiteralStringBacktick */ .chroma .sb { color: #c41a16 }
/* LiteralStringChar */ .chroma .sc { color: #2300ce }
/* LiteralStringDelimiter */ .chroma .dl { color: #c41a16 }
/* LiteralStringDoc */ .chroma .sd { color: #c41a16 }
/* LiteralStringDouble */ .chroma .s2 { color: #c41a16 }
/* LiteralStringEscape */ .chroma .se { color: #c41a16 }
/* LiteralStringHeredoc */ .chroma .sh { color: #c41a16 }
/* LiteralStringInterpol */ .chroma .si { color: #c41a16 }
/* LiteralStringOther */ .chroma .sx { color: #c41a16 }
/* LiteralStringRegex */ .chroma .sr { color: #c41a16 }
/* LiteralStringSingle */ .chroma .s1 { color: #c41a16 }
/* LiteralStringSymbol */ .chroma .ss { color: #c41a16 }
/* LiteralNumber */ .chroma .m { color: #1c01ce }
/* LiteralNumberBin */ .chroma .mb { color: #1c01ce }
/* LiteralNumberFloat */ .chroma .mf { color: #1c01ce }
/* LiteralNumberHex */ .chroma .mh { color: #1c01ce }
/* LiteralNumberInteger */ .chroma .mi { color: #1c01ce }
/* LiteralNumberIntegerLong */ .chroma .il { color: #1c01ce }
/* LiteralNumberOct */ .chroma .mo { color: #1c01ce }
/* Operator */ .chroma .o { color: #000000 }
/* OperatorWord */ .chroma .ow { color: #000000 }
/* Punctuation */ .chroma .p {  }
/* Comment */ .chroma .c { color: #177500 }
/* CommentHashbang */ .chroma .ch { color: #177500 }
/* CommentMultiline */ .chroma .cm { color: #177500 }
/* CommentSingle */ .chroma .c1 { color: #177500 }
/* CommentSpecial */ .chroma .cs { color: #177500 }
/* CommentPreproc */ .chroma .cp { color: #633820 }
/* CommentPreprocFile */ .chroma .cpf { color: #633820 }
/* Generic */ .chroma .g {  }
/* GenericDeleted */ .chroma .gd {  }
/* GenericEmph */ .chroma .ge {  }
/* GenericError */ .chroma .gr {  }
/* GenericHeading */ .chroma .gh {  }
/* GenericInserted */ .chroma .gi {  }
/* GenericOutput */ .chroma .go {  }
/* GenericPrompt */ .chroma .gp {  }
/* GenericStrong */ .chroma .gs {  }
/* GenericSubheading */ .chroma .gu {  }
/* GenericTraceback */ .chroma .gt {  }
/* GenericUnderline */ .chroma .gl {  }
/* TextWhitespace */ .chroma .w {  }

  }

  @media (prefers-color-scheme: dark) {
    :root {
      --bright-text-color: #eee;
      --link-color: #8cc2dd;
      --link-visited-color: #b9a9e0;
      --background-color: #333;
      --text-color: #ddd;
      --faded-text-color: #aaa;
      --slightly-dimmer-text-color: #ccc;
      --blockquote-text-color: var(--slightly-dimmer-text-color);
      --faint-color: #666;

      color-scheme: dark;  
    }

     

    img.diagram {
      filter: invert(.8);
    }

    /* Background */ .chroma { color: #e2e4e5; background-color: #282a36 }
/* Other */ .chroma .x {  }
/* Error */ .chroma .err { color: #ff5c57 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%;background-color: #ffffcc }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em;color: #7f7f7f }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em;color: #7f7f7f }
/* Keyword */ .chroma .k { color: #ff6ac1 }
/* KeywordConstant */ .chroma .kc { color: #ff6ac1 }
/* KeywordDeclaration */ .chroma .kd { color: #ff5c57 }
/* KeywordNamespace */ .chroma .kn { color: #ff6ac1 }
/* KeywordPseudo */ .chroma .kp { color: #ff6ac1 }
/* KeywordReserved */ .chroma .kr { color: #ff6ac1 }
/* KeywordType */ .chroma .kt { color: #9aedfe }
/* Name */ .chroma .n {  }
/* NameAttribute */ .chroma .na { color: #57c7ff }
/* NameBuiltin */ .chroma .nb { color: #ff5c57 }
/* NameBuiltinPseudo */ .chroma .bp {  }
/* NameClass */ .chroma .nc { color: #f3f99d }
/* NameConstant */ .chroma .no { color: #ff9f43 }
/* NameDecorator */ .chroma .nd { color: #ff9f43 }
/* NameEntity */ .chroma .ni {  }
/* NameException */ .chroma .ne {  }
/* NameFunction */ .chroma .nf { color: #57c7ff }
/* NameFunctionMagic */ .chroma .fm {  }
/* NameLabel */ .chroma .nl { color: #ff5c57 }
/* NameNamespace */ .chroma .nn {  }
/* NameOther */ .chroma .nx {  }
/* NameProperty */ .chroma .py {  }
/* NameTag */ .chroma .nt { color: #ff6ac1 }
/* NameVariable */ .chroma .nv { color: #ff5c57 }
/* NameVariableClass */ .chroma .vc { color: #ff5c57 }
/* NameVariableGlobal */ .chroma .vg { color: #ff5c57 }
/* NameVariableInstance */ .chroma .vi { color: #ff5c57 }
/* NameVariableMagic */ .chroma .vm {  }
/* Literal */ .chroma .l {  }
/* LiteralDate */ .chroma .ld {  }
/* LiteralString */ .chroma .s { color: #5af78e }
/* LiteralStringAffix */ .chroma .sa { color: #5af78e }
/* LiteralStringBacktick */ .chroma .sb { color: #5af78e }
/* LiteralStringChar */ .chroma .sc { color: #5af78e }
/* LiteralStringDelimiter */ .chroma .dl { color: #5af78e }
/* LiteralStringDoc */ .chroma .sd { color: #5af78e }
/* LiteralStringDouble */ .chroma .s2 { color: #5af78e }
/* LiteralStringEscape */ .chroma .se { color: #5af78e }
/* LiteralStringHeredoc */ .chroma .sh { color: #5af78e }
/* LiteralStringInterpol */ .chroma .si { color: #5af78e }
/* LiteralStringOther */ .chroma .sx { color: #5af78e }
/* LiteralStringRegex */ .chroma .sr { color: #5af78e }
/* LiteralStringSingle */ .chroma .s1 { color: #5af78e }
/* LiteralStringSymbol */ .chroma .ss { color: #5af78e }
/* LiteralNumber */ .chroma .m { color: #ff9f43 }
/* LiteralNumberBin */ .chroma .mb { color: #ff9f43 }
/* LiteralNumberFloat */ .chroma .mf { color: #ff9f43 }
/* LiteralNumberHex */ .chroma .mh { color: #ff9f43 }
/* LiteralNumberInteger */ .chroma .mi { color: #ff9f43 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #ff9f43 }
/* LiteralNumberOct */ .chroma .mo { color: #ff9f43 }
/* Operator */ .chroma .o { color: #ff6ac1 }
/* OperatorWord */ .chroma .ow { color: #ff6ac1 }
/* Punctuation */ .chroma .p {  }
/* Comment */ .chroma .c { color: #78787e }
/* CommentHashbang */ .chroma .ch { color: #78787e }
/* CommentMultiline */ .chroma .cm { color: #78787e }
/* CommentSingle */ .chroma .c1 { color: #78787e }
/* CommentSpecial */ .chroma .cs { color: #78787e }
/* CommentPreproc */ .chroma .cp { color: #78787e }
/* CommentPreprocFile */ .chroma .cpf { color: #78787e }
/* Generic */ .chroma .g {  }
/* GenericDeleted */ .chroma .gd { color: #ff5c57 }
/* GenericEmph */ .chroma .ge { text-decoration: underline }
/* GenericError */ .chroma .gr { color: #ff5c57 }
/* GenericHeading */ .chroma .gh { font-weight: bold }
/* GenericInserted */ .chroma .gi { font-weight: bold }
/* GenericOutput */ .chroma .go { color: #43454f }
/* GenericPrompt */ .chroma .gp {  }
/* GenericStrong */ .chroma .gs { font-style: italic }
/* GenericSubheading */ .chroma .gu { font-weight: bold }
/* GenericTraceback */ .chroma .gt {  }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w {  }

  }

  body {
    font-family: Verdana, sans-serif;
    margin: auto;
    padding: 20px;
    max-width: 720px;
    text-align: left;
    background-color: var(--background-color);
    color: var(--text-color);
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  strong,
  b {
    color: var(--bright-text-color);
  }

  a {
    color: var(--link-color);
    text-decoration: none;
  }

  .title {
    text-decoration: none;
    border: 0;
  }

  .title span {
    font-weight: 400;
  }

  nav a {
    margin-right: 10px;
  }

  textarea {
    width: 100%;
    font-size: 16px;
  }

  input {
    font-size: 16px;
  }

  content {
    line-height: 1.6;
  }

  table {
    width: 100%;
  }

  img {
    max-width: 100%;
  }

  code {
    padding: 2px 5px;
    font-family: Fira Code, Inconsolata, monospace;
     
    font-size: 14px;
  }

   
  p code {
     
    border-radius: 4px;
    border: solid var(--faint-color) 1px;
    margin: 2px;
    padding: 3px;
  }

   
  pre code {
    display: block;
    padding: 20px;
    white-space: pre-wrap;
  }

  pre {
    border-radius: 10px;
  }

  blockquote {
    border-left: 1px solid #999;
    color: var(--blockquote-text-color);
    padding-left: 20px;
    font-style: italic;
  }

  footer {
    padding: 25px;
    text-align: center;
  }

  .helptext {
    color: var(--faded-text-color);
    font-size: small;
  }

  .deemphasize {
    color: var(--faded-text-color);
  }

  .errorlist {
    color: #eba613;
    font-size: small;
  }

   
  ul.blog-posts {
    list-style-type: none;
    padding: unset;
  }

  ul.blog-posts li {
    display: flex;
  }

  ul.blog-posts li span {
    flex: 0 0 130px;
    text-align: right;
    margin-right: 20px;
  }

  ul.blog-posts li a:visited {
    color: var(--link-visited-color);
  }
</style>



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>

</head>

<body>
  <header><a href="/" class="title">
  <h2>Darius Foo</h2>
</a>
<nav>

<a href="/blog">Blog</a>


<a href="/research/">Research</a>

<a href="/work/">Work</a>

<a href="/other/">Other</a>

</nav>
</header>
  <main>

<h1>Visualizing Z3&#39;s proofs</h1>
<p>
    <time datetime='2021-03-21' pubdate>
      21 Mar, 2021
    </time>
</p>


<content>
  <p><em>A writeup of a presentation I gave in class.</em></p>
<p>SMT solvers like Z3 are often also called automated theorem provers. Why? What do their proofs look like?</p>
<p>An SMT solver tells us if a formula in first-order logic (augmented with various theories) is <em>satisfiable</em><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>: there is some assignment of variables that makes the formula true. Z3 can even produce such an assignment.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">z3</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">i</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="p">[</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div><p>Not every formula is satisfiable, though. In that case, there are two possibilities.</p>
<p>Z3 can say <code>unknown</code>. This is the less interesting one. It means that Z3 ran out of time or memory, or the algorithm it uses to find the assignment is incomplete, or the problem itself is unsolvable in general. In other words, we don&rsquo;t know for sure if an assignment does not exist.</p>
<!-- https://stackoverflow.com/questions/11197344/z3-produces-unknown-for-assertions-without-quantifiers -->
<p>The other outcome is <code>unsat</code>.
This is a much stronger statement than satisfiability, as it means that <em>every</em> assignment of variables must not work.</p>
<p>This has something of the flavour of proving a theorem, where we aim to convince ourselves that a formula is true for <em>every</em> assignment of variables.</p>
<p>We can connect these two views by expressing the theorem we want to prove instead as the non-existence of a <em>refutation</em>, or counterexample, to it.
We do this by negating the formula and asking, &ldquo;is it possible that there is some way for this formula not to be true?&rdquo;
<code>unsat</code> means no, i.e. the theorem is always true.</p>
<h2 id="z3s-proofs">Z3&rsquo;s proofs</h2>
<p>Z3 has facilities for explaining its deductions, in the form of proofs.
Let&rsquo;s try them on a really simple theorem, $\exists a. a = a$.</p>
<!-- https://stackoverflow.com/questions/49874498/can-i-replay-a-proof-in-z3 -->
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">z3</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">set_param</span><span class="p">(</span><span class="n">proof</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">a</span> <span class="o">==</span> <span class="n">a</span>
<span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>

<span class="n">res</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">check</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="k">if</span> <span class="n">res</span> <span class="o">==</span> <span class="n">sat</span><span class="p">:</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>
<span class="k">else</span><span class="p">:</span>
  <span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">proof</span><span class="p">()</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</code></pre></div><p>Something to note that is that variables in SMT are implicitly existentially quantified. Therefore we are searching for a counterexample by seeing if $\forall a. a \neq a$ is satisfiable.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">unsat</span>
<span class="n">mp</span><span class="p">(</span><span class="n">asserted</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">a</span><span class="p">)),</span>
   <span class="n">trans</span><span class="p">(</span><span class="n">monotonicity</span><span class="p">(</span><span class="n">rewrite</span><span class="p">((</span><span class="n">a</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">),</span>
                      <span class="n">Not</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">Not</span><span class="p">(</span><span class="kc">True</span><span class="p">)),</span>
         <span class="n">rewrite</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">),</span>
         <span class="n">Not</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">),</span>
   <span class="kc">False</span><span class="p">)</span>
</code></pre></div><p>Unsurprisingly, it is not.
Z3 outputs a <em>proof tree</em>, which we can traverse and pretty-print.</p>






<img src="/images/z3proof1.png" class="diagram" style="display: block; margin: auto;">

<p>Firstly, we see that the conclusion at the bottom is <code>False</code>.
This may seem odd, but recall that the goal is to show that negation of the original theorem cannot be proved, so this is the only conclusion which makes sense.</p>
<p>Next, we see some of Z3&rsquo;s inference rules<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> in action.
Our original goal is <code>asserted</code>.
We have two instances of <code>rewrite</code>, where built-in equalities are used to simplify terms.
There is an application of <code>monotonicity</code>, where we negate both sides.
Finally we use the <code>trans</code>itivity of equality and modus ponens to derive the conclusion.</p>
<p>Let&rsquo;s try $\exists a. a = \neg (\neg a)$.</p>






<img src="/images/z3proof2.png" class="diagram" style="display: block; margin: auto;">

<p>And here&rsquo;s another for the linear arithmetic formula $\exists x y. 2 x \leq 3 y, y &gt; x, x &gt; 0$.</p>






<img src="/images/z3proof3.png" class="diagram" style="display: block; margin: auto;">

<p>Clearly, these generated proofs quickly get too large to be comprehensible.
They&rsquo;re also largely mechanical and not very meaningful.
Still, it&rsquo;s intriguing to see the automated reasoning that Z3 performs.</p>
<p>A final point about the last one is the application of the rule <code>th-lemma</code> to derive the conclusion.</p>






<img src="/images/z3proof4.png" class="diagram" style="display: block; margin: auto;">

<p>This is a theory lemma, a placeholder rule for a possibly-opaque decision from a theory solver.</p>
<p>If you want to generate these proofs yourself, the code is <a href="https://gist.github.com/dariusf/1fbb17816bea7417e4a104d58d2053d8">here</a>.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>For a more thorough introduction to satisfiability, check out <a href="https://homes.cs.washington.edu/~emina/blog/2017-06-23-a-primer-on-sat.html#satisfiability-and-validity">this blog post</a>.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>There&rsquo;s a more complete list of rules in Section 3.3 of <a href="https://www21.in.tum.de/~boehmes/proofrec.pdf">this paper</a>.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

</content>
<p>
  
</p>

  </main>
  <footer>
</footer>

    
</body>

</html>
