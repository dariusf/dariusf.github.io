<!doctype html><html lang=en-US><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://dariusf.github.io/images/favicon.png><title>Bags of puzzle pieces in ASP | Darius Foo</title>
<meta name=title content="Bags of puzzle pieces in ASP"><meta name=description content="Answer set programming is an offshoot of traditional logic programming with a number of nice properties: programs always terminate, are fully declarative (i.e. clause ordering doesn't matter and search is complete, unlike Prolog), and have a well-defined semantics. Modelling a domain with relations is a wonderfully high-level way to reason about things, allowing complex rules to be represented concisely.
ASP is typically applied to hard search problems, but can model pretty much anything. One area it's popular in is game design, particularly for procedural content generation: if we can write down the rules of, say, a puzzle game, we can straightforwardly sample valid puzzles (or even solutions to puzzles) with desirable properties."><meta name=keywords content><meta property="og:url" content="https://dariusf.github.io/asp-puzzle-pieces/"><meta property="og:site_name" content="Darius Foo"><meta property="og:title" content="Bags of puzzle pieces in ASP"><meta property="og:description" content="Answer set programming is an offshoot of traditional logic programming with a number of nice properties: programs always terminate, are fully declarative (i.e. clause ordering doesn't matter and search is complete, unlike Prolog), and have a well-defined semantics. Modelling a domain with relations is a wonderfully high-level way to reason about things, allowing complex rules to be represented concisely.
ASP is typically applied to hard search problems, but can model pretty much anything. One area it's popular in is game design, particularly for procedural content generation: if we can write down the rules of, say, a puzzle game, we can straightforwardly sample valid puzzles (or even solutions to puzzles) with desirable properties."><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2017-11-25T12:15:06+08:00"><meta property="article:modified_time" content="2017-11-25T12:15:06+08:00"><meta property="og:image" content="https://dariusf.github.io/images/favicon.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dariusf.github.io/images/favicon.png"><meta name=twitter:title content="Bags of puzzle pieces in ASP"><meta name=twitter:description content="Answer set programming is an offshoot of traditional logic programming with a number of nice properties: programs always terminate, are fully declarative (i.e. clause ordering doesn't matter and search is complete, unlike Prolog), and have a well-defined semantics. Modelling a domain with relations is a wonderfully high-level way to reason about things, allowing complex rules to be represented concisely.
ASP is typically applied to hard search problems, but can model pretty much anything. One area it's popular in is game design, particularly for procedural content generation: if we can write down the rules of, say, a puzzle game, we can straightforwardly sample valid puzzles (or even solutions to puzzles) with desirable properties."><meta itemprop=name content="Bags of puzzle pieces in ASP"><meta itemprop=description content="Answer set programming is an offshoot of traditional logic programming with a number of nice properties: programs always terminate, are fully declarative (i.e. clause ordering doesn't matter and search is complete, unlike Prolog), and have a well-defined semantics. Modelling a domain with relations is a wonderfully high-level way to reason about things, allowing complex rules to be represented concisely.
ASP is typically applied to hard search problems, but can model pretty much anything. One area it's popular in is game design, particularly for procedural content generation: if we can write down the rules of, say, a puzzle game, we can straightforwardly sample valid puzzles (or even solutions to puzzles) with desirable properties."><meta itemprop=datePublished content="2017-11-25T12:15:06+08:00"><meta itemprop=dateModified content="2017-11-25T12:15:06+08:00"><meta itemprop=wordCount content="775"><meta itemprop=image content="https://dariusf.github.io/images/favicon.png"><meta name=referrer content="no-referrer-when-downgrade"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Code"><style>@media(prefers-color-scheme:light){:root{--bright-text-color:#222;--link-color:#3273dc;--link-visited-color:#6e4bbe;--background-color:#fff;--text-color:#444;--faded-text-color:#777;--blockquote-text-color:var(--bright-text-color);--faint-color:#ccc}.chroma{background-color:#fff}.chroma .x{}.chroma .err{color:#000}.chroma .lntd{vertical-align:top;padding:0;margin:0;border:0}.chroma .lntable{border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block}.chroma .hl{display:block;width:100%;background-color:#ffc}.chroma .lnt{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .ln{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .k{color:#a90d91}.chroma .kc{color:#a90d91}.chroma .kd{color:#a90d91}.chroma .kn{color:#a90d91}.chroma .kp{color:#a90d91}.chroma .kr{color:#a90d91}.chroma .kt{color:#a90d91}.chroma .n{color:#000}.chroma .na{color:#836c28}.chroma .nb{color:#a90d91}.chroma .bp{color:#5b269a}.chroma .nc{color:#3f6e75}.chroma .no{color:#000}.chroma .nd{color:#000}.chroma .ni{color:#000}.chroma .ne{color:#000}.chroma .nf{color:#000}.chroma .fm{color:#000}.chroma .nl{color:#000}.chroma .nn{color:#000}.chroma .nx{color:#000}.chroma .py{color:#000}.chroma .nt{color:#000}.chroma .nv{color:#000}.chroma .vc{color:#000}.chroma .vg{color:#000}.chroma .vi{color:#000}.chroma .vm{color:#000}.chroma .l{color:#1c01ce}.chroma .ld{color:#1c01ce}.chroma .s{color:#c41a16}.chroma .sa{color:#c41a16}.chroma .sb{color:#c41a16}.chroma .sc{color:#2300ce}.chroma .dl{color:#c41a16}.chroma .sd{color:#c41a16}.chroma .s2{color:#c41a16}.chroma .se{color:#c41a16}.chroma .sh{color:#c41a16}.chroma .si{color:#c41a16}.chroma .sx{color:#c41a16}.chroma .sr{color:#c41a16}.chroma .s1{color:#c41a16}.chroma .ss{color:#c41a16}.chroma .m{color:#1c01ce}.chroma .mb{color:#1c01ce}.chroma .mf{color:#1c01ce}.chroma .mh{color:#1c01ce}.chroma .mi{color:#1c01ce}.chroma .il{color:#1c01ce}.chroma .mo{color:#1c01ce}.chroma .o{color:#000}.chroma .ow{color:#000}.chroma .p{}.chroma .c{color:#177500}.chroma .ch{color:#177500}.chroma .cm{color:#177500}.chroma .c1{color:#177500}.chroma .cs{color:#177500}.chroma .cp{color:#633820}.chroma .cpf{color:#633820}.chroma .g{}.chroma .gd{}.chroma .ge{}.chroma .gr{}.chroma .gh{}.chroma .gi{}.chroma .go{}.chroma .gp{}.chroma .gs{}.chroma .gu{}.chroma .gt{}.chroma .gl{}.chroma .w{}}@media(prefers-color-scheme:dark){:root{--bright-text-color:#eee;--link-color:#8cc2dd;--link-visited-color:#b9a9e0;--background-color:#333;--text-color:#ddd;--faded-text-color:#aaa;--slightly-dimmer-text-color:#ccc;--blockquote-text-color:var(--slightly-dimmer-text-color);--faint-color:#666;color-scheme:dark}img.theme-affected{filter:invert(.8)}.chroma{color:#e2e4e5;background-color:#282a36}.chroma .x{}.chroma .err{color:#ff5c57}.chroma .lntd{vertical-align:top;padding:0;margin:0;border:0}.chroma .lntable{border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block}.chroma .hl{display:block;width:100%;background-color:#ffc}.chroma .lnt{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .ln{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .k{color:#ff6ac1}.chroma .kc{color:#ff6ac1}.chroma .kd{color:#ff5c57}.chroma .kn{color:#ff6ac1}.chroma .kp{color:#ff6ac1}.chroma .kr{color:#ff6ac1}.chroma .kt{color:#9aedfe}.chroma .n{}.chroma .na{color:#57c7ff}.chroma .nb{color:#ff5c57}.chroma .bp{}.chroma .nc{color:#f3f99d}.chroma .no{color:#ff9f43}.chroma .nd{color:#ff9f43}.chroma .ni{}.chroma .ne{}.chroma .nf{color:#57c7ff}.chroma .fm{}.chroma .nl{color:#ff5c57}.chroma .nn{}.chroma .nx{}.chroma .py{}.chroma .nt{color:#ff6ac1}.chroma .nv{color:#ff5c57}.chroma .vc{color:#ff5c57}.chroma .vg{color:#ff5c57}.chroma .vi{color:#ff5c57}.chroma .vm{}.chroma .l{}.chroma .ld{}.chroma .s{color:#5af78e}.chroma .sa{color:#5af78e}.chroma .sb{color:#5af78e}.chroma .sc{color:#5af78e}.chroma .dl{color:#5af78e}.chroma .sd{color:#5af78e}.chroma .s2{color:#5af78e}.chroma .se{color:#5af78e}.chroma .sh{color:#5af78e}.chroma .si{color:#5af78e}.chroma .sx{color:#5af78e}.chroma .sr{color:#5af78e}.chroma .s1{color:#5af78e}.chroma .ss{color:#5af78e}.chroma .m{color:#ff9f43}.chroma .mb{color:#ff9f43}.chroma .mf{color:#ff9f43}.chroma .mh{color:#ff9f43}.chroma .mi{color:#ff9f43}.chroma .il{color:#ff9f43}.chroma .mo{color:#ff9f43}.chroma .o{color:#ff6ac1}.chroma .ow{color:#ff6ac1}.chroma .p{}.chroma .c{color:#78787e}.chroma .ch{color:#78787e}.chroma .cm{color:#78787e}.chroma .c1{color:#78787e}.chroma .cs{color:#78787e}.chroma .cp{color:#78787e}.chroma .cpf{color:#78787e}.chroma .g{}.chroma .gd{color:#ff5c57}.chroma .ge{text-decoration:underline}.chroma .gr{color:#ff5c57}.chroma .gh{font-weight:700}.chroma .gi{font-weight:700}.chroma .go{color:#43454f}.chroma .gp{}.chroma .gs{font-style:italic}.chroma .gu{font-weight:700}.chroma .gt{}.chroma .gl{text-decoration:underline}.chroma .w{}}:root{--heading-font:ui-rounded, 'Hiragino Maru Gothic ProN', Quicksand, Comfortaa, Manjari, 'Arial Rounded MT', 'Arial Rounded MT Bold', Calibri, source-sans-pro, sans-serif;--text-font-size:17px;--text-font:system-ui, sans-serif}*{margin:0}body{}main{margin-top:.75em}sup{vertical-align:top;font-size:.7em}p{margin-bottom:1em}html{overflow-x:hidden;margin-right:calc(-1 * (100vw - 100%))}body{font-family:var(--text-font);font-size:var(--text-font-size);margin:auto;padding:20px;max-width:720px;text-align:left;background-color:var(--background-color);color:var(--text-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5}h1,h2,h3,h4,h5,h6{font-family:var(--heading-font);color:var(--bright-text-color);font-weight:400}.blog-content h1,.blog-content h2,.blog-content h3,.blog-content h4,.blog-content h5,.blog-content h6{margin-top:.5em}hr,ul,ol{margin-bottom:.5em}div>iframe{margin-bottom:.5em}.blog-timestamp{font-size:.9em}.blog-content{margin-top:1.5em}a{color:var(--link-color);text-decoration:none}.title{color:var(--text-color);font-size:1.5em;font-family:var(--heading-font);margin-right:10px}nav a{margin-right:8px;font-family:var(--heading-font)}.paper-item svg{width:16px;vertical-align:text-bottom}.menuactive{text-decoration:underline;text-decoration-thickness:2px}table{width:100%}img{max-width:100%;margin:auto;margin-bottom:.5em;display:block}code{padding:2px 5px;margin-bottom:1em;font-family:Fira Code,monospace;font-size:14px;line-height:1.4}pre code{display:block;padding:20px;white-space:pre-wrap;overflow-x:auto}pre{border-radius:10px}p code,ol code,ul code,summary code{border-radius:4px;border:solid var(--faint-color)1px;margin:0 2px;padding:1px 2px}blockquote{border-left:1px solid #999;color:var(--blockquote-text-color);padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.deemphasize{color:var(--faded-text-color)}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px;text-align:right;margin-right:20px}ul.blog-posts li a:visited{color:var(--link-visited-color)}</style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script>const macros={};function render(){renderMathInElement(document.body,{trust:!0,strict:!1,throwOnError:!1,delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros})}</script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=render()></script></head><body><header><a href=/><span class=title>Darius Foo</span></a><nav style=display:inline-block><a href=/blog/>Blog</a>
<a href=/research/>Research</a>
<a href=/work/>Work</a>
<a href=/other/>Other</a></nav></header><main><h1>Bags of puzzle pieces in ASP</h1><div><time class=blog-timestamp datetime=2017-11-25 pubdate>25 Nov, 2017</time></div><div class=blog-content><p>Answer set programming is an offshoot of traditional logic programming with a number of nice properties: programs always terminate, are fully declarative (i.e. clause ordering doesn't matter and search is complete, unlike Prolog), and have a <a href=https://en.wikipedia.org/wiki/Stable_model_semantics>well-defined semantics</a>. Modelling a domain with relations is a wonderfully high-level way to reason about things, allowing complex rules to be represented <a href=https://en.wikipedia.org/wiki/Answer_set_programming#Examples_of_ASP_programs>concisely</a>.</p><p>ASP is typically applied to hard search problems, but can model pretty much anything. One area it's popular in is game design, particularly for <a href=https://adamsmith.as/papers/tciaig-asp4pcg.pdf>procedural content generation</a>: if we can write down the rules of, say, a puzzle game, we can straightforwardly sample valid puzzles (or even <a href=https://adamsmith.as/papers/fdg2013_shortcuts.pdf>solutions to puzzles</a>) with desirable properties.</p><p>Here, we'll explore one way of sampling puzzle pieces: given an infinite bag of heterogeneous pieces, we want to grab a <em>handful</em>, put them on the game board, then rule out the worlds where the pieces don't form a valid puzzle.</p><p>Incidentally, this is how one typically approaches problems with ASP: defining the <em>entire</em> problem space and how to prune it down to the interesting bits.</p><p>By a <em>handful</em>, we intuitively mean <em>some</em> quantity of pieces with <em>some</em> types. For example, we might generate <a href=https://en.wikipedia.org/wiki/Pipe_Mania>Pipe Mania</a> or <a href=https://en.wikipedia.org/wiki/Rush_Hour_(puzzle)>Rush Hour</a> boards such that we get a puzzle of appropriate size or difficulty.</p><p>Generally, the number of piece types is finite and much smaller than the size of the game board, so we'll want to allow duplicate pieces. We'll represent pieces very abstractly, indexed by an identifier and piece type.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nf>piece</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=n>a</span><span class=p>).</span>
</span></span></code></pre></div><p>We'll start with 4 piece types, and an upper limit on the maximum number of pieces we want per puzzle -- ASP programs must terminate, so domains must be finite.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nl>#const</span> <span class=n>max_n</span><span class=o>=</span><span class=mi>4</span><span class=p>.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>piece_type</span><span class=p>(</span><span class=n>a</span><span class=p>;</span><span class=n>b</span><span class=p>;</span><span class=n>c</span><span class=p>;</span><span class=n>d</span><span class=p>).</span>
</span></span><span class=line><span class=cl><span class=nf>piece_n</span><span class=p>(</span><span class=mi>1</span><span class=p>..</span><span class=n>max_n</span><span class=p>).</span>
</span></span></code></pre></div><p>Two pieces of type <code>b</code> and one piece of type <code>a</code> might be represented as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nf>piece</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=n>a</span><span class=p>).</span>
</span></span><span class=line><span class=cl><span class=nf>piece</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=n>b</span><span class=p>).</span>
</span></span><span class=line><span class=cl><span class=nf>piece</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=n>b</span><span class=p>).</span>
</span></span></code></pre></div><p>Now to get our handful of pieces. There are two quantities to vary: the number of pieces and the piece types. We express this using a couple of choice rules, where one depends on the other.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=c>% guess a subset of pieces used
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>{</span> <span class=n>used</span><span class=p>(</span><span class=nv>I</span><span class=p>)</span> <span class=p>:</span> <span class=n>piece_n</span><span class=p>(</span><span class=nv>I</span><span class=p>)</span> <span class=p>}.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>% guess a single type for each used piece
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>{</span> <span class=n>piece</span><span class=p>(</span><span class=nv>I</span><span class=p>,</span><span class=nv>T</span><span class=p>)</span> <span class=p>:</span> <span class=n>piece_type</span><span class=p>(</span><span class=nv>T</span><span class=p>)</span> <span class=p>}</span> <span class=o>=</span> <span class=mi>1</span> <span class=p>:</span><span class=o>-</span> <span class=n>used</span><span class=p>(</span><span class=nv>I</span><span class=p>).</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>#show</span> <span class=n>piece</span><span class=o>/</span><span class=mi>2</span><span class=p>.</span>
</span></span></code></pre></div><p>Let's try running this with <a href=https://potassco.org/clingo/run/>clingo</a>. We'll generate all answer sets, which is possible because we're still only working with tiny puzzles.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ clingo puzzle.lp 0 -q
</span></span><span class=line><span class=cl>clingo version 5.2.1
</span></span><span class=line><span class=cl>Reading from puzzle.lp
</span></span><span class=line><span class=cl>Solving...
</span></span><span class=line><span class=cl>SATISFIABLE
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Models       : 625
</span></span><span class=line><span class=cl>Calls        : 1
</span></span><span class=line><span class=cl>Time         : 0.002s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
</span></span><span class=line><span class=cl>CPU Time     : 0.002s
</span></span></code></pre></div><p>We're getting there, but 625 models is probably too many for only 4 pieces. Looking at the generated answer sets, we see that there are many duplicates. For one, the earlier example appears again, this time represented as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nf>piece</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=n>a</span><span class=p>).</span>
</span></span><span class=line><span class=cl><span class=nf>piece</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=n>b</span><span class=p>).</span>
</span></span><span class=line><span class=cl><span class=nf>piece</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span><span class=n>b</span><span class=p>).</span>
</span></span></code></pre></div><p>Yet another occurrence:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nf>piece</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=n>b</span><span class=p>).</span>
</span></span><span class=line><span class=cl><span class=nf>piece</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=n>a</span><span class=p>).</span>
</span></span><span class=line><span class=cl><span class=nf>piece</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=n>b</span><span class=p>).</span>
</span></span></code></pre></div><p>We don't really gain anything from having the same handful of pieces represented multiple times, as that skews the distribution of puzzles in difficult-to-predict ways once we start sampling them randomly.</p><p>In both examples above, we can see that the two arguments of <code>piece</code> are out of order and not contiguously increasing. That's somewhere we can start: giving pieces a canonical ordering, so it's easier to filter duplicates.</p><p>We first define an auxiliary predicate to capture the maximum index used. This is also the number of pieces actually generated.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nf>max</span><span class=p>(</span><span class=nv>I</span><span class=p>)</span> <span class=p>:</span><span class=o>-</span> <span class=p>{</span> <span class=n>used</span><span class=p>(_)</span> <span class=p>}</span> <span class=o>=</span> <span class=nv>I</span><span class=p>.</span>
</span></span></code></pre></div><p>We then say what it means for the piece indexes to be contiguously increasing with an inductive rule. <code>1</code> is always part of an increasing sequence, and so is <code>N+1</code> if <code>N</code> is <em>and</em> we haven't exceeded the maximum index.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nf>increasing</span><span class=p>(</span><span class=mi>1</span><span class=p>).</span>
</span></span><span class=line><span class=cl><span class=nf>increasing</span><span class=p>(</span><span class=nv>N</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=p>:</span><span class=o>-</span> <span class=n>increasing</span><span class=p>(</span><span class=nv>N</span><span class=p>),</span> <span class=nv>N</span> <span class=o>&lt;</span> <span class=nv>I</span><span class=p>,</span> <span class=n>max</span><span class=p>(</span><span class=nv>I</span><span class=p>).</span>
</span></span></code></pre></div><p>Finally, we rule out cases where a piece index is selected, but isn't in an increasing sequence.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=p>:</span><span class=o>-</span> <span class=n>used</span><span class=p>(</span><span class=nv>I</span><span class=p>),</span> <span class=ow>not</span> <span class=n>increasing</span><span class=p>(</span><span class=nv>I</span><span class=p>).</span>
</span></span></code></pre></div><p>This brings us down to 341 models. Next, we ensure that pieces are sorted by index and type, by ruling out cases where they appear out of order.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=p>:</span><span class=o>-</span> <span class=n>piece</span><span class=p>(</span><span class=nv>I1</span><span class=p>,</span><span class=nv>V1</span><span class=p>),</span> <span class=n>piece</span><span class=p>(</span><span class=nv>I2</span><span class=p>,</span><span class=nv>V2</span><span class=p>),</span> <span class=nv>I1</span> <span class=o>&lt;</span> <span class=nv>I2</span><span class=p>,</span> <span class=nv>V1</span> <span class=o>&gt;</span> <span class=nv>V2</span><span class=p>.</span>
</span></span></code></pre></div><p>We get 70 models now. A manual look at the answers seems promising, showing no obvious duplicates, but how do we know we're done, i.e. all answer sets are unique?</p><p>It turns out that what we're doing -- grabbing a handful of heterogeneous pieces from an infinite bag -- is an instance of <a href=https://en.wikipedia.org/wiki/Combination#Number_of_combinations_with_repetition>combinations with repetition</a>. The number of ways of taking <code>k</code> pieces from a bag of <code>n</code> unique pieces is given by</p>$$\binom{n+k-1}{k}$$<p>For the case of 4 pieces, we're sampling one piece, then two, etc. We add one for the case where we pick <em>no</em> pieces.</p>$$\binom{7}{4}+\binom{6}{3}+\binom{5}{2}+\binom{4}{1}+1=70$$<p>Success!</p></div><p></p></main><footer></footer></body></html>