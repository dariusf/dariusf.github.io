<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">

		<meta property="og:title" content="Darius Foo">
		<meta property="og:type" content="article">
		<meta property="og:url" content="https://dariusf.github.io">
		<meta property="og:image" content="https://dariusf.github.io/avatar.png">

		<title>Visualizing Z3&#39;s proofs</title>
		<meta name="description" content="PhD student, programming languages and formal verification">
		<link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="Darius Foo">


		

		

		

		

		
		
		<style>@media (prefers-color-scheme: light) { /**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	background: none;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	font-size: 1em;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.token.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #9a6e3a;
	/* This background color was intended by the author of this theme. */
	background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function,
.token.class-name {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}
 }
@media (prefers-color-scheme: dark) { /**
 * prism.js tomorrow night eighties for JavaScript, CoffeeScript, CSS and HTML
 * Based on https://github.com/chriskempson/tomorrow-theme
 * @author Rose Pritchard
 */

code[class*="language-"],
pre[class*="language-"] {
	color: #ccc;
	background: none;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	font-size: 1em;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;

}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #2d2d2d;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.block-comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: #999;
}

.token.punctuation {
	color: #ccc;
}

.token.tag,
.token.attr-name,
.token.namespace,
.token.deleted {
	color: #e2777a;
}

.token.function-name {
	color: #6196cc;
}

.token.boolean,
.token.number,
.token.function {
	color: #f08d49;
}

.token.property,
.token.class-name,
.token.constant,
.token.symbol {
	color: #f8c555;
}

.token.selector,
.token.important,
.token.atrule,
.token.keyword,
.token.builtin {
	color: #cc99cd;
}

.token.string,
.token.char,
.token.attr-value,
.token.regex,
.token.variable {
	color: #7ec699;
}

.token.operator,
.token.entity,
.token.url {
	color: #67cdcc;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}

.token.inserted {
	color: green;
}
 }
/* This is an arbitrary CSS string added to the bundle */
:root {
	/* --font-family: -apple-system, system-ui, sans-serif; */
	/* --font-family-monospace: Consolas, Menlo, Monaco, Andale Mono WT, Andale Mono, Lucida Console, Lucida Sans Typewriter, DejaVu Sans Mono, Bitstream Vera Sans Mono, Liberation Mono, Nimbus Mono L, Courier New, Courier, monospace;
	*/

    --font-family-monospace: Fira Code, Menlo, Consolas, Monaco, Liberation Mono, Lucida Console, monospace;


  /*    --text-font: Crimson Text, serif;*/
  /*    --text-font: Poppins, Verdana, sans-serif;*/
  /*    --heading-font: Quicksand, sans-serif;*/
  /*    --text-font: Open Sans, sans-serif;*/
  /*    --text-font-size: 16px;*/
  /*    --heading-font: Open Sans, sans-serif;*/
  /*    --text-font: Cabin, sans-serif;*/
  /*    --text-font-size: 16px;*/
  /*    --text-font: Roboto, sans-serif;*/

  /*    --heading-font: Roboto, sans-serif;*/
  /*    --heading-font: Cabin, sans-serif;*/
  /*    --heading-font: Dosis, sans-serif;*/

  /*    --heading-font: Work Sans, sans-serif;*/
  /*    --text-font: Open Sans, sans-serif;*/

      /* --heading-font: Nunito, sans-serif; */
      --heading-font: ui-rounded, 'Hiragino Maru Gothic ProN', Quicksand, Comfortaa, Manjari, 'Arial Rounded MT', 'Arial Rounded MT Bold', Calibri, source-sans-pro, sans-serif;
  /*    --text-font: PT Sans, sans-serif;*/

  /*    --heading-font: Varela Round, sans-serif;*/
  /*    --text-font: Noto Serif, serif;*/

  /*    --text-font: Lato, sans-serif;*/
      --text-font-size: 17px;

  /*    --text-font: Merriweather, sans-serif;*/
  /*    --text-font-size: 16px;*/

  /* https://css-tricks.com/snippets/css/system-font-stack/ */
  /* https://systemfontstack.com/ */

    /* system font on all platforms */
  /*    --heading-font: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu;*/
      /* --text-font: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu; */
      --text-font: -apple-system, system-ui, sans-serif;
			/* system-ui, sans-serif; */


/* Theme colors */

	/* --color-gray-20: #e0e0e0;
	--color-gray-50: #C0C0C0;
	--color-gray-90: #333; */

	--background-color: #fff;

	/* --text-color: var(--color-gray-90); */
	/* --text-color-link: #082840; */

	/* --text-color-link: #ff0000; */
	/* --text-color-link-active: #5f2b48; */
	/* --text-color-link-visited: #17050F; */


	/* --syntax-tab-size: 2; */

	--bright-text-color: #222;
	--link-color: #3273dc;
	/* --link-color: #ff5e6c; */
	--link-visited-color: #6e4bbe;
	--background-color: #fff;
	--text-color: #444;
	--faded-text-color: #777;
	--blockquote-text-color: var(--bright-text-color);
	--faint-color: #ccc;
}

@media (prefers-color-scheme: dark) {
	:root {
		/* --color-gray-20: #e0e0e0; */
		/* --color-gray-50: #C0C0C0; */
		/* --color-gray-90: #dad8d8; */

		/* --text-color is assigned to --color-gray-_ above */
		/* --text-color-link: #1493fb; */
		/* --text-color-link-active: #6969f7; */
		/* --text-color-link-visited: #a6a6f8; */

		--background-color: #15202b;

		--bright-text-color: #eee;
		--link-color: #8cc2dd;
		--link-visited-color: #b9a9e0;
		--background-color: #333;
		--text-color: #ddd;
		--faded-text-color: #aaa;
		--slightly-dimmer-text-color: #ccc;
		--blockquote-text-color: var(--slightly-dimmer-text-color);
		--faint-color: #666;

		color-scheme: dark; /* sets scrollbar colour */
	}

	.theme-affected {
		filter: invert(.8);
	}
}

body {
	box-sizing: border-box;

	/* https://github.com/sindresorhus/github-markdown-css */
	min-width: 200px;
	/* max from old blog */
	/* max-width: 40em; */
	/* tiny bit wider because prism adds some padding */
	max-width: 726px;

	margin: 0 auto;
	padding: 0 20px;

	/* enable ligatures */
	text-rendering: optimizeLegibility;

	font-family: var(--text-font);
	font-size: var(--text-font-size);
	color: var(--text-color);
	background-color: var(--background-color);

	/*
	text-align: left;
	word-wrap: break-word;
	overflow-wrap: break-word;
	*/
	/* line-height: 1.5; */
}

@media (max-width: 767px) {
	body {
		padding: 0px 1em;
	}
}

@view-transition {
	navigation: auto;
}

html {
	overflow-y: scroll;
}

/* https://github.com/Kimeiga/bahunya/blob/master/src/parts/_typography.css */
ul, ol {
  padding-left: 2em;
}

li {
	line-height: 1.5;
}

h1, h2, h3, h4, h5, h6 {
	font-family: var(--heading-font);
	color: var(--bright-text-color);
	font-weight: normal;
	line-height: 1.25;
}

footer {
	padding: 35px;
}

/* header {
	border-bottom: 1px dashed var(--color-gray-20);
} */


/* misc changes from here on */

/* https://www.a11yproject.com/posts/how-to-hide-content/ */
.visually-hidden {
	clip: rect(0 0 0 0);
	clip-path: inset(50%);
	height: 1px;
	overflow: hidden;
	position: absolute;
	white-space: nowrap;
	width: 1px;
}

p:has(img) {
	text-align: center;
}
/* Fluid images via https://www.zachleat.com/web/fluid-images/ */
img{
  max-width: 100%;
}
img[width][height] {
  height: auto;
}
/* img[src$=".svg"] {
  width: 100%;
  height: auto;
  max-width: none;
} */
video,
iframe {
	width: 100%;
	height: auto;
}
iframe {
	aspect-ratio: 16/9;
}

p:last-child {
	margin-bottom: 0;
}
p {
	line-height: 1.5;
}

a[href] {
	color: var(--link-color);
	text-decoration: none;
}

/* a[href]:visited {
	color: var(--link-visited-color);
} */

/* a[href]:hover,
a[href]:active { */
	/* color: var(--text-color-link-active); */
	/* text-decoration: underline; */
	/* text-decoration-thickness: 2px; */
/* } */

/* main :first-child {
	margin-top: 0;
} */

/* .links-nextprev {
	display: flex;
	justify-content: space-between;
	gap: .5em 1em;
	list-style: "";
	border-top: 1px dashed var(--color-gray-20);
	padding: 1em 0;
}
.links-nextprev > * {
	flex-grow: 1;
}
.links-nextprev-next {
	text-align: right;
} */

table {
	margin: 1em 0;
	border-collapse: collapse;
}
table td,
table th {
	padding-right: 1em;
}
/* table thead tr th {
  border-bottom: solid var(--text-color) 2px;
  border-top: solid var(--text-color) 2px;
} */

.table-lines td {
  border-bottom: solid var(--text-color) 1px;
  border-top: solid var(--text-color) 1px;
}

/* pre,
code {
	font-family: var(--font-family-monospace) !important;
	font-size: 14px !important;
} */

/* override prism */
/* https://github.com/orgs/PrismJS/discussions/2859 */
code[class*="language-"],
pre[class*="language-"] {
	font-family: var(--font-family-monospace);
	font-size: 14px;
}

pre[class*="language-"] {
	margin-top: 0;
	margin-bottom: 1em;
}

pre:not([class*="language-"]) {
	margin: .5em 0;
	line-height: 1.375; /* 22px /16 */
	/* -moz-tab-size: var(--syntax-tab-size); */
	/* -o-tab-size: var(--syntax-tab-size); */
	/* tab-size: var(--syntax-tab-size); */
	-webkit-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
	direction: ltr;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	overflow-x: auto;
}

.scroll-when-overflowing, pre {
	overflow-x: scroll;
  -ms-overflow-style: none;  /* IE and Edge */
  scrollbar-width: none;  /* Firefox */
}

.scroll-when-overflowing::-webkit-scrollbar, pre::-webkit-scrollbar {
  display: none;
}

/* mathjax v4, where display math is not centered */
mjx-container {
	margin: auto;
}
header {
			/* display: flex; */
			/* gap: 2em; */
			border-right: 10px;
			/* flex-wrap: wrap; */
			/* justify-content: space-between; */
			/* align-items: center; */
			align-items: end;
			padding-top: 1em;
			/* padding: 1em; */
		}
.nav-item {
				font-family: var(--heading-font);
				padding-right: 5px;
				display: inline-block;
			}
			
			.nav-item a[href][aria-current="page"] {
				text-decoration: underline;
				text-decoration-thickness: 2px;
			}</style>
	</head>
	<body>
		<a href="#skip" class="visually-hidden">Skip to main content</a>

		

		<header>

			
			
			
			<a href="/" style="padding-right: 10px; color: var(--text-color); font-family: var(--heading-font); font-size: 1.5em;">Darius Foo</a>
			
				
				
				
				
				
				
			
			
			<nav style="display: inline-block">
				<h2 class="visually-hidden" id="top-level-navigation-menu">Top level navigation menu</h2>
				<ul style="list-style: none; padding: 0; margin: 0;">
					<li class="nav-item"><a href="/blog/">Blog</a></li>
					<li class="nav-item"><a href="/research/">Research</a></li>
					<li class="nav-item"><a href="/work/">Work</a></li>
					<li class="nav-item"><a href="/games/">Games</a></li>
				</ul>
			</nav>
		</header>

		<main id="skip">
			

<h1 style="margin-top: 1rem; margin-bottom: 0.2em" id="visualizing-z3s-proofs">Visualizing Z3&#39;s proofs</h1>



<div class="post-metadata">
	
	<time style="font-size: 0.9em;" datetime="2021-03-21">21 Mar 2021</time>
	
	
</div>

<div class="blog-content">
<p><em>A writeup of a presentation I gave in class.</em></p>
<p>SMT solvers like Z3 are often also called automated theorem provers. Why? What do their proofs look like?</p>
<p>An SMT solver tells us if a formula in first-order logic (augmented with various theories) is <em>satisfiable</em><sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup>: there is some assignment of variables that makes the formula true. Z3 can even produce such an assignment.</p>
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token keyword">from</span> z3 <span class="token keyword">import</span> <span class="token operator">*</span>

i <span class="token operator">=</span> Int<span class="token punctuation">(</span><span class="token string">'i'</span><span class="token punctuation">)</span>
solve<span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span></code></pre>
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">]</span></code></pre>
<p>Not every formula is satisfiable, though. In that case, there are two possibilities.</p>
<p>Z3 can say <code>unknown</code>. This is the less interesting one. It means that Z3 ran out of time or memory, or the algorithm it uses to find the assignment is incomplete, or the problem itself is unsolvable in general. In other words, we don't know for sure if an assignment does not exist.</p>
<!-- https://stackoverflow.com/questions/11197344/z3-produces-unknown-for-assertions-without-quantifiers -->
<p>The other outcome is <code>unsat</code>.
This is a much stronger statement than satisfiability, as it means that <em>every</em> assignment of variables must not work.</p>
<p>This has something of the flavour of proving a theorem, where we aim to convince ourselves that a formula is true for <em>every</em> assignment of variables.</p>
<p>We can connect these two views by expressing the theorem we want to prove instead as the non-existence of a <em>refutation</em>, or counterexample, to it.
We do this by negating the formula and asking, &quot;is it possible that there is some way for this formula not to be true?&quot;
<code>unsat</code> means no, i.e. the theorem is always true.</p>
<h2 id="z3s-proofs">Z3's proofs</h2>
<p>Z3 has facilities for explaining its deductions, in the form of proofs.
Let's try them on a really simple theorem, [object Promise].</p>
<!-- https://stackoverflow.com/questions/49874498/can-i-replay-a-proof-in-z3 -->
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token keyword">from</span> z3 <span class="token keyword">import</span> <span class="token operator">*</span>

set_param<span class="token punctuation">(</span>proof<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
s <span class="token operator">=</span> Solver<span class="token punctuation">(</span><span class="token punctuation">)</span>

a <span class="token operator">=</span> Bool<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>
f <span class="token operator">=</span> a <span class="token operator">==</span> a
s<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Not<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span>

res <span class="token operator">=</span> s<span class="token punctuation">.</span>check<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
<span class="token keyword">if</span> res <span class="token operator">==</span> sat<span class="token punctuation">:</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>model<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
  p <span class="token operator">=</span> s<span class="token punctuation">.</span>proof<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span></code></pre>
<p>Something to note that is that variables in SMT are implicitly existentially quantified. Therefore we are searching for a counterexample by seeing if [object Promise] is satisfiable.</p>
<pre class="language-python" tabindex="0"><code class="language-python">unsat
mp<span class="token punctuation">(</span>asserted<span class="token punctuation">(</span>Not<span class="token punctuation">(</span>a <span class="token operator">==</span> a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
   trans<span class="token punctuation">(</span>monotonicity<span class="token punctuation">(</span>rewrite<span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">==</span> a<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      Not<span class="token punctuation">(</span>a <span class="token operator">==</span> a<span class="token punctuation">)</span> <span class="token operator">==</span> Not<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
         rewrite<span class="token punctuation">(</span>Not<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
         Not<span class="token punctuation">(</span>a <span class="token operator">==</span> a<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
   <span class="token boolean">False</span><span class="token punctuation">)</span></code></pre>
<p>Unsurprisingly, it is not.
Z3 outputs a <em>proof tree</em>, which we can traverse and pretty-print.</p>
<p><picture><source type="image/avif" srcset="/blog/z3-proofs/eCd6ZZJBEd-964.avif 964w"><source type="image/webp" srcset="/blog/z3-proofs/eCd6ZZJBEd-964.webp 964w"><img loading="lazy" decoding="async" src="/blog/z3-proofs/eCd6ZZJBEd-964.png" class="theme-affected" alt="first pretty-printed proof tree" width="964" height="156"></picture></p>
<p>Firstly, we see that the conclusion at the bottom is <code>False</code>.
This may seem odd, but recall that the goal is to show that negation of the original theorem cannot be proved, so this is the only conclusion which makes sense.</p>
<p>Next, we see some of Z3's inference rules<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup> in action.
Our original goal is <code>asserted</code>.
We have two instances of <code>rewrite</code>, where built-in equalities are used to simplify terms.
There is an application of <code>monotonicity</code>, where we negate both sides.
Finally we use the <code>trans</code>itivity of equality and modus ponens to derive the conclusion.</p>
<p>Let's try [object Promise].</p>
<p><picture><source type="image/avif" srcset="/blog/z3-proofs/HV6aMLnxj0-1743.avif 1743w"><source type="image/webp" srcset="/blog/z3-proofs/HV6aMLnxj0-1743.webp 1743w"><img loading="lazy" decoding="async" src="/blog/z3-proofs/HV6aMLnxj0-1743.png" class="theme-affected" alt="another proof tree" width="1743" height="290"></picture></p>
<p>And here's another for the linear arithmetic formula [object Promise].</p>
<p><picture><source type="image/avif" srcset="/blog/z3-proofs/8PuYupz8iZ-2726.avif 2726w"><source type="image/webp" srcset="/blog/z3-proofs/8PuYupz8iZ-2726.webp 2726w"><img loading="lazy" decoding="async" src="/blog/z3-proofs/8PuYupz8iZ-2726.png" class="theme-affected" alt="linear arithmetic formula proof, overwhelming detail" width="2726" height="165"></picture></p>
<p>Clearly, these generated proofs quickly get too large to be comprehensible.
They're also largely mechanical and not very meaningful.
Still, it's intriguing to see the automated reasoning that Z3 performs.</p>
<p>A final point about the last one is the application of the rule <code>th-lemma</code> to derive the conclusion.</p>
<p><picture><source type="image/avif" srcset="/blog/z3-proofs/92fQ8tuCpw-489.avif 489w"><source type="image/webp" srcset="/blog/z3-proofs/92fQ8tuCpw-489.webp 489w"><img loading="lazy" decoding="async" src="/blog/z3-proofs/92fQ8tuCpw-489.png" class="theme-affected" alt="theory lemma" width="489" height="59"></picture></p>
<p>This is a theory lemma, a placeholder rule for a possibly-opaque decision from a theory solver.</p>
<p>If you want to generate these proofs yourself, the code is <a href="https://gist.github.com/dariusf/1fbb17816bea7417e4a104d58d2053d8">here</a>.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>For a more thorough introduction to satisfiability, check out <a href="https://homes.cs.washington.edu/~emina/blog/2017-06-23-a-primer-on-sat.html#satisfiability-and-validity">this blog post</a>. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>There's a more complete list of rules in Section 3.3 of <a href="https://www21.in.tum.de/~boehmes/proofrec.pdf">this paper</a>. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

</div>

		</main>

		<footer>
			
		</footer>

		<!-- This page `/blog/z3-proofs/` was built on 2025-12-06T06:57:03.499Z -->
		
	</body>
</html>
