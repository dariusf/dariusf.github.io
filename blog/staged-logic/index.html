<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">

		<meta property="og:title" content="Darius Foo">
		<meta property="og:type" content="article">
		<meta property="og:url" content="https://dariusf.github.io">
		<meta property="og:image" content="https://dariusf.github.io/avatar.png">

		<title>Verifying effectful higher-order programs with staged logic</title>
		<meta name="description" content="PhD student, programming languages and formal verification">
		<link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="Darius Foo">


		

		

		

		

		
		
		<style>@media (prefers-color-scheme: light) { /**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	background: none;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	font-size: 1em;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.token.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #9a6e3a;
	/* This background color was intended by the author of this theme. */
	background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function,
.token.class-name {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}
 }
@media (prefers-color-scheme: dark) { /**
 * prism.js tomorrow night eighties for JavaScript, CoffeeScript, CSS and HTML
 * Based on https://github.com/chriskempson/tomorrow-theme
 * @author Rose Pritchard
 */

code[class*="language-"],
pre[class*="language-"] {
	color: #ccc;
	background: none;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	font-size: 1em;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;

}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #2d2d2d;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.block-comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: #999;
}

.token.punctuation {
	color: #ccc;
}

.token.tag,
.token.attr-name,
.token.namespace,
.token.deleted {
	color: #e2777a;
}

.token.function-name {
	color: #6196cc;
}

.token.boolean,
.token.number,
.token.function {
	color: #f08d49;
}

.token.property,
.token.class-name,
.token.constant,
.token.symbol {
	color: #f8c555;
}

.token.selector,
.token.important,
.token.atrule,
.token.keyword,
.token.builtin {
	color: #cc99cd;
}

.token.string,
.token.char,
.token.attr-value,
.token.regex,
.token.variable {
	color: #7ec699;
}

.token.operator,
.token.entity,
.token.url {
	color: #67cdcc;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}

.token.inserted {
	color: green;
}
 }
/* This is an arbitrary CSS string added to the bundle */
:root {
	/* --font-family: -apple-system, system-ui, sans-serif; */
	/* --font-family-monospace: Consolas, Menlo, Monaco, Andale Mono WT, Andale Mono, Lucida Console, Lucida Sans Typewriter, DejaVu Sans Mono, Bitstream Vera Sans Mono, Liberation Mono, Nimbus Mono L, Courier New, Courier, monospace;
	*/

    --font-family-monospace: Fira Code, Menlo, Consolas, Monaco, Liberation Mono, Lucida Console, monospace;


  /*    --text-font: Crimson Text, serif;*/
  /*    --text-font: Poppins, Verdana, sans-serif;*/
  /*    --heading-font: Quicksand, sans-serif;*/
  /*    --text-font: Open Sans, sans-serif;*/
  /*    --text-font-size: 16px;*/
  /*    --heading-font: Open Sans, sans-serif;*/
  /*    --text-font: Cabin, sans-serif;*/
  /*    --text-font-size: 16px;*/
  /*    --text-font: Roboto, sans-serif;*/

  /*    --heading-font: Roboto, sans-serif;*/
  /*    --heading-font: Cabin, sans-serif;*/
  /*    --heading-font: Dosis, sans-serif;*/

  /*    --heading-font: Work Sans, sans-serif;*/
  /*    --text-font: Open Sans, sans-serif;*/

      /* --heading-font: Nunito, sans-serif; */
      --heading-font: ui-rounded, 'Hiragino Maru Gothic ProN', Quicksand, Comfortaa, Manjari, 'Arial Rounded MT', 'Arial Rounded MT Bold', Calibri, source-sans-pro, sans-serif;
  /*    --text-font: PT Sans, sans-serif;*/

  /*    --heading-font: Varela Round, sans-serif;*/
  /*    --text-font: Noto Serif, serif;*/

  /*    --text-font: Lato, sans-serif;*/
      --text-font-size: 17px;

  /*    --text-font: Merriweather, sans-serif;*/
  /*    --text-font-size: 16px;*/

  /* https://css-tricks.com/snippets/css/system-font-stack/ */
  /* https://systemfontstack.com/ */

    /* system font on all platforms */
  /*    --heading-font: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu;*/
      /* --text-font: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu; */
      --text-font: -apple-system, system-ui, sans-serif;
			/* system-ui, sans-serif; */


/* Theme colors */

	/* --color-gray-20: #e0e0e0;
	--color-gray-50: #C0C0C0;
	--color-gray-90: #333; */

	--background-color: #fff;

	/* --text-color: var(--color-gray-90); */
	/* --text-color-link: #082840; */

	/* --text-color-link: #ff0000; */
	/* --text-color-link-active: #5f2b48; */
	/* --text-color-link-visited: #17050F; */


	/* --syntax-tab-size: 2; */

	--bright-text-color: #222;
	--link-color: #3273dc;
	/* --link-color: #ff5e6c; */
	--link-visited-color: #6e4bbe;
	--background-color: #fff;
	--text-color: #444;
	--faded-text-color: #777;
	--blockquote-text-color: var(--bright-text-color);
	--faint-color: #ccc;
}

@media (prefers-color-scheme: dark) {
	:root {
		/* --color-gray-20: #e0e0e0; */
		/* --color-gray-50: #C0C0C0; */
		/* --color-gray-90: #dad8d8; */

		/* --text-color is assigned to --color-gray-_ above */
		/* --text-color-link: #1493fb; */
		/* --text-color-link-active: #6969f7; */
		/* --text-color-link-visited: #a6a6f8; */

		--background-color: #15202b;

		--bright-text-color: #eee;
		--link-color: #8cc2dd;
		--link-visited-color: #b9a9e0;
		--background-color: #333;
		--text-color: #ddd;
		--faded-text-color: #aaa;
		--slightly-dimmer-text-color: #ccc;
		--blockquote-text-color: var(--slightly-dimmer-text-color);
		--faint-color: #666;

		color-scheme: dark; /* sets scrollbar colour */
	}

	.theme-affected {
		filter: invert(.8);
	}
}

body {
	box-sizing: border-box;

	/* https://github.com/sindresorhus/github-markdown-css */
	min-width: 200px;
	/* max from old blog */
	/* max-width: 40em; */
	/* tiny bit wider because prism adds some padding */
	max-width: 726px;

	margin: 0 auto;
	padding: 0 20px;

	/* enable ligatures */
	text-rendering: optimizeLegibility;

	font-family: var(--text-font);
	font-size: var(--text-font-size);
	color: var(--text-color);
	background-color: var(--background-color);

	/*
	text-align: left;
	word-wrap: break-word;
	overflow-wrap: break-word;
	*/
	/* line-height: 1.5; */
}

@media (max-width: 767px) {
	body {
		padding: 0px 1em;
	}
}

@view-transition {
	navigation: auto;
}

html {
	overflow-y: scroll;
}

/* https://github.com/Kimeiga/bahunya/blob/master/src/parts/_typography.css */
ul, ol {
  padding-left: 2em;
}

li {
	line-height: 1.5;
}

h1, h2, h3, h4, h5, h6 {
	font-family: var(--heading-font);
	color: var(--bright-text-color);
	font-weight: normal;
	line-height: 1.25;
}

footer {
	padding: 35px;
}

/* header {
	border-bottom: 1px dashed var(--color-gray-20);
} */


/* misc changes from here on */

/* https://www.a11yproject.com/posts/how-to-hide-content/ */
.visually-hidden {
	clip: rect(0 0 0 0);
	clip-path: inset(50%);
	height: 1px;
	overflow: hidden;
	position: absolute;
	white-space: nowrap;
	width: 1px;
}

p:has(img) {
	text-align: center;
}
/* Fluid images via https://www.zachleat.com/web/fluid-images/ */
img{
  max-width: 100%;
}
img[width][height] {
  height: auto;
}
/* img[src$=".svg"] {
  width: 100%;
  height: auto;
  max-width: none;
} */
video,
iframe {
	width: 100%;
	height: auto;
}
iframe {
	aspect-ratio: 16/9;
}

p:last-child {
	margin-bottom: 0;
}
p {
	line-height: 1.5;
}

a[href] {
	color: var(--link-color);
	text-decoration: none;
}

/* a[href]:visited {
	color: var(--link-visited-color);
} */

/* a[href]:hover,
a[href]:active { */
	/* color: var(--text-color-link-active); */
	/* text-decoration: underline; */
	/* text-decoration-thickness: 2px; */
/* } */

/* main :first-child {
	margin-top: 0;
} */

/* .links-nextprev {
	display: flex;
	justify-content: space-between;
	gap: .5em 1em;
	list-style: "";
	border-top: 1px dashed var(--color-gray-20);
	padding: 1em 0;
}
.links-nextprev > * {
	flex-grow: 1;
}
.links-nextprev-next {
	text-align: right;
} */

table {
	margin: 1em 0;
	border-collapse: collapse;
}
table td,
table th {
	padding-right: 1em;
}
/* table thead tr th {
  border-bottom: solid var(--text-color) 2px;
  border-top: solid var(--text-color) 2px;
} */

.table-lines td {
  border-bottom: solid var(--text-color) 1px;
  border-top: solid var(--text-color) 1px;
}

/* pre,
code {
	font-family: var(--font-family-monospace) !important;
	font-size: 14px !important;
} */

/* override prism */
/* https://github.com/orgs/PrismJS/discussions/2859 */
code[class*="language-"],
pre[class*="language-"] {
	font-family: var(--font-family-monospace);
	font-size: 14px;
}

pre[class*="language-"] {
	margin-top: 0;
	margin-bottom: 1em;
}

pre:not([class*="language-"]) {
	margin: .5em 0;
	line-height: 1.375; /* 22px /16 */
	/* -moz-tab-size: var(--syntax-tab-size); */
	/* -o-tab-size: var(--syntax-tab-size); */
	/* tab-size: var(--syntax-tab-size); */
	-webkit-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
	direction: ltr;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	overflow-x: auto;
}

.scroll-when-overflowing, pre {
	overflow-x: scroll;
  -ms-overflow-style: none;  /* IE and Edge */
  scrollbar-width: none;  /* Firefox */
}

.scroll-when-overflowing::-webkit-scrollbar, pre::-webkit-scrollbar {
  display: none;
}

/* mathjax v4, where display math is not centered */
mjx-container {
	margin: auto;
}
header {
			/* display: flex; */
			/* gap: 2em; */
			border-right: 10px;
			/* flex-wrap: wrap; */
			/* justify-content: space-between; */
			/* align-items: center; */
			align-items: end;
			padding-top: 1em;
			/* padding: 1em; */
		}
.nav-item {
				font-family: var(--heading-font);
				padding-right: 5px;
				display: inline-block;
			}
			
			.nav-item a[href][aria-current="page"] {
				text-decoration: underline;
				text-decoration-thickness: 2px;
			}</style>
	</head>
	<body>
		<a href="#skip" class="visually-hidden">Skip to main content</a>

		

		<header>

			
			
			
			<a href="/" style="padding-right: 10px; color: var(--text-color); font-family: var(--heading-font); font-size: 1.5em;">Darius Foo</a>
			
				
				
				
				
				
				
			
			
			<nav style="display: inline-block">
				<h2 class="visually-hidden" id="top-level-navigation-menu">Top level navigation menu</h2>
				<ul style="list-style: none; padding: 0; margin: 0;">
					<li class="nav-item"><a href="/blog/">Blog</a></li>
					<li class="nav-item"><a href="/research/">Research</a></li>
					<li class="nav-item"><a href="/work/">Work</a></li>
					<li class="nav-item"><a href="/games/">Games</a></li>
				</ul>
			</nav>
		</header>

		<main id="skip">
			

<h1 style="margin-top: 1rem; margin-bottom: 0.2em" id="verifying-effectful-higher-order-programs-with-staged-logic">Verifying effectful higher-order programs with staged logic</h1>



<div class="post-metadata">
	
	<time style="font-size: 0.9em;" datetime="2024-08-16">16 Aug 2024</time>
	
	
</div>

<div class="blog-content">
<!-- (23 Aug 2024) -->
<!-- (13 Sep 2024) -->
<p><em>Text version of a talk given at the <a href="https://nus-plse.github.io/seminars.html">NUS PLSE Seminar</a> and <a href="https://www.fm24.polimi.it/?page_id=612">FM 2024</a> in Milan.</em></p>
<ul>
<li><a href="#effectful-higher-order-functions">Effectful higher-order functions</a></li>
<li><a href="#specifying-higher-order-functions-today">Specifying higher-order functions today</a>
<ul>
<li><a href="#example-1-mutating-the-list">Example 1: mutating the list</a></li>
<li><a href="#example-2-stronger-precondition">Example 2: stronger precondition</a></li>
<li><a href="#example-3-effects-outside-metalogic">Example 3: effects outside metalogic</a></li>
</ul>
</li>
<li><a href="#staged-logic">Staged logic</a>
<ul>
<li><a href="#effectful-placeholders">Effectful placeholders</a></li>
<li><a href="#recursion">Recursion</a></li>
<li><a href="#re-summarization">Re-summarization</a></li>
<li><a href="#compaction-via-biabduction">Compaction via biabduction</a></li>
</ul>
</li>
<li><a href="#solutions-to-problematic-examples">Solutions to problematic examples</a>
<ul>
<li><a href="#example-1">Example 1</a></li>
<li><a href="#example-2">Example 2</a></li>
<li><a href="#example-3">Example 3</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h1 id="effectful-higher-order-functions">Effectful higher-order functions</h1>
<p>Most programming languages in use today are higher-order, and allow programmers to perform <em>effects</em> (primitive state, exceptions, or algebraic effects) in any context.</p>
<p>This enables expressive programming patterns, e.g. using state in a closure to avoid traversing a list twice:</p>
<pre class="language-ocaml" tabindex="0"><code class="language-ocaml"><span class="token comment">(* sum a list, and also count the number of elements *)</span>
<span class="token keyword">let</span> count <span class="token operator">=</span> ref <span class="token number">0</span> <span class="token keyword">in</span>
foldr <span class="token punctuation">(</span><span class="token keyword">fun</span> c t <span class="token operator">-></span> incr count<span class="token punctuation">;</span> c<span class="token operator">+</span>t<span class="token punctuation">)</span> xs <span class="token number">0</span></code></pre>
<p>or using a continuation to return multiple solutions when backtracking, and allowing the continuation to throw an exception to end the search efficiently:</p>
<pre class="language-ocaml" tabindex="0"><code class="language-ocaml"><span class="token keyword">let</span> stop <span class="token operator">=</span> raise Stop
<span class="token keyword">let</span> <span class="token keyword">rec</span> search xs k <span class="token operator">=</span>
  <span class="token keyword">try</span>
    <span class="token keyword">if</span> found <span class="token keyword">then</span> k answer<span class="token punctuation">;</span>
    <span class="token comment">(* ... keep searching *)</span>
  <span class="token keyword">with</span> Stop <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">in</span>
<span class="token keyword">let</span> result <span class="token operator">=</span> search xs <span class="token punctuation">(</span><span class="token keyword">fun</span> answer <span class="token operator">-></span> <span class="token keyword">if</span> good answer <span class="token keyword">then</span> stop <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>Using a <a href="https://github.com/ocaml-multicore/picos#motivation">modern I/O library</a> also makes algebraic effects pervasive.</p>
<p>Reasoning about effectful higher-order functions does not seem particularly difficult - we certainly do it informally every time we use them in programs!
However, support for such functions in automated verifiers varies greatly:</p>
<ul>
<li><em>Most automated verifiers require function arguments to be pure</em>. Examples include Dafny, Why3, and Cameleer. This is because they lift these functions into the underlying logic (usually the first-order logic of SMT) and are restricted by what can be expressed in it.</li>
<li><em>Other automated verifiers rely on type system guarantees</em>. Examples include Prusti and Creusot, which target Rust and can exploit the fact that closures can maintain invariants over their captured state via ownership. This makes the problem simpler, with the tradeoff that this approach does not work in languages with weaker type systems.</li>
<li><em>Most verifiers which do support such functions are interactive</em>. Examples include Iris, CFML, and Steel/Pulse (F*), which are built on proof assistants. In practice, this means that they support varying levels of automation, with the tradeoff being that they are more expressive.</li>
</ul>
<p>A second issue is that even when higher-order functions are supported, they tend to be specified <em>imprecisely</em>. We'll see an example of this shortly.</p>
<p>The question we're concerned with in this work is: is there a <em>precise</em> and <em>general</em> way to support effectful higher-order functions in <em>automated</em> program verifiers?</p>
<h1 id="specifying-higher-order-functions-today">Specifying higher-order functions today</h1>
<div style="display:none">
<p>[object Promise]
[object Promise]
[object Promise]
[object Promise]
[object Promise]
[object Promise]
[object Promise]
[object Promise]
[object Promise]
[object Promise]
[object Promise]
[object Promise]
[object Promise]</p>
</div>
<p>We'll use the classic [object Promise] function as a running example.</p>
<pre class="language-ocaml" tabindex="0"><code class="language-ocaml"><span class="token keyword">let</span> foldr f a l <span class="token operator">=</span>
  <span class="token keyword">match</span> l <span class="token keyword">with</span>
  <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=></span> a
  <span class="token operator">|</span> h <span class="token punctuation">::</span> t <span class="token operator">=></span>
    f h <span class="token punctuation">(</span>foldr f a t<span class="token punctuation">)</span></code></pre>
<p>[object Promise] is <em>effectful</em> - it may have state, exceptions, or algebraic effects.
[object Promise] is hence an <em>effectful higher-order function</em>.</p>
<p>We would like to specify [object Promise] in a way that allows a wide range of clients to be verified, including the one we saw earlier, which calls [object Promise] with a closure.</p>
<pre class="language-ocaml" tabindex="0"><code class="language-ocaml"><span class="token keyword">let</span> count <span class="token operator">=</span> ref <span class="token number">0</span> <span class="token keyword">in</span>
foldr <span class="token punctuation">(</span><span class="token keyword">fun</span> c t <span class="token operator">-></span> incr count<span class="token punctuation">;</span> c <span class="token operator">+</span> t<span class="token punctuation">)</span> <span class="token number">0</span> xs</code></pre>
<p>Here is a specification one might write today in a modern program logic<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup>.</p>
[object Promise]<ol>
<li><span class="trigger" data-id="inv">The most salient feature</span> of this specification is that it is parameterized over an <em>invariant</em> [object Promise], a (separation logic) <em>property</em> whose purpose is to describe the result of [object Promise]. It does this by relating the suffix of the list traversed so far - initially empty, and finally [object Promise] - with the result of the fold.</li>
<li>Next, we use a <span class="trigger" data-id="finv">nested triple</span> to require that [object Promise] must preserve the invariant - assuming that the invariant holds of the portion of the list that has been folded [object Promise] and the result of the recursive call [object Promise], [object Promise] must reestablish it for [object Promise] and its result [object Promise]. This is fair, as [object Promise] contains a call to [object Promise], and so we need the knowledge that [object Promise] preserves the invariant to ensure that [object Promise] does. As the invariant is a separation logic property, it may also be seen as a way to describe the effect of [object Promise].</li>
<li>Anticipating that some clients may want to operate only on certain kinds of lists, the specification is further <span class="trigger" data-id="ppred">parameterized</span> over a unary predicate [object Promise]. A precondition [object Promise], which must be proved at each call site, allows [object Promise] to then rely on [object Promise] in its precondition.</li>
<li><span class="trigger" data-id="shape">A shape predicate</span> [object Promise] relating the list structure [object Promise] to its content [object Promise] appears in both pre- and postcondition. This is to say that [object Promise] should not change the list.</li>
</ol>
<style>
  .highlight {
    color: red;
  }
  .trigger {
    text-decoration: underline;
    cursor: help;
  }
</style>
<script>
const foldrHighlightData = {
  'inv': 'foldrinv',
  'shape': 'shape',
  'ppred': 'ppred',
  'finv': 'preserve',
};
document.addEventListener('mouseover', function(event) {
  let elt=event.target.closest('.trigger');
  if (elt !== null) {
    document.querySelectorAll('.' + foldrHighlightData[elt.dataset.id])
      .forEach(a => a.classList.add('highlight'));
  }
});
document.addEventListener('mouseout', function(event) {
  let elt=event.target.closest('.trigger');
  if (elt !== null) {
    document.querySelectorAll('.' + foldrHighlightData[elt.dataset.id])
      .forEach(a => a.classList.remove('highlight'));
  }
});
</script>
<p>This specification elegantly solves the problem for the client we presented earlier (using an invariant to relate the value of [object Promise] and [object Promise], and an identity [object Promise]).
We argue, however, that it is <em>imprecise</em>: there are many clients that <em>cannot be verified</em> using it <em>without significant changes</em>.</p>
<p>The authors of the specification say as much<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">1</a></sup>:</p>
<!-- [Iris tutorial](https://iris-project.org/tutorial-pdfs/iris-lecture-notes.pdf) says as much (pg 35): -->
<blockquote>
<p>Different clients may instantiate foldr with some very different functions, hence it can be hard to give a specification for f that is reasonable and general enough to support all these choices.</p>
</blockquote>
<p>The problem is that due to the use of abstract properties, this specification commits somewhat prematurely to an <em>abstraction</em> of [object Promise]'s behavior, and this abstraction may not be precise enough to verify a given client.</p>
<p>We'll look at three examples of such clients.</p>
<h2 id="example-1-mutating-the-list">Example 1: mutating the list</h2>
<p>Suppose we allowed [object Promise] to mutate the list.</p>
<pre class="language-ocaml" tabindex="0"><code class="language-ocaml"><span class="token keyword">let</span> foldr_ex1 l <span class="token operator">=</span> foldr <span class="token punctuation">(</span><span class="token keyword">fun</span> x r <span class="token operator">-></span> <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token operator">!</span>x <span class="token keyword">in</span>
                                    x <span class="token operator">:=</span> v<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> v<span class="token operator">+</span>r<span class="token punctuation">)</span> l <span class="token number">0</span></code></pre>
<p>This is not technically allowed by the shape predicate in the postcondition, but suppose we changed it to [object Promise].</p>
<p>The problem is that [object Promise] tells us nothing about [object Promise].
The use of invariants required us to <em>commit to a parameterization</em>, and this particular one is insufficient.</p>
<p>To fix this, we would have to add [object Promise] as a parameter to every occurrence of [object Promise].
While adding results in a more general specification, it would also be cluttered with more anticipated client use cases.</p>
<h2 id="example-2-stronger-precondition">Example 2: stronger precondition</h2>
<p>Suppose we would like to pass a function argument which relies on a property concerning intermediate results of the fold.</p>
<pre class="language-ocaml" tabindex="0"><code class="language-ocaml"><span class="token keyword">let</span> foldr_ex2 l <span class="token operator">=</span> foldr <span class="token punctuation">(</span><span class="token keyword">fun</span> x r <span class="token operator">-></span> <span class="token keyword">assert</span><span class="token punctuation">(</span>x<span class="token operator">+</span>r<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> x<span class="token operator">+</span>r<span class="token punctuation">)</span> l <span class="token number">0</span></code></pre>
<p>The problem here is that we can't use [object Promise] to strengthen the precondition of [object Promise], as we need a property relating [object Promise] and [object Promise], and [object Promise] only constrains [object Promise]. [object Promise] also cannot be used, as it only tells us about [object Promise], not [object Promise].</p>
<p>While it is possible to assume something stronger here, e.g. [object Promise], in general it would be awkward to decompose the property into two parts.</p>
<h2 id="example-3-effects-outside-metalogic">Example 3: effects outside metalogic</h2>
<p>This example illustrates a different problem with invariants: suppose we allowed the function to throw an exception.</p>
<pre class="language-ocaml" tabindex="0"><code class="language-ocaml"><span class="token keyword">let</span> foldr_ex3 l <span class="token operator">=</span> foldr <span class="token punctuation">(</span><span class="token keyword">fun</span> x r <span class="token operator">-></span> <span class="token keyword">if</span> x<span class="token operator">>=</span><span class="token number">0</span> <span class="token keyword">then</span> x<span class="token operator">+</span>r
                                    <span class="token keyword">else</span> raise Exc<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> l <span class="token number">0</span></code></pre>
<p>The problem is that our specification requires [object Promise] to <em>return</em> to preserve the invariant, and does not say anything about exceptions.</p>
<p>The more general issue is that we are trying to abstract [object Promise]'s behavior into a predicate of the underlying logic, and that limits expressiveness to that of the underlying logic.</p>
<p>This is the reason that, as mentioned earlier, many automated verifiers do not handle closures, because they lift function arguments into the pure, first-order logic of SMT, which cannot abstract over heap manipulation.
While separation logic can, it says nothing about exceptions/effects.
One would need some kind of (monadic) encoding or <a href="https://devilhena-paulo.github.io/thesis/de-vilhena-thesis.pdf">protocol</a>, a fundamentally different specification.</p>
<h1 id="staged-logic">Staged logic</h1>
<p>Taking a step back, why did we have to abstract away the behavior of [object Promise] to begin with?</p>
<p>The problem was that it was difficult to represent (1) unknown higher-order effectful calls and (2) ordering of effects precisely in pre/post specifications.
Our idea is thus to generalize Hoare triples with the ingredients required to represent them.</p>
<p>Suppose we think of the traditional [object Promise] and [object Promise]  as propositions in some new logical language [object Promise] for describing effectful behavior.</p>
[object Promise]<p>[object Promise] and [object Promise] are symbolic-heap separation logic formulae,</p>
[object Promise]<p>and [object Promise] may be thought of as a separation logic <em>assert</em> (or <em>exhale</em>, in Viper terms, which requires the presence of a portion of heap and consumes it), and [object Promise] as the dual notion of <em>assume</em> (or <em>inhale</em>, which produces a portion of heap).</p>
<p>We then extend this language with two new constructs: sequencing and (un)interpreted relations.</p>
[object Promise]<!-- We call $\varphi$ a *staged formula*, for reasons that will be explained shortly. -->
<!-- $\sigma{\wedge}\pi$ is a symbolic-heap separation logic formula. -->
<p>What is the semantics of such formulae? We defer a detailed answer to our paper<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup>, but a first approximation is the following generalization, starting from the (partial correctness) semantics of Hoare triples.</p>
[object Promise]<p>Suppose we redefined Hoare triples in terms of a new &quot;bold&quot; kind of triple, with the new formula type on both sides.
Intuitively, the formula on the left describes a &quot;history&quot;, while the formula on the right describes the behavior of [object Promise] on top of that history.</p>
<p>This is a specific case of this new kind of triple.
The more general case could have its semantics defined as follows.</p>
[object Promise]<p>Now we can clearly see how this new kind of triple generalizes the standard one: where we previously had a precondition [object Promise] constraining the initial state [object Promise], and a postcondition [object Promise] constraining the final state [object Promise] and result [object Promise], we now have a formula constraining the same three things, with the ability to have an arbitrary number of assertions.</p>
<p>To give a flavour of some reasoning rules, here is the standard separation logic rule for load/deference, followed by our new one.</p>
[object Promise][object Promise]<!-- https://github.com/KaTeX/KaTeX/issues/471 -->
<p>It shouldn't be too surprising, as it mostly follows the schema we just presented.</p>
<p>The advantage of having the precondition on the right becomes clearer with the rule for function application, which is the first place where our new logic fundamentally differs.</p>
[object Promise][object Promise]<p>First, we have the standard separation logic rule for function application. The key part is that some <em>knowledge</em> or <em>specification</em> of [object Promise] is required to prove that it is safe to call in a state satisfying [object Promise]. Once this is done via the entailment on the right, a postcondition [object Promise] (with appropriate substitutions) and frame [object Promise] are produced, allowing us to continue.</p>
<p>On the other hand, the new rule requires no knowledge of the function being called, and can hence work even when [object Promise] is completely unknown, as is the case when it is a possibly effectful function parameter.
Placing the precondition on the right essentially allows us to defer checking it until a later.</p>
<p>We call this new language of formulae <em>staged logic</em>. It consists of the following ingredients.</p>
<ol>
<li>Sequencing and uninterpreted relations</li>
<li>Recursive formulae</li>
<li>Re-summarization of recursion (lemmas)</li>
<li>Compact sequences of pre/post stages using biabduction</li>
</ol>
<p>The insight is that these allow us to <em>defer abstraction</em> until appropriate.</p>
<p>We go over each in turn using examples, then present solutions to the clients we couldn't verify earlier before concluding.</p>
<h2 id="effectful-placeholders">Effectful placeholders</h2>
<p>Consider the following toy heap-manipulating program. [object Promise] is an effectful higher-order function, as it calls an unknown function [object Promise].</p>
<pre class="language-ocaml" tabindex="0"><code class="language-ocaml"><span class="token keyword">let</span> hello f x y <span class="token operator">=</span>
  x <span class="token operator">:=</span> <span class="token operator">!</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> r <span class="token operator">=</span> f y <span class="token keyword">in</span>
  <span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">!</span>x <span class="token operator">+</span> r <span class="token keyword">in</span>
  y <span class="token operator">:=</span> r2<span class="token punctuation">;</span>
  r2</code></pre>
<p>Here is a possible specification for it.</p>
[object Promise]<p>Sequencing and uninterpreted relations together allow us to leave placeholders for unknown function parameters, to represent their effects.</p>
<p>Stateful behavior is otherwise <em>compacted</em> into a single [object Promise]/[object Promise] pair.</p>
<!-- $f$ may be seen as *stratifying* the behavior of $\m{hello}$ into two *stages* under [compaction](#compaction-via-biabduction), hence the name "staged formulae", in allusion to *staged programming*. -->
<p>One might wonder why we must require the presence of [object Promise] and [object Promise] after the call to [object Promise].
For [object Promise], this is easy, as it is passed as an argument to [object Promise], and we have to require that it is not, e.g., deallocated.
Interestingly, we also cannot assume anything about [object Promise] after the call to [object Promise]. As [object Promise] is unknown and arbitrary, it is possible that it may capture [object Promise] and cause it to have a potentially different value after, [object Promise].</p>
<p>Another detail is that this specification assumes that [object Promise] and [object Promise] are not aliased. Details on how to relax this assumption are in the paper<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">2</a></sup>.</p>
<!--

Sequencing of multiple effectful functions can be represented directly.

```ocaml
let compose f g x = f (g x)
```

$$
\m{compose}(f, g, x, \m{res}) = \exists r.\ g(x, r); f(r, \m{res})
$$

-->
<h2 id="recursion">Recursion</h2>
<p>Recursive programs are naturally represented by recursive specifications.</p>
<!-- under a least fixed point interpretation -->
<pre class="language-ocaml" tabindex="0"><code class="language-ocaml"><span class="token keyword">let</span> foldr f a l <span class="token operator">=</span>
  <span class="token keyword">match</span> l <span class="token keyword">with</span>
  <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=></span> a
  <span class="token operator">|</span> h <span class="token punctuation">::</span> t <span class="token operator">=></span>
    f h <span class="token punctuation">(</span>foldr f a t<span class="token punctuation">)</span></code></pre>
<p>here is a staged logic specification for it:</p>
[object Promise]<p>Most importantly, the call to [object Promise] can be represented directly, without abstraction.</p>
<p>This specification looks very much like the program, because there is no state that could benefit from being expressed with separation logic.
However, it is still an abstraction of the program.</p>
<p>Comparing this to the previous specification, this time expressed as a single [object Promise]/[object Promise] pair in staged logic,</p>
[object Promise]<p>we see that it is longer and more complex, and contains all kinds of paramterization to make up for the inability to speak simply about ordering.
Leaving the recursion in the specification <em>before</em> we are aware of what clients expect (and thus, what kind of abstraction is appropriate) is what allows staged specifications to be more precise.</p>
<!-- not precise when it comes to concurrency due to summary of stateful behavior, which may no longer be atomic -->
<h2 id="re-summarization">Re-summarization</h2>
<p>We previously saw function calls represented without any abstraction in specifications, which probably wouldn't work well in large programs.
We would hence like to recover abstraction at some appropriate time.
That time tends to be at calls;
given a use of [object Promise] such as the following, which passes a closure as an argument,</p>
<pre class="language-ocaml" tabindex="0"><code class="language-ocaml"><span class="token keyword">let</span> foldr_sum_state x xs init <span class="token operator">=</span>
  <span class="token keyword">let</span> g c t <span class="token operator">=</span> x <span class="token operator">:=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> c <span class="token operator">+</span> t <span class="token keyword">in</span>
  foldr g xs init</code></pre>
<p>and a user-provided specification (below), we can verify the above program by proving the following entailment.</p>
[object Promise]<p>This may also be seen as a means of <em>recovering abstraction</em>,
or <em>re-summarizing</em> the relatively low-level staged specification,
to get rid of recursion and explicit occurrences of unknown functions
and produce a simpler, non-recursive summary of its behavior.</p>
<p>This example also demonstrates the utility of staged logic,
which allows us to very plainly state the effectful behavior of the program,
and also <em>prove the entailment automatically</em>.</p>
<p>In the paper<sup class="footnote-ref"><a href="#fn2" id="fnref2:2">2</a></sup>, we define a set of syntactic proof rules for reducing [object Promise]-entailments (modulo <em>compaction</em>) into separation logic proof obligations,
which can be discharged using an off-the-shelf SL prover and SMT.
This particular proof uses an inferred (or provided, in general) induction hypothesis.</p>
<h2 id="compaction-via-biabduction">Compaction via biabduction</h2>
<p>The final piece is <em>compaction</em>, which allows us to have the expressiveness of stages, but also the <em>succinctness</em> of triples when the extra expressiveness is not needed.
In short, it allows any staged formula to always be transformed into the following normal form.</p>
[object Promise]<p>Compaction can be seen as a normalization procedure for (programs represented as) staged formulae.
This is key not only for entailment proofs, but for automation:
in our prototype, users only need to provide essential lemmas, and all other intermediate specifications are derived mechanically.
In this way, compaction functions as a means of specification inference in a verification setting.</p>
<p>We'll illustrate it by example on the heap-manipulating [object Promise] program we saw earlier.</p>
[object Promise]<p>This specification is already in normal form, but suppose we find out an interpretation for [object Promise], for example, from the following client.</p>
<pre class="language-ocaml" tabindex="0"><code class="language-ocaml"><span class="token keyword">let</span> z <span class="token operator">=</span> ref <span class="token number">0</span> <span class="token keyword">in</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> ref <span class="token number">1</span> <span class="token keyword">in</span>
hello <span class="token punctuation">(</span><span class="token keyword">fun</span> <span class="token punctuation">_</span> <span class="token operator">-></span> incr z<span class="token punctuation">;</span> <span class="token number">0</span><span class="token punctuation">)</span> z y</code></pre>
<p>Now we have the following interpretation for [object Promise].</p>
[object Promise]<p>Unfolding [object Promise] in [object Promise] (and doing some renaming),</p>
[object Promise]<p>This specification is not in normal form.
Focusing on the boxed portions, we see an [object Promise] followed by a [object Promise].
We can apply the following normalization rule.</p>
[object Promise]<p>In other words, it suffices to solve a <a href="https://fbinfer.com/docs/separation-logic-and-bi-abduction/">biabductive entailment</a> to infer a pair of <em>frame</em> (in the separation logic sense) and <em>antiframe</em> (an additional condition [object Promise] required for [object Promise] to entail [object Promise]).
We can then use these in place of the original conditions, &quot;swapping&quot; them around, or &quot;pushing&quot; the [object Promise] &quot;through&quot; the [object Promise].</p>
<p>For this example, one solution is:</p>
[object Promise]<p>We can thus transform [object Promise] as follow.</p>
[object Promise]<p>Now we have two consecutive [object Promise] and [object Promise] stages.
We can normalize them using the following rules.</p>
[object Promise]<p>Now we have this, and again we have another [object Promise]/[object Promise] pair.</p>
[object Promise]<p>Here's the solution...</p>
[object Promise]<p>... and final state, after one more round of simplification (not shown).</p>
[object Promise]<p>Now the specification for this call to [object Promise] is in normal form, and we can use it for subsequent reasoning.
We see also that it precisely captures the aggregate behavior of this call, including the state changes.</p>
<h1 id="solutions-to-problematic-examples">Solutions to problematic examples</h1>
<p>Going back to the problematic clients we highlighted previously,
how can we tackle them using staged logic,
and how does the approach differ from the invariant-based way of writing specifications given in the introduction?</p>
<p>All the following assume the specification for [object Promise] is as given in the previous section.
Crucially, none have to change it to solve all problems.</p>
<h2 id="example-1">Example 1</h2>
<pre class="language-ocaml" tabindex="0"><code class="language-ocaml"><span class="token keyword">let</span> foldr_ex1 l <span class="token operator">=</span> foldr <span class="token punctuation">(</span><span class="token keyword">fun</span> x r <span class="token operator">-></span> <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token operator">!</span>x <span class="token keyword">in</span>
                                    x <span class="token operator">:=</span> v<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> v<span class="token operator">+</span>r<span class="token punctuation">)</span> l <span class="token number">0</span></code></pre>
<p>An invariant to tell us about the content of the list is not needed.
Instead, we describe the final content of the list in terms of the initial content using a pure function [object Promise], alongside the result.
The list is described using a shape predicate.</p>
[object Promise]<!--

$$
\begin{array}{l}
\m{mapinc}(\xs, \ys) = \\
\quad \phantom{\vee\ } (\xs{=}[]{\wedge}\ys) \\
\quad \vee\ (\exists x, \xs_1, \ys.\ \xs{=}x{::}\xs_1{\wedge}\ys{=}(x{+}1){::}\ys_1) \wedge \m{mapinc}(\xs_1, \ys_1) \\ \\
\list(l, \m{rs}) = \\
\quad \phantom{\vee\ } (\emp{\wedge}l{=}[]) \\
\quad \vee\ (\exists x, \m{rs}_1, l_1.\ x{\mapsto}r * \list(l_1,\m{rs}_1){\wedge}l{=}x{::}l_1 {\wedge} \m{rs}{=}r{::}\m{rs}_1)
\end{array}
$$

-->
<h2 id="example-2">Example 2</h2>
<pre class="language-ocaml" tabindex="0"><code class="language-ocaml"><span class="token keyword">let</span> foldr_ex2 l <span class="token operator">=</span> foldr <span class="token punctuation">(</span><span class="token keyword">fun</span> x r <span class="token operator">-></span> <span class="token keyword">assert</span><span class="token punctuation">(</span>x<span class="token operator">+</span>r<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> x<span class="token operator">+</span>r<span class="token punctuation">)</span> l <span class="token number">0</span></code></pre>
<p>To enable the assertion in the function argument to be proved, we explicate the assumption that all suffix-sums of the list are positive using a pure function of [object Promise]. This can be directly given as part of the user-provided specificaton on the right.</p>
[object Promise]<p>In this example, we are not concerned with shapes, and fittingly, shape predicates do not appear at all in the specification or lemma.</p>
<!--
$$
\begin{array}{l}
\m{allSPos}(l) = \\
\phantom{\vee\ } (l{=}[]) \\
\vee\ (\exists x, r, l_1.\ l=x{::}l_1 \wedge \m{allSPos}(l_1)\wedge \m{sum}(l,r) \wedge r{\geq}0)
\end{array}
$$
-->
<h2 id="example-3">Example 3</h2>
<pre class="language-ocaml" tabindex="0"><code class="language-ocaml"><span class="token keyword">let</span> foldr_ex3 l <span class="token operator">=</span> foldr <span class="token punctuation">(</span><span class="token keyword">fun</span> x r <span class="token operator">-></span> <span class="token keyword">if</span> x<span class="token operator">>=</span><span class="token number">0</span> <span class="token keyword">then</span> x<span class="token operator">+</span>r
                                    <span class="token keyword">else</span> raise Exc<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> l <span class="token number">0</span></code></pre>
<p>An exception can be modelled as an <em>interpreted</em> relation (more on the semantics of handlers in our ICFP 2024 paper<sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup>).</p>
<!-- Given a pure function to describe lists containing only positive elements,

$$
\begin{array}{l}
\m{allPos}(l) = \\
\phantom{\vee\ } (l{=}[]) \\
\vee\ (\exists x, l_1.\ l=x{::}l_1 \wedge \m{allPos}(l_1)\wedge r{\geq}0)
\end{array}
$$

-->
<p>We can give a precise description of the conditions under which an exception is thrown via the following entailment.</p>
[object Promise]<p>The underlying logic is still symbolic-heap separation logic; we do not delegate effects to it.
Staged logic may thus be seen as a behavioral layer on top of separation logic, which excels when one is describing individual program states.</p>
<h1 id="conclusion">Conclusion</h1>
<p>We have described <em>staged logic</em>, a generalization of Hoare triples for specifying effectful higher-order programs and verifying them in an automated setting.</p>
<p>It fits well into the standard workflow of automated program verifiers:
given a program and a property it should satisfy,
a staged formula is derived from the program,
and the resulting entailment is automatically proved,
with lemmas and induction hypotheses provided by the user.</p>
<p>Since staged logic generalizes Hoare logic,
one can easily &quot;fall back&quot; to triples in cases where the expressiveness of stages is not needed,
and employ abstraction, invariants, and all the other techniques which have been developed for program proofs.
There is no need to always specify programs as disjunctions of paths, or always capture the ordering of every function call and effect,
however the crucial thing is that <em>the option to do so is available</em> where it makes specifications more natural.</p>
<p>Check out our paper<sup class="footnote-ref"><a href="#fn2" id="fnref2:3">2</a></sup> for the details.</p>
<p>These ideas have been implemented in a prototype verifier called <a href="https://github.com/hipsleek/heifer">Heifer</a>, which we hope will grow into a practical verification tool for real programs.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Taken from the <a href="https://iris-project.org/tutorial-pdfs/iris-lecture-notes.pdf">Iris lecture notes</a>, pg 32 <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Our FM24 paper may be found <a href="https://raw.githubusercontent.com/hipsleek/Heifer/StagedSL/docs/FM2024_TR.pdf">here</a> <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a> <a href="#fnref2:2" class="footnote-backref">↩︎</a> <a href="#fnref2:3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Our ICFP24 paper may be found <a href="https://www.comp.nus.edu.sg/~yahuis/ICFP24/ICFP2024.pdf">here</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

</div>

		</main>

		<footer>
			
		</footer>

		<!-- This page `/blog/staged-logic/` was built on 2025-12-06T06:57:03.499Z -->
		
	</body>
</html>
