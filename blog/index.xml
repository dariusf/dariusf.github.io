<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on Darius Foo</title><link>https://dariusf.github.io/blog/</link><description>Recent content in Blog on Darius Foo</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><copyright>Copyright Â© 2022, Darius Foo.</copyright><lastBuildDate>Fri, 15 Jul 2022 20:31:50 +0800</lastBuildDate><atom:link href="https://dariusf.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Godot + C# + VSCode (macOS)</title><link>https://dariusf.github.io/godot-vscode/</link><pubDate>Fri, 15 Jul 2022 20:31:50 +0800</pubDate><guid>https://dariusf.github.io/godot-vscode/</guid><description>Install system dependencies:
brew install --cask mono-mdk dotnet-sdk godot-mono brew install mono $ which dotnet msbuild mono /usr/local/bin/dotnet /Library/Frameworks/Mono.framework/Versions/Current/Commands/msbuild /Library/Frameworks/Mono.framework/Versions/Current/Commands/mono Start Godot and create a project (e.g. $HOME/godot/hello).
Add a C# script to a node. This should generate hello.sln and hello.csproj files.
Set Editor &amp;gt; Editor Settings &amp;gt; Mono &amp;gt; Editor, so VSCode will be started when double-clicking script files.
Over to VSCode. Install the following extensions:
C# C# Tools for Godot godot-tools Mono Debug Open the project:</description></item><item><title>Trees with holes</title><link>https://dariusf.github.io/trees-with-holes/</link><pubDate>Mon, 16 May 2022 16:28:10 +0800</pubDate><guid>https://dariusf.github.io/trees-with-holes/</guid><description>While working on a top-down synthesis prototype, I got distracted by the issue of how to represent incomplete program fragments, with holes to be filled in.
The simple way:
type expr = | One | Plus of expr * expr | Hole let (__) = Hole let hypothesis = Plus (__, __) and this would probably have worked, but with quadratic-time substitution, since all the holes would be at the bottom of the tree.</description></item><item><title>A ShiViz Hello World</title><link>https://dariusf.github.io/hello-shiviz/</link><pubDate>Mon, 14 Feb 2022 13:25:48 +0800</pubDate><guid>https://dariusf.github.io/hello-shiviz/</guid><description>ShiViz visualizes space-time diagrams, a succinct way to represent distributed system executions.
The examples on the site are all rather large, so here's a tiny Hello World example which illustrates the input format and basic ideas.
client1 &amp;#34;message 1 sent&amp;#34; {&amp;#34;client1&amp;#34;:1} client2 &amp;#34;message 2 sent&amp;#34; {&amp;#34;client2&amp;#34;:1} server &amp;#34;message 2 received&amp;#34; {&amp;#34;server&amp;#34;:1, &amp;#34;client2&amp;#34;:1} server &amp;#34;message 1 sent received&amp;#34; {&amp;#34;client1&amp;#34;:1, &amp;#34;server&amp;#34;:2, &amp;#34;client2&amp;#34;:1} server &amp;#34;ack message 1&amp;#34; {&amp;#34;client1&amp;#34;:1, &amp;#34;server&amp;#34;:3, &amp;#34;client2&amp;#34;:1} client1 &amp;#34;internal&amp;#34; {&amp;#34;client1&amp;#34;:2} client1 &amp;#34;receive message 1 ack&amp;#34; {&amp;#34;client1&amp;#34;:3, &amp;#34;server&amp;#34;:3, &amp;#34;client2&amp;#34;:1} (?</description></item><item><title>Watching the screen for changes (macOS)</title><link>https://dariusf.github.io/watch-screen/</link><pubDate>Thu, 02 Dec 2021 17:25:08 +0800</pubDate><guid>https://dariusf.github.io/watch-screen/</guid><description>Sometimes all you need is for your computer to tell you when something on the screen changes. Maybe you're invigilating an exam over Zoom and your eyes are drying out from staring at the chat window, which does not (and probably will never) have any notification settings.
Rectangles The first piece is how to capture a small region of the screen. Interestingly, this is built into the screencapture command, which takes the coordinates and dimensions of a rectangular area to capture.</description></item><item><title>From Docker to VirtualBox</title><link>https://dariusf.github.io/virtualbox/</link><pubDate>Mon, 13 Sep 2021 11:07:06 +0800</pubDate><guid>https://dariusf.github.io/virtualbox/</guid><description>Docker is great for quickly dropping into a Linux environment, but isn't compatible with certain obscure use cases (mine being testing version-locked Java GUIs).
After a period of unsuccessfully installing random packages and toggling flags, I figured the next-easiest thing to do was to use VirtualBox. Perhaps surprisingly, it comes with an able CLI. Here's how it compares to Docker's.
Getting Started brew install --cask virtualbox There's no equivalent of docker run -it to start a VM and give me a shell; we'll have to use ssh.</description></item><item><title>Visualizing Z3's proofs</title><link>https://dariusf.github.io/z3-proofs/</link><pubDate>Sun, 21 Mar 2021 12:00:06 +0800</pubDate><guid>https://dariusf.github.io/z3-proofs/</guid><description>A writeup of a presentation I gave in class.
SMT solvers like Z3 are often also called automated theorem provers. Why? What do their proofs look like?
An SMT solver tells us if a formula in first-order logic (augmented with various theories) is satisfiable1: there is some assignment of variables that makes the formula true. Z3 can even produce such an assignment.
from z3 import * i = Int(&amp;#39;i&amp;#39;) solve(i &amp;gt; 0) [i = 1] Not every formula is satisfiable, though.</description></item><item><title>Pretty stack-and-heap diagrams</title><link>https://dariusf.github.io/stack-heap/</link><pubDate>Sun, 07 Feb 2021 00:13:31 +0800</pubDate><guid>https://dariusf.github.io/stack-heap/</guid><description>I'm teaching an introductory programming class this semester, which introduced students to the runtime stack and the heap in one of the early tutorials.
For consistency across face-to-face and online classes, I decided to have the diagrams in my slides instead of drawing them terribly over and over.
While there were lots of references for drawing such diagrams by hand, there didn't seem to be any small and simple tools for generating them.</description></item><item><title>Transparent iOS backups</title><link>https://dariusf.github.io/ios-backups/</link><pubDate>Thu, 30 Jul 2020 17:49:26 +0800</pubDate><guid>https://dariusf.github.io/ios-backups/</guid><description>Backing up an iOS device is nice and simple: there's iCloud, or connecting your device, opening Finder, and clicking Back Up Now. Unfortunately this process is also rather opaque: all we can do in Finder is to create and restore backups, not view their contents. I'd like to be able to extract individual files and archive them elsewhere.
At the time of writing there are no up-to-date and polished open source apps for simply viewing backup data in an open format, so here we'll explore how iOS backups are structured and figure out how to extract the raw files.</description></item><item><title>Bags of puzzle pieces in ASP</title><link>https://dariusf.github.io/asp-puzzle-pieces/</link><pubDate>Sat, 25 Nov 2017 12:15:06 +0800</pubDate><guid>https://dariusf.github.io/asp-puzzle-pieces/</guid><description>Answer set programming is an offshoot of traditional logic programming with a number of nice properties: programs always terminate, are fully declarative (i.e. clause ordering doesn't matter and search is complete, unlike Prolog), and have a well-defined semantics. Modelling a domain with relations is a wonderfully high-level way to reason about things, allowing complex rules to be represented concisely.
ASP is typically applied to hard search problems, but can model pretty much anything.</description></item></channel></rss>