<!doctype html><html lang=en-US><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://dariusf.github.io/images/favicon.png><title>Verifying effectful higher-order programs with staged logic | Darius Foo</title>
<meta name=title content="Verifying effectful higher-order programs with staged logic"><meta name=description content="Text version of a talk given at the NUS PLSE Seminar and FM 2024 in Milan.
Effectful higher-order functions Specifying higher-order functions today Example 1: mutating the list Example 2: stronger precondition Example 3: effects outside metalogic Staged logic Effectful placeholders Recursion Re-summarization Compaction via biabduction Solutions to the problematic examples Example 1 Example 2 Example 3 Conclusion Effectful higher-order functions Programs written in mainstream languages today are rife with effectful higher-order functions: functions which take other functions as arguments, where these arguments may use primitive side effects, such as state, exceptions, or algebraic effects."><meta name=keywords content><meta property="og:url" content="https://dariusf.github.io/drafts/staged/"><meta property="og:site_name" content="Darius Foo"><meta property="og:title" content="Verifying effectful higher-order programs with staged logic"><meta property="og:description" content="Text version of a talk given at the NUS PLSE Seminar and FM 2024 in Milan.
Effectful higher-order functions Specifying higher-order functions today Example 1: mutating the list Example 2: stronger precondition Example 3: effects outside metalogic Staged logic Effectful placeholders Recursion Re-summarization Compaction via biabduction Solutions to the problematic examples Example 1 Example 2 Example 3 Conclusion Effectful higher-order functions Programs written in mainstream languages today are rife with effectful higher-order functions: functions which take other functions as arguments, where these arguments may use primitive side effects, such as state, exceptions, or algebraic effects."><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:section" content="drafts"><meta property="article:published_time" content="2024-08-16T11:59:39+08:00"><meta property="article:modified_time" content="2024-08-16T11:59:39+08:00"><meta property="og:image" content="https://dariusf.github.io/images/favicon.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dariusf.github.io/images/favicon.png"><meta name=twitter:title content="Verifying effectful higher-order programs with staged logic"><meta name=twitter:description content="Text version of a talk given at the NUS PLSE Seminar and FM 2024 in Milan.
Effectful higher-order functions Specifying higher-order functions today Example 1: mutating the list Example 2: stronger precondition Example 3: effects outside metalogic Staged logic Effectful placeholders Recursion Re-summarization Compaction via biabduction Solutions to the problematic examples Example 1 Example 2 Example 3 Conclusion Effectful higher-order functions Programs written in mainstream languages today are rife with effectful higher-order functions: functions which take other functions as arguments, where these arguments may use primitive side effects, such as state, exceptions, or algebraic effects."><meta itemprop=name content="Verifying effectful higher-order programs with staged logic"><meta itemprop=description content="Text version of a talk given at the NUS PLSE Seminar and FM 2024 in Milan.
Effectful higher-order functions Specifying higher-order functions today Example 1: mutating the list Example 2: stronger precondition Example 3: effects outside metalogic Staged logic Effectful placeholders Recursion Re-summarization Compaction via biabduction Solutions to the problematic examples Example 1 Example 2 Example 3 Conclusion Effectful higher-order functions Programs written in mainstream languages today are rife with effectful higher-order functions: functions which take other functions as arguments, where these arguments may use primitive side effects, such as state, exceptions, or algebraic effects."><meta itemprop=datePublished content="2024-08-16T11:59:39+08:00"><meta itemprop=dateModified content="2024-08-16T11:59:39+08:00"><meta itemprop=wordCount content="3456"><meta itemprop=image content="https://dariusf.github.io/images/favicon.png"><meta name=referrer content="no-referrer-when-downgrade"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Code"><style>@media(prefers-color-scheme:light){:root{--bright-text-color:#222;--link-color:#3273dc;--link-visited-color:#6e4bbe;--background-color:#fff;--text-color:#444;--faded-text-color:#777;--blockquote-text-color:var(--bright-text-color);--faint-color:#ccc}.chroma{background-color:#fff}.chroma .x{}.chroma .err{color:#000}.chroma .lntd{vertical-align:top;padding:0;margin:0;border:0}.chroma .lntable{border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block}.chroma .hl{display:block;width:100%;background-color:#ffc}.chroma .lnt{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .ln{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .k{color:#a90d91}.chroma .kc{color:#a90d91}.chroma .kd{color:#a90d91}.chroma .kn{color:#a90d91}.chroma .kp{color:#a90d91}.chroma .kr{color:#a90d91}.chroma .kt{color:#a90d91}.chroma .n{color:#000}.chroma .na{color:#836c28}.chroma .nb{color:#a90d91}.chroma .bp{color:#5b269a}.chroma .nc{color:#3f6e75}.chroma .no{color:#000}.chroma .nd{color:#000}.chroma .ni{color:#000}.chroma .ne{color:#000}.chroma .nf{color:#000}.chroma .fm{color:#000}.chroma .nl{color:#000}.chroma .nn{color:#000}.chroma .nx{color:#000}.chroma .py{color:#000}.chroma .nt{color:#000}.chroma .nv{color:#000}.chroma .vc{color:#000}.chroma .vg{color:#000}.chroma .vi{color:#000}.chroma .vm{color:#000}.chroma .l{color:#1c01ce}.chroma .ld{color:#1c01ce}.chroma .s{color:#c41a16}.chroma .sa{color:#c41a16}.chroma .sb{color:#c41a16}.chroma .sc{color:#2300ce}.chroma .dl{color:#c41a16}.chroma .sd{color:#c41a16}.chroma .s2{color:#c41a16}.chroma .se{color:#c41a16}.chroma .sh{color:#c41a16}.chroma .si{color:#c41a16}.chroma .sx{color:#c41a16}.chroma .sr{color:#c41a16}.chroma .s1{color:#c41a16}.chroma .ss{color:#c41a16}.chroma .m{color:#1c01ce}.chroma .mb{color:#1c01ce}.chroma .mf{color:#1c01ce}.chroma .mh{color:#1c01ce}.chroma .mi{color:#1c01ce}.chroma .il{color:#1c01ce}.chroma .mo{color:#1c01ce}.chroma .o{color:#000}.chroma .ow{color:#000}.chroma .p{}.chroma .c{color:#177500}.chroma .ch{color:#177500}.chroma .cm{color:#177500}.chroma .c1{color:#177500}.chroma .cs{color:#177500}.chroma .cp{color:#633820}.chroma .cpf{color:#633820}.chroma .g{}.chroma .gd{}.chroma .ge{}.chroma .gr{}.chroma .gh{}.chroma .gi{}.chroma .go{}.chroma .gp{}.chroma .gs{}.chroma .gu{}.chroma .gt{}.chroma .gl{}.chroma .w{}}@media(prefers-color-scheme:dark){:root{--bright-text-color:#eee;--link-color:#8cc2dd;--link-visited-color:#b9a9e0;--background-color:#333;--text-color:#ddd;--faded-text-color:#aaa;--slightly-dimmer-text-color:#ccc;--blockquote-text-color:var(--slightly-dimmer-text-color);--faint-color:#666;color-scheme:dark}img.theme-affected{filter:invert(.8)}.chroma{color:#e2e4e5;background-color:#282a36}.chroma .x{}.chroma .err{color:#ff5c57}.chroma .lntd{vertical-align:top;padding:0;margin:0;border:0}.chroma .lntable{border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block}.chroma .hl{display:block;width:100%;background-color:#ffc}.chroma .lnt{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .ln{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .k{color:#ff6ac1}.chroma .kc{color:#ff6ac1}.chroma .kd{color:#ff5c57}.chroma .kn{color:#ff6ac1}.chroma .kp{color:#ff6ac1}.chroma .kr{color:#ff6ac1}.chroma .kt{color:#9aedfe}.chroma .n{}.chroma .na{color:#57c7ff}.chroma .nb{color:#ff5c57}.chroma .bp{}.chroma .nc{color:#f3f99d}.chroma .no{color:#ff9f43}.chroma .nd{color:#ff9f43}.chroma .ni{}.chroma .ne{}.chroma .nf{color:#57c7ff}.chroma .fm{}.chroma .nl{color:#ff5c57}.chroma .nn{}.chroma .nx{}.chroma .py{}.chroma .nt{color:#ff6ac1}.chroma .nv{color:#ff5c57}.chroma .vc{color:#ff5c57}.chroma .vg{color:#ff5c57}.chroma .vi{color:#ff5c57}.chroma .vm{}.chroma .l{}.chroma .ld{}.chroma .s{color:#5af78e}.chroma .sa{color:#5af78e}.chroma .sb{color:#5af78e}.chroma .sc{color:#5af78e}.chroma .dl{color:#5af78e}.chroma .sd{color:#5af78e}.chroma .s2{color:#5af78e}.chroma .se{color:#5af78e}.chroma .sh{color:#5af78e}.chroma .si{color:#5af78e}.chroma .sx{color:#5af78e}.chroma .sr{color:#5af78e}.chroma .s1{color:#5af78e}.chroma .ss{color:#5af78e}.chroma .m{color:#ff9f43}.chroma .mb{color:#ff9f43}.chroma .mf{color:#ff9f43}.chroma .mh{color:#ff9f43}.chroma .mi{color:#ff9f43}.chroma .il{color:#ff9f43}.chroma .mo{color:#ff9f43}.chroma .o{color:#ff6ac1}.chroma .ow{color:#ff6ac1}.chroma .p{}.chroma .c{color:#78787e}.chroma .ch{color:#78787e}.chroma .cm{color:#78787e}.chroma .c1{color:#78787e}.chroma .cs{color:#78787e}.chroma .cp{color:#78787e}.chroma .cpf{color:#78787e}.chroma .g{}.chroma .gd{color:#ff5c57}.chroma .ge{text-decoration:underline}.chroma .gr{color:#ff5c57}.chroma .gh{font-weight:700}.chroma .gi{font-weight:700}.chroma .go{color:#43454f}.chroma .gp{}.chroma .gs{font-style:italic}.chroma .gu{font-weight:700}.chroma .gt{}.chroma .gl{text-decoration:underline}.chroma .w{}}:root{--heading-font:ui-rounded, 'Hiragino Maru Gothic ProN', Quicksand, Comfortaa, Manjari, 'Arial Rounded MT', 'Arial Rounded MT Bold', Calibri, source-sans-pro, sans-serif;--text-font-size:17px;--text-font:system-ui, sans-serif}*{margin:0}body{}main{margin-top:.75em}sup{vertical-align:top;font-size:.7em}p{margin-bottom:1em}html{overflow-x:hidden;margin-right:calc(-1 * (100vw - 100%))}body{font-family:var(--text-font);font-size:var(--text-font-size);margin:auto;padding:20px;max-width:720px;text-align:left;background-color:var(--background-color);color:var(--text-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5}h1,h2,h3,h4,h5,h6{font-family:var(--heading-font);color:var(--bright-text-color);font-weight:400}.blog-content h1,.blog-content h2,.blog-content h3,.blog-content h4,.blog-content h5,.blog-content h6{margin-top:.5em}hr,ul,ol{margin-bottom:.5em}div>iframe{margin-bottom:.5em}.blog-timestamp{font-size:.9em}.blog-content{margin-top:1.5em}a{color:var(--link-color);text-decoration:none}.title{color:var(--text-color);font-size:1.5em;font-family:var(--heading-font);margin-right:10px}nav a{margin-right:8px;font-family:var(--heading-font)}.paper-item svg{width:16px;vertical-align:text-bottom}.menuactive{text-decoration:underline;text-decoration-thickness:2px}table{width:100%}img{max-width:100%;margin:auto;margin-bottom:.5em;display:block}code{padding:2px 5px;margin-bottom:1em;font-family:Fira Code,monospace;font-size:14px;line-height:1.4}pre code{display:block;padding:20px;white-space:pre-wrap;overflow-x:auto}pre{border-radius:10px}p code,ol code,ul code,summary code{border-radius:4px;border:solid var(--faint-color)1px;margin:0 2px;padding:1px 2px}blockquote{border-left:1px solid #999;color:var(--blockquote-text-color);padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.deemphasize{color:var(--faded-text-color)}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px;text-align:right;margin-right:20px}ul.blog-posts li a:visited{color:var(--link-visited-color)}</style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>const macros={};document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros})})</script></head><body><header><a href=/><span class=title>Darius Foo</span></a><nav style=display:inline-block><a href=/blog/>Blog</a>
<a href=/research/>Research</a>
<a href=/work/>Work</a>
<a href=/other/>Other</a></nav></header><main><h1>Verifying effectful higher-order programs with staged logic</h1><div><time class=blog-timestamp datetime=2024-08-16 pubdate>16 Aug, 2024</time></div><div class=blog-content><p><em>Text version of a talk given at the <a href=https://nus-plse.github.io/seminars.html>NUS PLSE Seminar</a> and <a href="https://www.fm24.polimi.it/?page_id=612">FM 2024</a> in Milan.</em></p><ul><li><a href=#effectful-higher-order-functions>Effectful higher-order functions</a></li><li><a href=#specifying-higher-order-functions-today>Specifying higher-order functions today</a><ul><li><a href=#example-1-mutating-the-list>Example 1: mutating the list</a></li><li><a href=#example-2-stronger-precondition>Example 2: stronger precondition</a></li><li><a href=#example-3-effects-outside-metalogic>Example 3: effects outside metalogic</a></li></ul></li><li><a href=#staged-logic>Staged logic</a><ul><li><a href=#effectful-placeholders>Effectful placeholders</a></li><li><a href=#recursion>Recursion</a></li><li><a href=#re-summarization>Re-summarization</a></li><li><a href=#compaction-via-biabduction>Compaction via biabduction</a></li></ul></li><li><a href=#solutions-to-the-problematic-examples>Solutions to the problematic examples</a><ul><li><a href=#example-1>Example 1</a></li><li><a href=#example-2>Example 2</a></li><li><a href=#example-3>Example 3</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul><h1 id=effectful-higher-order-functions>Effectful higher-order functions</h1><p>Programs written in mainstream languages today are rife with <em>effectful higher-order functions</em>:
functions which take other functions as arguments, where these arguments may use primitive side effects, such as state, exceptions, or algebraic effects.</p><p>In everyday programming, it is not unusual to do things like
use state in a closure to avoid traversing a list twice,
or use a continuation to return solutions when backtracking, and allow the continuation to throw an exception to end the search efficiently.
Using a modern I/O library makes effects pervasive.</p><p>Reasoning about such functions does not seem particularly difficult - we certainly do it informally every time we write such programs!
However, verifier support for such functions varies greatly:</p><ul><li><em>Most automated verifiers require function arguments to be pure</em>. Examples include Dafny, Why3, and Cameleer. This is because they lift these functions into the underlying logic (usually the first-order logic of SMT) and are restricted by what can be expressed in it.</li><li><em>Other automated verifiers rely on type system guarantees</em>. Examples include Prusti and Creusot, which target Rust and can exploit the fact that closures can maintain invariants over their captured state via ownership.</li><li><em>Other verifiers are interactive</em>. Examples include Iris, CFML, and Steel/Pulse (F*). In practice, this means that they support varying levels of automation, from none at all to full automation in specific cases, with the tradeoff being that they are more expressive.</li></ul><p>Even when higher-order functions are supported, they tend to be specified <em>imprecisely</em>. We'll see an example of this shortly.</p><p>The question we're concerned with in this work is: is there a <em>precise</em> and <em>general</em> way to support effectful higher-order functions in <em>automated</em> program verification?</p><h1 id=specifying-higher-order-functions-today>Specifying higher-order functions today</h1><p>$\gdef\m#1{\mathit{#1}}$</p><p>$\gdef\foldr{\m{foldr}}$
$\gdef\xs{\m{xs}}$
$\gdef\ys{\m{ys}}$
$\gdef\res{\m{res}}$
$\gdef\inv{\m{Inv}}$
$\gdef\islist{\m{isList}}$
$\gdef\list{\m{List}}$
$\gdef\emp{\m{emp}}$</p><p>$\gdef\req#1{\mathbf{req}\ #1}$
$\gdef\ens#1{\mathbf{ens}\ #1}$</p><p>We'll use the classic $\foldr$ function as a running example.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>foldr</span> <span class=n>f</span> <span class=n>a</span> <span class=n>l</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>match</span> <span class=n>l</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span> <span class=o>=&gt;</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>h</span> <span class=o>::</span> <span class=n>t</span> <span class=o>=&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span> <span class=n>h</span> <span class=o>(</span><span class=n>foldr</span> <span class=n>f</span> <span class=n>a</span> <span class=n>t</span><span class=o>)</span>
</span></span></code></pre></div><p>$f$ is <em>effectful</em> - it may have state, exceptions, or algebraic effects.
$\foldr$ is hence an <em>effectful higher-order function</em>.</p><p>How can we specify $\foldr$ in a way that allows the following client to be verified?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>count</span> <span class=o>=</span> <span class=n>ref</span> <span class=n>0</span> <span class=k>in</span>
</span></span><span class=line><span class=cl><span class=n>foldr</span> <span class=o>(</span><span class=k>fun</span> <span class=n>c</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>incr</span> <span class=n>count</span><span class=o>;</span> <span class=n>c</span> <span class=o>+</span> <span class=n>t</span><span class=o>)</span> <span class=n>0</span> <span class=n>xs</span>
</span></span></code></pre></div><p><a href=https://iris-project.org/tutorial-pdfs/lecture6-foldr.pdf>The conventional way to do it in a modern program logic, like Iris</a>, is as follows.</p>$$
\forall P, \inv, f, \xs, l. \left\{ \begin{array}{l}
(\forall x, a', \ys.\ \{P\ x * \inv\ \ys\ a'\}\ f(x, a')\ \{r.\ \inv\ (x::\ys)\ r\}) \\
*\ \islist\ l\ \xs * \m{all}\ P\ \xs * \inv\ []\ a
\end{array} \right\} \\
\foldr\ f\ a\ l \\
\{r.\ \islist\ l\ \xs * \inv\ \xs\ r \}
$$<ol><li>A nested triple is used to specify $f$, as some knowledge of it is needed to reason about the call to it in $\foldr$.</li><li>The specification of $\foldr$ is parameterized over an <em>invariant</em> or <em>abstract property</em> $\inv$, which relates the content of the input list $\xs$ with the result of the fold. Its purpose is to <em>summarize</em> what $\foldr$ does.</li><li>As $f$ is called within $\foldr$ and its result contributes to that of $\foldr$, it must preserve the invariant - assuming the invariant holds of the tail $t$ and the result of the recursive call $a'$, $f$ must reestablish it for $l$ and its result $r$. The invariant also serves as a means of summarizing the behavior of $f$.</li><li>Anticipating that some clients may want to operate only on certain kinds of lists, the specification is further parameterized over a unary predicate $P$. A precondition $\m{all}\ P\ \xs$, which must be proved at each call site, allows $f$ to then rely on $P\ x$ in its precondition.</li><li>A <em>shape predicate</em> $\islist$ relating the structure $l$ to its content $\xs$ appears in both pre- and postcondition. This is to say that $\foldr$ should not change the list.</li></ol><p>This specification elegantly solves the problem, but we argue that it is <em>imprecise</em>.
In particular, while it may be used to verify the client we provided earlier (using a separation logic invariant to relate the value of $\m{count}$ and $t$, and an identity $P$), there are many clients that <em>cannot be verified</em> using it <em>without significant changes</em>.</p><p>The <a href=https://iris-project.org/tutorial-pdfs/iris-lecture-notes.pdf>Iris tutorial</a> says as much (pg 35):</p><blockquote><p>Different clients may instantiate foldr with some very different functions, hence it can be hard to give a specification for f that is reasonable and general enough to support all these choices.</p></blockquote><p>The problem is that due to the use of abstract properties, this specification <em>commits prematurely</em> to a <em>summary</em> or <em>abstraction</em> of $f$'s behavior.
Due to the undue strengthening of the precondition of $\foldr$, <em>precision</em> is lost.
This leads to the symptom that the abstraction may not be precise enough for a given client.</p><p>We'll look at three examples of such clients.</p><h2 id=example-1-mutating-the-list>Example 1: mutating the list</h2><p>Suppose we allowed $f$ to mutate the list.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>foldr_ex1</span> <span class=n>l</span> <span class=o>=</span> <span class=n>foldr</span> <span class=o>(</span><span class=k>fun</span> <span class=n>x</span> <span class=n>r</span> <span class=o>-&gt;</span> <span class=k>let</span> <span class=n>v</span> <span class=o>=</span> <span class=o>!</span><span class=n>x</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>                                    <span class=n>x</span> <span class=o>:=</span> <span class=n>v</span><span class=o>+</span><span class=n>1</span><span class=o>;</span> <span class=n>v</span><span class=o>+</span><span class=n>r</span><span class=o>)</span> <span class=n>l</span> <span class=n>0</span>
</span></span></code></pre></div><p>This is not allowed by the shape predicate in the postcondition, but suppose we changed it to $\islist\ l\ \xs'$.</p><p>Now the problem is that $\inv\ \xs\ r$ tells us nothing about $\xs'$.
We would have to add $\xs'$ as a parameter at least, and the client would have to relate it to $x$.</p><p>While this results in a more general specification, it is also cluttered with more anticipated client use cases.
The problem is really that the use of invariants requires us to <em>commit to a parameterization</em>.</p><h2 id=example-2-stronger-precondition>Example 2: stronger precondition</h2><p>Suppose we would like to pass a function argument which relies on a property concerning intermediate folded results.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>foldr_ex2</span> <span class=n>l</span> <span class=o>=</span> <span class=n>foldr</span> <span class=o>(</span><span class=k>fun</span> <span class=n>x</span> <span class=n>r</span> <span class=o>-&gt;</span> <span class=k>assert</span><span class=o>(</span><span class=n>x</span><span class=o>+</span><span class=n>r</span><span class=o>&gt;=</span><span class=n>0</span><span class=o>);</span> <span class=n>x</span><span class=o>+</span><span class=n>r</span><span class=o>)</span> <span class=n>l</span> <span class=n>0</span>
</span></span></code></pre></div><p>Again, because we committed to a parameterization,
we can't use $P$ to strengthen the precondition of $f$,
as $P$ only constrains individual elements and cannot be used to talk about the suffixes of the list.</p><h2 id=example-3-effects-outside-metalogic>Example 3: effects outside metalogic</h2><p>This example illustrates a different problem with invariants: suppose we allowed the function to throw an exception.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>foldr_ex3</span> <span class=n>l</span> <span class=o>=</span> <span class=n>foldr</span> <span class=o>(</span><span class=k>fun</span> <span class=n>x</span> <span class=n>r</span> <span class=o>-&gt;</span> <span class=k>if</span> <span class=n>x</span><span class=o>&gt;=</span><span class=n>0</span> <span class=k>then</span> <span class=n>x</span><span class=o>+</span><span class=n>r</span>
</span></span><span class=line><span class=cl>                                    <span class=k>else</span> <span class=k>raise</span> <span class=nc>Exc</span><span class=bp>()</span><span class=o>)</span> <span class=n>l</span> <span class=n>0</span>
</span></span></code></pre></div><p>When we use an invariant to summarize the behavior of $\foldr$ or $f$,
we are really trying to abstract their behavior into a predicate of the underlying logic.
The behavior we can describe is now limited by the expressiveness of that logic.</p><p>For example, as mentioned earlier, many verifiers do not handle closures because they lift function arguments into the pure, first-order logic of SMT.</p><p>Here, separation logic allows state, but says nothing about exceptions/effects, as $f$ must return a value to preserve the invariant.
One would need some kind of encoding or <a href=https://devilhena-paulo.github.io/thesis/de-vilhena-thesis.pdf>protocol</a>, a fundamentally different specification.</p><h1 id=staged-logic>Staged logic</h1><p>Taking a step back, why did we have to abstract away the behavior of $f$ to begin with?</p><p>The problem was that it was difficult to represent (1) unknown higher-order effectful calls and (2) ordering of effects precisely in pre/post specifications.</p><p>Our idea is thus to generalize triples with those ingredients.
We extend the "language" of triples (where $\mathbf{req}$ and $\mathbf{ens}$ are viewed as atomic predicates) with two contructs: sequencing and (un)interpreted relations.
We call $\varphi$ a <em>staged formula</em>, for reasons that will be explained shortly.
$\sigma{\wedge}\pi$ is a symbolic-heap separation logic formula.</p>$$\varphi ::= \req{\sigma{\wedge}\pi} \mid \ens{\sigma{\wedge}\pi} \mid \varphi; \varphi \mid f(x, r) \mid \exists x.\ \varphi \mid \varphi \vee \varphi$$<p>What is the semantics of such formulae? We defer this question to <a href=https://raw.githubusercontent.com/hipsleek/Heifer/StagedSL/docs/FM2024_TR.pdf>our paper</a>, but a first approximation is the following generalization, starting from the (partial correctness) semantics of Hoare triples.</p>$$
\begin{align*}
\{ P \}\ e\ \{ Q \} \equiv & \ \forall s, s'. \langle s, e \rangle ⟶ \langle s', v \rangle \wedge P\ s \Rightarrow Q\ v\ s' \\
\{ \ens{\m{emp}} \}\ e\ \{ \varphi \} \equiv & \ \forall s, s'. \langle s, e \rangle ⟶ \langle s', v \rangle \Rightarrow \langle s \rightsquigarrow s', v \rangle \vDash \varphi
\end{align*}
$$<p>Where we previously had a precondition constraining $s$ and a postcondition constraining $s'$ and the result $v$, we now have a staged formula constraining the same three things.</p><p>The ingredients of our solution consist of the following.</p><ol><li>Sequencing and uninterpreted relations</li><li>Recursive formulae</li><li>Re-summarization of recursion (lemmas)</li><li>Compact sequences of pre/post stages using biabduction</li></ol><p>The insight is that these allow us to <em>defer abstraction</em> until appropriate.</p><p>We go over each in turn using examples, then present solutions to the examples.</p><h2 id=effectful-placeholders>Effectful placeholders</h2><p>Consider the following program, which manipulates the heap and has a call to an unknown function $f$.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>hello</span> <span class=n>f</span> <span class=n>x</span> <span class=n>y</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=n>x</span> <span class=o>:=</span> <span class=o>!</span><span class=n>x</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>r</span> <span class=o>=</span> <span class=n>f</span> <span class=n>y</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>r2</span> <span class=o>=</span> <span class=o>!</span><span class=n>x</span> <span class=o>+</span> <span class=n>r</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=n>y</span> <span class=o>:=</span> <span class=n>r2</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>r2</span>
</span></span></code></pre></div><p>Here is a possible <em>staged specification</em> for it.</p>$$
\begin{array}{l}
\m{hello}(f, x, y, res) = \\
\quad \exists a.\ \req{x{\mapsto}a}; \ens{x{\mapsto}a{+}1} \\
\quad \exists r.\ f(y, r); \\
\quad \exists b.\ \req{x{\mapsto}b * y{\mapsto}\_}; \\
\quad \phantom{\exists b.\ } \ens{x{\mapsto}b * y{\mapsto}\m{res}{\wedge}\m{res}{=}b{+}r} \\
\end{array}
$$<ul><li>Uninterpreted relations allow us to represent unknown function parameters.</li><li>Sequencing allows them to serve as <em>placeholders</em> for effects.</li><li>Stateful behavior is otherwise <em>compacted</em> into a single $\textbf{req}$/$\textbf{ens}$ pair $f$ may be seen as <em>stratifying</em> the behavior of $\m{hello}$ into two <em>stages</em> under <a href=#compaction-via-biabduction>compaction</a>, hence the name "staged formulae", in allusion to <em>staged programming</em>.</li><li>Note that we can no longer assume anything about $y$ after the call to $f$, as it is passed as an argument.</li><li>We also cannot assume anything about $x$ after the call to $f$! It is possible that $x$ may have been captured by $f$. Thus it may have a potentially different value after, $b$.</li><li>This specification assumes that $x$ and $y$ are not aliased. Details on how to relax this assumption in the paper.</li></ul><p>Sequencing of multiple effectful functions can be represented directly.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>compose</span> <span class=n>f</span> <span class=n>g</span> <span class=n>x</span> <span class=o>=</span> <span class=n>f</span> <span class=o>(</span><span class=n>g</span> <span class=n>x</span><span class=o>)</span>
</span></span></code></pre></div>$$
\m{compose}(f, g, x, \m{res}) = \exists r.\ g(x, r); f(r, \m{res})
$$<h2 id=recursion>Recursion</h2><p>Recursive specifications naturally represent recursive programs.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>foldr</span> <span class=n>f</span> <span class=n>a</span> <span class=n>l</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>match</span> <span class=n>l</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span> <span class=o>=&gt;</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>h</span> <span class=o>::</span> <span class=n>t</span> <span class=o>=&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span> <span class=n>h</span> <span class=o>(</span><span class=n>foldr</span> <span class=n>f</span> <span class=n>a</span> <span class=n>t</span><span class=o>)</span>
</span></span></code></pre></div>$$
\begin{array}{l}
\foldr(f, a, l, \m{res}) = \\
\quad \phantom{\vee\ } \ens{l{=}[]{\wedge}\m{res}{=}a} \\
\quad \vee\ \exists r, l_1.\ \ens{l{=}x{::}l_1}; \foldr(f, a, l_1, r); f(x, r, \m{res})
\end{array}
$$<p>Most importantly, the call to $f$ can be represented directly, without abstraction.</p><p>This specification looks very much like the program, because there is no state that could benefit from being expressed with separation logic.
However, it is still an abstraction of the program.</p><p>Comparing this to the previous specification, this time expressed as a single $\mathbf{req}$/$\mathbf{ens}$ pair in staged logic,</p>$$
\begin{array}{l}
\foldr(f, a, l, \m{res}) = \\
\quad \exists P, \inv, \xs.\ \req{\m{List(l, \xs)} * \inv([], a) \wedge \m{all}(P, \xs)} \\
\qquad \wedge f(x, a', r) \sqsubseteq (\exists ys.\ \req{\inv(\ys, a') \wedge P(x)}; \ens{\inv(x{::}\ys, r)}); \\
\quad \ens{\m{List}(l, \xs) * \inv(\xs, \m{res})}
\end{array}
$$<p>we see that leaving the recursion in the specification <em>before</em> we are aware of what clients expect (and thus, what kind of abstraction is appropriate) is what allows staged specifications to be more precise.</p><h2 id=re-summarization>Re-summarization</h2><p>What kind of properties can we use staged logic to prove, and how do we do it?</p><p>First, we add a <em>subsumption</em> relation, which is true if a staged formula entails another staged formula.</p>$$\pi ::= ... \mid \varphi \sqsubseteq \varphi$$<p>Given a use of $\foldr$ such as the following,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>foldr_sum</span> <span class=n>xs</span> <span class=n>init</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>g</span> <span class=n>c</span> <span class=n>t</span> <span class=o>=</span> <span class=n>c</span> <span class=o>+</span> <span class=n>t</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=n>foldr</span> <span class=n>g</span> <span class=n>xs</span> <span class=n>init</span>
</span></span></code></pre></div><p>We might wish to prove a functional correctness property, such as the fact that $\m{foldr\_sum}$ computes the sum of $\xs$ plus $\m{init}$.</p><p>This can be stated as follows:</p>$$
\forall \xs, \m{init}, \res.\ \m{foldr\_sum}(\xs, \m{init}, \res) \sqsubseteq \exists r.\ \ens{\res{=}r{+}\m{init}{\wedge}\m{sum}(\xs,r)}
$$<p>where $\m{foldr\_sum}$ is a staged formula representing the above program (derived from the program automatically in a syntax-directed manner), and $\m{sum}$ is a recursive pure function.</p>$$
\begin{array}{l}
\m{sum}(\xs,\res) = \\
\phantom{\vee\ } (xs{=}[]{\wedge}\res{=}0) \\
\vee\ (\exists x, l_1, r.\ l=x{::}l_1 \wedge \m{sum}(l_1, r)\wedge \res{=}x{+}r)
\end{array}
$$<p>In the paper, we define a set of syntactic proof rules for reducing $\sqsubseteq$-entailments (modulo compaction) into pure proof obligations,
which can be discharged using SMT.
This particular proof can be done automatically with an inferred (or provided, in general) induction hypothesis.</p><p>The above entailment can be seen as a lemma in staged logic.
We also call this <em>re-summarization</em> because
it is at this point that we abstract away the recursion from the relatively low-level staged specification,
and produce a non-recursive summary.</p><p>What do we gain from using staged logic here, one might ask, since $\m{foldr_sum}$ is pure, and the proof can also be done automatically in a verifier like Dafny, with its heuristics for synthesizing induction hypotheses?</p><p>What we gain is that we can handle effectful higher-order functions. Consider the following variation of $\m{foldr\_sum}$, which uses a closure.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>foldr_sum_state</span> <span class=n>x</span> <span class=n>xs</span> <span class=n>init</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>g</span> <span class=n>c</span> <span class=n>t</span> <span class=o>=</span> <span class=n>x</span> <span class=o>:=</span> <span class=n>x</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span> <span class=n>c</span> <span class=o>+</span> <span class=n>t</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=n>foldr</span> <span class=n>g</span> <span class=n>xs</span> <span class=n>init</span>
</span></span></code></pre></div><p>The proof of the following entailment can also be done automatically, in a very similar manner,
because of how staged logic can naturally express sequencing of effects.</p>$$
\begin{array}{rl}
& \forall \xs, \m{init}, \res.\ \m{foldr\_sum\_state}(x, \xs, \m{init}, \res) \\
\sqsubseteq & \exists i,r.\ \req{x{\mapsto}i}; \ens{x{\mapsto}i{+}r{\wedge}\res{=}r{+}\m{init}{\wedge}\m{sum}(\xs,r)}
\end{array}
$$<h2 id=compaction-via-biabduction>Compaction via biabduction</h2><p><em>Compaction</em> allows us to have the expressiveness of stages, but also the <em>succinctness</em> of triples when the extra expressiveness is not needed.
In short, it allows any staged formula to always be transformed into the following normal form.</p>$$
\big(\req{\sigma{\wedge}\pi}; \ens{\sigma{\wedge}\pi}; f(x, r); \big)^* \req{\sigma{\wedge}\pi}; \ens{\sigma{\wedge}\pi}
$$<p>We'll illustrate it by example on the first example we saw.</p>$$
\begin{array}{l}
\m{hello}(f, x, y, res) = \\
\quad \exists a.\ \req{x{\mapsto}a}; \ens{x{\mapsto}a{+}1} \\
\quad \exists r.\ f(y, r); \\
\quad \exists b.\ \req{x{\mapsto}b * y{\mapsto}\_}; \\
\quad \phantom{\exists b.\ } \ens{x{\mapsto}b * y{\mapsto}\m{res}{\wedge}\m{res}{=}b{+}r} \\
\end{array}
$$<p>This specification is already in normal form, but suppose we find out an interpretation for $f$, for example, from the following client.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>z</span> <span class=o>=</span> <span class=n>ref</span> <span class=n>0</span> <span class=k>in</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>y</span> <span class=o>=</span> <span class=n>ref</span> <span class=n>1</span> <span class=k>in</span>
</span></span><span class=line><span class=cl><span class=n>hello</span> <span class=o>(</span><span class=k>fun</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=n>incr</span> <span class=n>z</span><span class=o>;</span> <span class=n>0</span><span class=o>)</span> <span class=n>z</span> <span class=n>y</span>
</span></span></code></pre></div><p>Now we have the following interpretation for $f$.</p>$$f(\_,\res) = \exists c.\ \req{z{\mapsto}c}; \ens{z{\mapsto}c{\wedge}\res{=}0}$$<p>Unfolding $f$ in $\m{hello}$ (and doing some renaming),</p>$$
\begin{array}{l}
\m{hello}(f, z, y, res) = \\
\quad \exists a.\ \req{z{\mapsto}a}; \boxed{\ens{z{\mapsto}a{+}1}} \\
\quad \exists r,c.\ \boxed{\req{z{\mapsto}c}}; \ens{z{\mapsto}c{\wedge}r{=}0} \\
\quad \exists b.\ \req{z{\mapsto}b * y{\mapsto}\_}; \\
\quad \phantom{\exists b.\ } \ens{z{\mapsto}b * y{\mapsto}\m{res}{\wedge}\m{res}{=}b{+}r} \\
\end{array}
$$<p>This specification is not in normal form.
Focusing on the boxed portions, we see an $\mathbf{ens}$ followed by a $\mathbf{req}$.
We can apply the following normalization rule.</p>$$
\frac{D_A * D_1 \vdash D_2 * D_F}{\ens{D_1};\req{D_2} \Rightarrow \req{D_A}; \ens{D_F}}
$$<p>In other words, it suffices to solve a <a href=https://fbinfer.com/docs/separation-logic-and-bi-abduction/>biabductive entailment</a> to infer a pair of <em>frame</em> (in the separation logic sense) and <em>antiframe</em> (an additional condition $D_A$ required for $D_1$ to entail $D_2$).
We can then use these in place of the original conditions, "swapping" them around, or "pushing" the $\mathbf{req}$ "through" the $\mathbf{ens}$.</p><p>For this example, one solution is:</p>$$
z{\mapsto}a{+}1 * (a{+}1{=}c) \vdash z{\mapsto}c * \emp
$$<p>We can thus transform $\m{hello}$ as follow.</p>$$
\begin{array}{l}
\m{hello}(f, z, y, res) = \\
\quad \exists a.\ \boxed{\req{z{\mapsto}a}; \exists c.\ \req{a{+}1{=}c}} \\
\quad \exists r.\ \boxed{\ens{\emp}; \ens{z{\mapsto}c{\wedge}r{=}0}} \\
\quad \exists b.\ \req{z{\mapsto}b * y{\mapsto}\_}; \\
\quad \phantom{\exists b.\ } \ens{z{\mapsto}b * y{\mapsto}\m{res}{\wedge}\m{res}{=}b{+}r} \\
\end{array}
$$<p>Now we have two consecutive $\mathbf{req}$ and $\mathbf{ens}$ stages.
We can normalize them using the following rules.</p>$$
\req{D_1}; \req{D_2} \Rightarrow \req{(D_1 * D_2)} \\
\ens{D_1}; \ens{D_2} \Rightarrow \ens{(D_1 * D_2)}
$$<p>Now we have this, and again we have another $\mathbf{ens}$/$\mathbf{req}$ pair.</p>$$
\begin{array}{l}
\m{hello}(f, z, y, res) = \\
\quad \exists a,c.\ \req{z{\mapsto}a * a{+}1{=}c}; \\
\quad \exists r.\ \boxed{\ens{z{\mapsto}c{\wedge}r{=}0}} \\
\quad \exists b.\ \boxed{\req{z{\mapsto}b * y{\mapsto}\_}}; \\
\quad \phantom{\exists b.\ } \ens{z{\mapsto}b * y{\mapsto}\m{res}{\wedge}\m{res}{=}b{+}r} \\
\end{array}
$$<p>Here's the solution...</p>$$
z{\mapsto}c{+}1{\wedge}r{=}0 * (c{+}1{=}b{\wedge}y{\mapsto}\_) \vdash z{\mapsto}b * y{\mapsto}\_ * r{=}0
$$<p>... and final state, after one more round of simplification (not shown).</p>$$
\begin{array}{l}
\m{hello}(f, z, y, res) = \\
\quad \exists a,c.\ \req{z{\mapsto}a * y{\mapsto}\_ \wedge a{+}1{=}c{\wedge}c{+}1{=}b}; \\
\quad \exists b.\ \ens{z{\mapsto}b * y{\mapsto}\m{res}{\wedge}\m{res}{=}b}
\end{array}
$$<p>Now the specification for this call to $\m{hello}$ is in normal form, and we can use it for subsequent reasoning.
We see also that it precisely summarizes the aggregate behavior of this call, including the state changes.</p><p>Compaction can be seen as a normalization procedure for (programs represented as) staged formulae,
but also as a means of exploiting the <em>specification inference</em> capabilities of biabduction in a verification setting, to automate derivation of specifications and allow the user to focus only on the nontrivial ones.</p><h1 id=solutions-to-the-problematic-examples>Solutions to the problematic examples</h1><p>Going back to the examples we highlighted previously,
how can we tackle them using staged logic,
and how does the approach differ from the invariant-based way of writing specifications given in the introduction?</p><p>All the following assume the specification for $\foldr$ is as given in the previous section.
Crucially, none have to change it to solve all problems.</p><h2 id=example-1>Example 1</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>foldr_ex1</span> <span class=n>l</span> <span class=o>=</span> <span class=n>foldr</span> <span class=o>(</span><span class=k>fun</span> <span class=n>x</span> <span class=n>r</span> <span class=o>-&gt;</span> <span class=k>let</span> <span class=n>v</span> <span class=o>=</span> <span class=o>!</span><span class=n>x</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>                                    <span class=n>x</span> <span class=o>:=</span> <span class=n>v</span><span class=o>+</span><span class=n>1</span><span class=o>;</span> <span class=n>v</span><span class=o>+</span><span class=n>r</span><span class=o>)</span> <span class=n>l</span> <span class=n>0</span>
</span></span></code></pre></div><p>An invariant to tell us about the content of the list is not needed.
Instead, we describe the final content of the list using another pure, recursive function (mapinc), alongside the result.
The list is described using a shape predicate.</p>$$
\begin{array}{l}
\m{mapinc}(\xs, \ys) = \\
\quad \phantom{\vee\ } (\xs{=}[]{\wedge}\ys) \\
\quad \vee\ (\exists x, \xs_1, \ys.\ \xs{=}x{::}\xs_1{\wedge}\ys{=}(x{+}1){::}\ys_1) \wedge \m{mapinc}(\xs_1, \ys_1) \\ \\
\list(l, \m{rs}) = \\
\quad \phantom{\vee\ } (\emp{\wedge}l{=}[]) \\
\quad \vee\ (\exists x, \m{rs}_1, l_1.\ x{\mapsto}r * \list(l_1,\m{rs}_1){\wedge}l{=}x{::}l_1 {\wedge} \m{rs}{=}r{::}\m{rs}_1)
\end{array}
$$<p>We can then prove</p>$$
\begin{array}{rl}
& \m{foldr\_ex1}(l,\res) \\
\sqsubseteq & \exists \xs, \ys.\ \req{\list(l,\xs)}; \ens{\list(l,\ys){\wedge}\m{mapinc}(\xs, \ys){\wedge}\m{sum}(\xs, \res)}
\end{array}
$$<h2 id=example-2>Example 2</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>foldr_ex2</span> <span class=n>l</span> <span class=o>=</span> <span class=n>foldr</span> <span class=o>(</span><span class=k>fun</span> <span class=n>x</span> <span class=n>r</span> <span class=o>-&gt;</span> <span class=k>assert</span><span class=o>(</span><span class=n>x</span><span class=o>+</span><span class=n>r</span><span class=o>&gt;=</span><span class=n>0</span><span class=o>);</span> <span class=n>x</span><span class=o>+</span><span class=n>r</span><span class=o>)</span> <span class=n>l</span> <span class=n>0</span>
</span></span></code></pre></div><p>To enable the assertion in the function argument to be proved, we explicate the assumption that all suffix-sums of the list are positive using the following pure function.</p>$$
\begin{array}{l}
\m{allSPos}(l) = \\
\phantom{\vee\ } (l{=}[]) \\
\vee\ (\exists x, r, l_1.\ l=x{::}l_1 \wedge \m{allSPos}(l_1)\wedge \m{sum}(l,r) \wedge r{\geq}0)
\end{array}
$$<p>We can then prove</p>$$
\m{foldr\_ex2}(l,\res) \sqsubseteq \req{\m{allSPos}(l)}; \ens{\m{sum}(l,\res)}
$$<h2 id=example-3>Example 3</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>foldr_ex3</span> <span class=n>l</span> <span class=o>=</span> <span class=n>foldr</span> <span class=o>(</span><span class=k>fun</span> <span class=n>x</span> <span class=n>r</span> <span class=o>-&gt;</span> <span class=k>if</span> <span class=n>x</span><span class=o>&gt;=</span><span class=n>0</span> <span class=k>then</span> <span class=n>x</span><span class=o>+</span><span class=n>r</span>
</span></span><span class=line><span class=cl>                                    <span class=k>else</span> <span class=k>raise</span> <span class=nc>Exc</span><span class=bp>()</span><span class=o>)</span> <span class=n>l</span> <span class=n>0</span>
</span></span></code></pre></div><p>An exception can be modelled as an <em>interpreted</em> relation (more on the semantics of handlers in our ICFP 2024 paper).</p><p>Given a pure function to describe lists containing only positive elements,</p>$$
\begin{array}{l}
\m{allPos}(l) = \\
\phantom{\vee\ } (l{=}[]) \\
\vee\ (\exists x, l_1.\ l=x{::}l_1 \wedge \m{allPos}(l_1)\wedge r{\geq}0)
\end{array}
$$<p>we can give a precise description of the conditions under which an exception is thrown via the following entailment.</p>$$
\m{foldr\_ex3}(l,\res) \sqsubseteq \ens{\m{allPos}(l){\wedge}\m{sum}(l,\res) \vee \ens{\neg\m{allPos}(l)}; \m{Exc}()}
$$<p>We could go even further and describe the prefix of elements which must be positive, if the exception carried that information to its handler.</p><p>The underlying logic is still symbolic-heap separation logic; we do not delegate effects to it,
yet can describe programs performing arbitrary (algebraic) effects.</p><h1 id=conclusion>Conclusion</h1><p>We have described <em>staged logic</em>, a generalization of Hoare triples that is particularly effective at specifying effectful higher-order programs.
It forms the basis of a new verification methodology based on the following ideas.</p><ol><li>Sequencing and uninterpreted relations</li><li>Recursive formulae</li><li>Re-summarization of recursion (lemmas)</li><li>Compact sequences of pre/post stages using biabduction</li></ol><p>All the ingredients together enable a strongest-postcondition-like workflow where,
given a program and an entailment about a property it should satisfy,
a staged formula is derived from the program, and the entailment is automatically proved.</p><p>Since staged logic generalizes Hoare logic,
one can easily "fall back" to triples in cases where the increased expressiveness of stages is not needed,
and employ abstraction, invariants, and all the other techniques which have been developed for program proofs.
There is no need to always specify programs as disjunctions of paths, or always capture the ordering of every function call and effect,
however the crucial thing is that <em>the option to do so is available</em> where it makes specifications for certain kinds of programs more natural.</p><p>Check out <a href=https://raw.githubusercontent.com/hipsleek/Heifer/StagedSL/docs/FM2024_TR.pdf>the paper</a> for the details.</p><p>These ideas have been implemented in a prototype verifier called <a href=https://github.com/hipsleek/heifer>Heifer</a>, which we hope will grow into a practical verification tool for real programs.</p></div><p></p></main><footer></footer></body></html>