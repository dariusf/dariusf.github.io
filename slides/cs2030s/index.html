<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>CS2030S</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@4.1.0//dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@4.1.0//dist/reveal.css">
  <style>
      </style>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@4.1.0//dist/theme/simple.css" id="theme">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@4.1.0//plugin/highlight/monokai.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/highlight.js/src/styles/github.css">
  <style>
  .slides section { text-align: left; }

  /* slide titles */
  .slides section h1 { font-weight: bold; }
  .slides section h2 { font-weight: bold; }
  .slides section h3 { font-weight: bold; }

  /* title */
  /* slightly smaller for long titles */
  .slides section h1 { font-size: 2em; }

  /*.slides section p { font-size: 0.8em; }*/
  /*.slides section li { font-size: 0.8em; }*/

  /* reveal defines top and bottom margins */
  .center {
    margin-left: auto !important;
    margin-right: auto !important;
    display: block;
  }

  .credit {
    float: right;
    font-size: 0.7em;
  }

  .right {
    text-align: right;
  }

  .small {
    font-size: 0.5em;
  }

  .wrap {
    /* wrap so long lines in code aren't cut off */
    white-space: pre-wrap;
  }

  .reveal code {
    font-family: "Liga Inconsolata", monospace;
    font-size: 1.1em;

    /*font-family: "Fira Code", monospace;*/
  }
  </style>
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">CS2030S</h1>
</section>

<section id="contents" class="slide level1">
<h1>Contents</h1>
<ol type="1">
<li><a href="#/recitation-1">Week 3</a>: OOP, the heap and stack</li>
<li><a href="#/recitation-2-week-4">Week 4</a>: overloading and overriding</li>
<li><a href="#/recitation-3-week-5">Week 5</a>: generics and variance</li>
<li><a href="#/recitation-4-week-6">Week 6</a>: wildcards</li>
<li><a href="#/recitation-5-week-7">Week 7</a>: midterm</li>
<li><a href="#/recitation-6-week-8">Week 8</a>: anonymous and nested classes</li>
<li><a href="#/recitation-7-week-9">Week 9</a>: FP and trampolines</li>
<li><a href="#/recitation-8-week-10">Week 10</a>: streams</li>
<li><a href="#/recitation-9-week-11">Week 11</a>: monads and parallel streams</li>
<li><a href="#/recitation-10-week-12">Week 12</a>: asynchrony</li>
</ol>
</section>
<section id="recitation-1" class="slide level1">
<h1>Recitation 1</h1>
</section>
<section id="welcome" class="slide level1">
<h1>Welcome!</h1>
<p>Darius Foo</p>
<p><a href="mailto:dariusf@comp.nus.edu.sg" class="email">dariusf@comp.nus.edu.sg</a></p>
<p>Office hours: 11am to 12pm, Thursdays, AS3-06-09</p>
</section>
<section id="recap" class="slide level1">
<h1>Recap</h1>
<style>
    blockquote {
      display: inline;
    } 
     
    details {
      display: inline;
    }

    summary {
      display: inline;
    }

    details[open] summary {
      display: none;
    }

    details summary::-webkit-details-marker {
      display:none;
    }

    .blue {
        color: blue;
    }
    /*
    https://stackoverflow.com/questions/41922483/how-to-insert-details-in-one-line-with-a-sentence

    https://stackoverflow.com/questions/6195329/how-can-you-hide-the-arrow-that-is-displayed-by-default-on-the-html5-details-e
    */
</style>
<p>Object-oriented programming?</p>
<ul>
<li><details>
<summary>
Encapsulation
</summary>
Encapsulation: <span class="blue">program + data</span>
</details>
<ul>
<li><details>
<summary>
Information hiding
</summary>
Information hiding: <span class="blue">private implementation</span>
</details></li>
<li><details>
<summary>
Tell, don’t ask
</summary>
Tell, don’t ask: <span class="blue">operations on objects</span>
</details></li>
</ul></li>
<li><details>
<summary>
Composition
</summary>
Composition: <span class="blue"><em>has-a</em></span>
</details></li>
<li><details>
<summary>
Inheritance
</summary>
Inheritance: <span class="blue"><em>is-a</em>/more <em>specific</em></span>
</details>
<ul>
<li><details>
<summary>
Polymorphism
</summary>
Polymorphism: <span class="blue">children differ/dynamic dispatch</span>
</details></li>
<li><details>
<summary>
Overriding
</summary>
Overriding: <span class="blue">re(de)fine parent behaviour</span>
</details></li>
<li><details>
<summary>
LSP
</summary>
LSP: <span class="blue">what <em>specific</em> means</span>
</details></li>
<li><details>
<summary>
Abstract class/interface
</summary>
Abstract class/interface: <span class="blue">let children fill in</span>
</details></li>
</ul></li>
</ul>
<!-- - Encapsulation
    + Information hiding
    + Tell, don't ask
- Composition (has-a)
- Inheritance (is-a)
    + Polymorphism
    + Overriding
    + LSP
    + Abstract class/interface
-->
<!--
Mindmap

record
attendance

what is oop? no right answer. the idea that programs and data should be packaged into units (classes), and these should be the building block. paradigm, way of doing things, and you should contrast this with fp

what is the difference between an object and a class? a class is a stencil, an object is a drawing. blueprint

- encapsulation: program + data
- information hiding: 
- tell don't ask. rather than expose data like in fp, define operations on object. contrast with pair object from fp. is there a clear winner?
- composition: idea that an object contains other objects. car has wheels, could also have car inherit from wheel but that would be weird. wheeled object, maybe
- inheritance: idea that an object can be made more specific. concrete example
- polymorphism: subclasses can implement methods in different ways. animal, call, vocalise, bark, meow. depending on the runtime type of the object
- overriding: subclasses can redefine parent behaviour
- lsp: sanity check for is-a relationship, what more specific means, any property of the parent must apply to the child, so wherever the parent is accepted, the child must be too. child cannot violate. use concrete example, like animal, dog
- abstract class: things high in the hierarchy can have holes. polymorphism lets us fill these in

-->
</section>
<section id="today" class="slide level1">
<h1>Today</h1>
<ol type="1">
<li>Encapsulation</li>
<li><strong>Evaluation in Java</strong></li>
<li>More practice</li>
</ol>
<!--
process model and allocation
stack stores primitives

the constructor also matters
-->
</section>
<section id="the-stack-and-heap" class="slide level1">
<h1>The stack and heap</h1>
<p>When the JVM runs, it’s given (conceptually) a block of memory by the OS.</p>
<p>Java programs access this memory via two abstract data structures typically referred to as the <em>stack</em> and <em>heap</em>.</p>
<p>Why two data structures? Different memory access patterns.</p>
</section>
<section id="the-stack" class="slide level1">
<h1>The stack</h1>
<p>The stack contains local variables and function (and method) parameters.</p>
<p>LIFO reflects the order of local variables appearing and disappearing as functions are called and return.</p>
</section>
<section id="the-stack-1" class="slide level1">
<h1>The stack</h1>
<p><img data-src="1-stack0.svg" class="generate" style="float: right" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="7">class A {
    static int f(int b) {
        return b + 1;
    }

    static void g() {
        int a = 1;
        int d = 4;
        int c = f(a);
    }
}</code></pre>
</div>
</section>
<section id="the-stack-2" class="slide level1">
<h1>The stack</h1>
<p><img data-src="1-stack01.svg" class="generate" style="float: right" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="8">class A {
    static int f(int b) {
        return b + 1;
    }

    static void g() {
        int a = 1;
        int d = 4;
        int c = f(a);
    }
}</code></pre>
</div>
</section>
<section id="the-stack-3" class="slide level1">
<h1>The stack</h1>
<p><img data-src="1-stack1.svg" class="generate" style="float: right" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="3">class A {
    static int f(int b) {
        return b + 1;
    }

    static void g() {
        int a = 1;
        int d = 4;
        int c = f(a);
    }
}</code></pre>
</div>
</section>
<section id="the-stack-4" class="slide level1">
<h1>The stack</h1>
<p><img data-src="1-stack2.svg" class="generate" style="float: right" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="9">class A {
    static int f(int b) {
        return b + 1;
    }

    static void g() {
        int a = 1;
        int d = 4;
        int c = f(a);
    }
}</code></pre>
</div>
</section>
<section id="the-heap" class="slide level1">
<h1>The heap</h1>
<p>The heap contains any object created with <code>new</code>.</p>
<p>It’s for objects which may stick around for arbitrarily long, i.e. their lifetimes are not tied to that of the functions which create them.</p>
</section>
<section id="the-heap-1" class="slide level1">
<h1>The heap</h1>
<p><img data-src="1-heap1.svg" class="generate" style="float: right" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="9">class A {
    int h = 0;

    int f(int b) {
        return b + this.h;
    }

    static A of() {
        int a = new A();
        a.h = 2;
        int c = a.f(1);
        return a;
    }
}</code></pre>
</div>
</section>
<section id="the-heap-2" class="slide level1">
<h1>The heap</h1>
<p><img data-src="1-heap2.svg" class="generate" style="float: right" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="10">class A {
    int h = 0;

    int f(int b) {
        return b + this.h;
    }

    static A of() {
        int a = new A();
        a.h = 2;
        int c = a.f(1);
        return a;
    }
}</code></pre>
</div>
</section>
<section id="the-heap-3" class="slide level1">
<h1>The heap</h1>
<p><img data-src="1-heap3.svg" class="generate" style="float: right" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="5">class A {
    int h = 0;

    int f(int b) {
        return b + this.h;
    }

    static A of() {
        int a = new A();
        a.h = 2;
        int c = a.f(1);
        return a;
    }
}</code></pre>
</div>
</section>
<section id="the-heap-4" class="slide level1">
<h1>The heap</h1>
<p><img data-src="1-heap4.svg" class="generate" style="float: right" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="11">class A {
    int h = 0;

    int f(int b) {
        return b + this.h;
    }

    static A of() {
        int a = new A();
        a.h = 2;
        int c = a.f(1);
        return a;
    }
}</code></pre>
</div>
</section>
<section id="diagrams-the-stack" class="slide level1">
<h1>Diagrams: the stack</h1>
<ul>
<li>Contains <em>entries</em>, which have a name and value
<ul>
<li>The value might be a <em>reference</em> <span class="math inline">→</span> to a heap object</li>
<li>A <em>frame</em> is a sequence of entries created in the same method</li>
</ul></li>
<li>After entering a method,
<ul>
<li>push an entry for <code>this</code></li>
<li>push an entry for each local variable or parameter</li>
</ul></li>
<li>When returning from a method,
<ul>
<li>pop everything in its frame</li>
</ul></li>
</ul>
</section>
<section id="diagrams-the-heap" class="slide level1">
<h1>Diagrams: the heap</h1>
<ul>
<li>When we see the <code>new</code> keyword, create a heap object with an entry for each field
<ul>
<li>A lambda is syntactic sugar for a <code>new</code> nested class</li>
</ul></li>
<li>If it is a lambda/nested class,
<ul>
<li>add entries for all locals immutably closed over</li>
<li>add an entry for the reference to the enclosing object</li>
</ul></li>
</ul>
</section>
<section id="recitation-2-week-4" class="slide level1">
<h1>Recitation 2 (week 4)</h1>
</section>
<section id="today-1" class="slide level1">
<h1>Today</h1>
<ul>
<li><strong>Overriding vs overloading</strong></li>
<li><strong>Tricky inheritance situations</strong></li>
<li>Interfaces</li>
</ul>
</section>
<section id="compile-time-vs-runtime" class="slide level1">
<h1>Compile-time vs runtime</h1>
<ul>
<li>At compile-time, we can only analyze code, i.e. we can’t run it</li>
<li>Certain information is unavailable and must be approximated, e.g. types</li>
</ul>
<pre ><code class="java">Animal a;
if (scanner.nextBoolean()) {
  a = new Dog();
} else {
  a = new Cat();
}
a.call(); // ?</code></pre>
<ul>
<li>aka “phase distinction”, <em>static</em> vs <em>dynamic</em></li>
</ul>
<!--
we can't know which branch is taken at compile-time. so all we can say is either branch is taken, and we must consider both when thinking of what could happen at call

this corresponds to us knowing that the compile-time type is animal, so it must be an animal or one of its subclasses
-->
</section>
<section id="overriding" class="slide level1">
<h1>Overriding</h1>
<pre ><code class="java">class Dog extends Animal {
  @Override
  void call() {
    System.out.println("woof!");
  }
}

class Cat extends Animal {
  @Override
  void call() {
    System.out.println("meow!");
  }
}</code></pre>
<p>Which method is called depends on the runtime type of the receiver, <code>this</code>:</p>
<pre ><code class="java">Animal a = ...;
a.call(); // depends on ...</code></pre>
</section>
<section id="overloading" class="slide level1">
<h1>Overloading</h1>
<pre ><code class="java">static void call(Dog d) {
  System.out.println("woof!");
}

static void call(Cat d) {
  System.out.println("meow!");
}</code></pre>
<p>Which method is called depends on the compile-time types of the receiver and parameters (and not the return type):</p>
<pre ><code class="java">Animal a = ...;
call(a); // will not compile</code></pre>
<pre ><code class="java">Dog d = new Dog();
call(d); // compiles and resolves to call(Dog)</code></pre>
</section>
<section id="overriding-vs-overloading" class="slide level1">
<h1>Overriding vs overloading</h1>
<ul>
<li>Overloading resolves at <strong>compile-time</strong>, so relies only on compile-time information</li>
<li>Overriding resolves at <strong>runtime</strong>, so relies on run-time information (“dynamic dispatch”)</li>
</ul>
</section>
<section id="overriding-vs-overloading-1" class="slide level1">
<h1>Overriding vs overloading</h1>
<ul>
<li>Tradeoff between expressiveness and guarantees</li>
<li>Bridging the gap
<ul>
<li><em>Casts</em> are runtime assertions that give us (shaky) compile-time guarantees</li>
<li>We lose information when casting <em>up</em>, but gain (dubious) information when casting <em>down</em></li>
</ul></li>
</ul>
<pre ><code class="java">Animal a = ...;
Dog d = (Dog) a; // gain info, but dubious (may fail)
Animal b = d; // lose info, but always works
Animal c = (Animal) d; // same as previous</code></pre>
</section>
<section id="intuitively" class="slide level1">
<h1>Intuitively</h1>
<p>Inheritance creates trees of classes:</p>
<p><img data-src="2-inheritance1.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
</section>
<section id="intuitively-1" class="slide level1">
<h1>Intuitively</h1>
<p><img data-src="2-inheritance2.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<p>Overriding arranges <em>methods</em> into trees as well, leading to <em>lines</em> (as in <em>lineage</em>) of methods.</p>
<p>Every method on a line has the same <em>signature</em> (name + parameter types).</p>
</section>
<section id="intuitively-2" class="slide level1">
<h1>Intuitively</h1>
<ul>
<li>Overloading chooses a line of methods at compile-time (using signature + receiver type)</li>
<li>Overriding chooses a single method on the line at runtime (using runtime type)</li>
</ul>
<p><img data-src="2-lineage.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
</section>
<section id="playing-compiler" class="slide level1">
<h1>Playing compiler</h1>
<p>How do we figure out which method is called?</p>
<ul>
<li>Look for the method of the same name with the same receiver and <em>closest</em> signature (“<a href="https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.4.9">overload resolution</a>”)</li>
<li>At runtime, methods which <code>@Override</code> it may instead be called</li>
</ul>
<p>(<code>@Override</code> is an optional assertion that may fail compilation if a method isn’t overriding anything)</p>
</section>
<section id="a" class="slide level1">
<h1>1a</h1>
<div id="one">
<pre ><code class="java">Circle c1 = new Circle(new Point(0, 0), 10);
Circle c2 = new Circle(new Point(0, 0), 10);
Object o1 = c1;
Object o2 = c2;</code></pre>
</div>
<p><img data-src="2-1a.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
</section>
<section id="a-1" class="slide level1">
<h1>1a</h1>
<pre ><code class="java">Circle c1 = new Circle(new Point(0, 0), 10);
Circle c2 = new Circle(new Point(0, 0), 10);
Object o1 = c1;
Object o2 = c2;</code></pre>
<pre ><code class="java">jshell&gt; o1.equals(o2)
equals(Object) called
$.. ==&gt; false</code></pre>
<ul>
<li><code>o1</code> is a compile-time <code>Object</code>, so only the <code>equals(Object)</code> line is eligible</li>
<li>The overriden <code>equals(Object)</code> is called</li>
<li><code>Point</code> doesn’t override <code>equals</code>, so <code>false</code>.</li>
</ul>
</section>
<section id="b" class="slide level1">
<h1>1b</h1>
<pre ><code class="java">Circle c1 = new Circle(new Point(0, 0), 10);
Circle c2 = new Circle(new Point(0, 0), 10);
Object o1 = c1;
Object o2 = c2;</code></pre>
<pre ><code class="java">jshell&gt; o1.equals((Circle) o2)
equals(Object) called
$.. ==&gt; false</code></pre>
<p>Doesn’t change the fact that <code>o1</code> is a compile-time <code>Object</code>.</p>
</section>
<section id="c" class="slide level1">
<h1>1c</h1>
<pre ><code class="java">Circle c1 = new Circle(new Point(0, 0), 10);
Circle c2 = new Circle(new Point(0, 0), 10);
Object o1 = c1;
Object o2 = c2;</code></pre>
<pre ><code class="java">jshell&gt; o1.equals(c2)
equals(Object) called
$.. ==&gt; false</code></pre>
<p>Same.</p>
</section>
<section id="d" class="slide level1">
<h1>1d</h1>
<pre ><code class="java">Circle c1 = new Circle(new Point(0, 0), 10);
Circle c2 = new Circle(new Point(0, 0), 10);
Object o1 = c1;
Object o2 = c2;</code></pre>
<pre ><code class="java">jshell&gt; o1.equals(c1)
equals(Object) called
$.. ==&gt; true</code></pre>
<p>Same, but now <code>o1</code> and <code>c1</code> are the same object, so <code>true</code>.</p>
</section>
<section id="e" class="slide level1">
<h1>1e</h1>
<pre ><code class="java">Circle c1 = new Circle(new Point(0, 0), 10);
Circle c2 = new Circle(new Point(0, 0), 10);
Object o1 = c1;
Object o2 = c2;</code></pre>
<pre ><code class="java">jshell&gt; c1.equals(o2)
equals(Object) called
$.. ==&gt; false</code></pre>
<ul>
<li>Now both lines are eligible, but <code>o2</code> is a compile-time <code>Object</code>, so overload resolution chooses <code>equals(Object)</code>.</li>
<li>At runtime, the overriden version is called. <code>false</code> still because <code>Point</code> doesn’t override <code>equals</code>.</li>
</ul>
</section>
<section id="f" class="slide level1">
<h1>1f</h1>
<pre ><code class="java">Circle c1 = new Circle(new Point(0, 0), 10);
Circle c2 = new Circle(new Point(0, 0), 10);
Object o1 = c1;
Object o2 = c2;</code></pre>
<pre ><code class="java">jshell&gt; c1.equals((Circle) o2);
equals(Circle) called
$.. ==&gt; false</code></pre>
<ul>
<li><code>o2</code> is a compile-time <code>Circle</code> so overload resolution chooses <code>equals(Circle)</code> as it’s <em>closer</em>.</li>
</ul>
</section>
<section id="g" class="slide level1">
<h1>1g</h1>
<pre ><code class="java">Circle c1 = new Circle(new Point(0, 0), 10);
Circle c2 = new Circle(new Point(0, 0), 10);
Object o1 = c1;
Object o2 = c2;</code></pre>
<pre ><code class="java">jshell&gt; c1.equals(c2)
equals(Circle) called
$.. ==&gt; false</code></pre>
<p>Same as previous.</p>
</section>
<section id="h" class="slide level1">
<h1>1h</h1>
<pre ><code class="java">Circle c1 = new Circle(new Point(0, 0), 10);
Circle c2 = new Circle(new Point(0, 0), 10);
Object o1 = c1;
Object o2 = c2;</code></pre>
<pre ><code class="java">jshell&gt; c1.equals(o1)
equals(Object) called
$.. ==&gt; true</code></pre>
<p>Same as 1e (<code>equals(Object)</code> chosen), except now we have two references to the same object, so <code>true</code>.</p>
</section>
<section id="a-2" class="slide level1">
<h1>2a</h1>
<pre ><code class="java">public class Rectangle {
    private double width;
    private double height;

    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }

    @Override
    public String toString() {
        return "Height: " + this.height +  " Width: " + this.width;
    }
}</code></pre>
</section>
<section id="a-3" class="slide level1">
<h1>2a</h1>
<p>A <code>Square</code> <em>is a</em> <code>Rectangle</code> with equal sides.</p>
<pre ><code class="java">public class Square extends Rectangle {
    public Square(double length) {
        super(length, length);
    }
}</code></pre>
</section>
<section id="b-1" class="slide level1">
<h1>2b</h1>
<p><code>Square</code> inherits <code>setWidth</code> and <code>setHeight</code>, and we can now create invalid <code>Square</code>s.</p>
<pre ><code class="java">jshell&gt; Square s = new Square(5.0)
s ==&gt; Height: 5.0 Width: 5.0
jshell&gt; s.setHeight(4)
jshell&gt; s
s ==&gt; Height: 4.0 Width: 5.0</code></pre>
</section>
<section id="c-1" class="slide level1">
<h1>2c</h1>
<p>LSP: anywhere we can use a <code>Rectangle</code>, we should also be able to use a <code>Square</code>…</p>
<pre ><code class="java">jshell&gt; Rectangle[] rects = {new Rectangle(3.0, 5.0), new Square(5.0)}
rects ==&gt; Rectangle[2] { Height: 5.0 Width: 3.0, Height: 5.0 Width: 5.0 }
jshell&gt; rects[0].setHeight(4.0)
jshell&gt; rects[0].setWidth(8.0)
jshell&gt; rects[0]
$.. ==&gt; Height: 4.0 Width: 8.0
jshell&gt; rects[1].setHeight(4.0)
jshell&gt; rects[1].setWidth(8.0)
jshell&gt; rects[1]
$.. ==&gt; Height: 8.0 Width: 8.0</code></pre>
<p>Now rectangles behave weirdly – we didn’t expect the call to <code>setHeight</code> to be forgotten.</p>
</section>
<section id="c-2" class="slide level1">
<h1>2c</h1>
<p>How do we get out of this?</p>
<p>Maybe a rectangle <em>is a</em> kind of square?</p>
<p>That doesn’t really make sense.</p>
</section>
<section id="c-3" class="slide level1">
<h1>2c</h1>
<p>It seems like <code>Square</code> and <code>Rectangle</code> should not inherit from each other.</p>
<p>But isn’t inheritance for modelling is-a relationships? What’s the problem?</p>
</section>
<section id="c-4" class="slide level1">
<h1>2c</h1>
<p>This is a bit of a trick question because <em>adding setters allows width and height to vary independently</em>. <code>Rectangle</code> isn’t just a platonic rectangle; it includes setters!</p>
<p><code>Square</code> inherits this ability and cannot shed it without violating the LSP.</p>
<p>The implementation in 2a without setters models the is-a relationship just fine.</p>
<p>Conclusion: mutability <del>ruins</del> <em>complicates</em> nice things</p>
</section>
<section id="c-5" class="slide level1">
<h1>2c</h1>
<p>Fixes:</p>
<ul>
<li>Immutability</li>
<li>Add <code>setSide(double)</code> to <code>Square</code> and throw exceptions in <code>setHeight</code> and <code>setWidth</code></li>
<li>Require <code>setHeight</code> and <code>setWidth</code> to be used together</li>
</ul>
<p>All are used in Java’s standard library.</p>
</section>
<section id="a-4" class="slide level1">
<h1>3a</h1>
<p><img data-src="2-3a.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<pre ><code class="java">Circle c = new Circle(new Point(0,0), 10);

// compile-time type: Shape, runtime type: Circle
Shape s = c;

// compile-time type: Printable, runtime type: Circle
Printable p = c;</code></pre>
<pre ><code class="java">s.print(); // no, not a compile-time Printable
p.print(); // yes
s.getArea(); // yes
p.getArea(); // no, not a compile-time Shape</code></pre>
</section>
<section id="bc" class="slide level1">
<h1>3b/c</h1>
<p>No, we can’t inherit from multiple abstract classes like we can from multiple interfaces.</p>
<p>Yes, interfaces can inherit from multiple parent interfaces.</p>
<p><img data-src="2-3c.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
</section>
<section id="recitation-3-week-5" class="slide level1">
<h1>Recitation 3 (week 5)</h1>
</section>
<section id="today-2" class="slide level1">
<h1>Today</h1>
<ul>
<li>Interfaces vs abstract classes</li>
<li>Variance</li>
<li>Generics</li>
</ul>
</section>
<section id="java-is-a-mature-language" class="slide level1">
<h1>Java is a mature language</h1>
<blockquote>
<p>There are only two kinds of languages: the ones people complain about and the ones nobody uses.</p>
</blockquote>
<ul>
<li>Interfaces</li>
<li>Variance</li>
<li>Generics</li>
</ul>
</section>
<section id="interfaces-vs-abstract-classes" class="slide level1">
<h1>Interfaces vs abstract classes</h1>
<ul>
<li>Interface
<ul>
<li>Methods are abstract by default</li>
<li>No state – <code>default</code> methods depend only on other methods</li>
<li><em>Can-do</em> relationships</li>
</ul></li>
<li>Abstract class
<ul>
<li>Methods are concrete by default</li>
<li>Methods may be stateful</li>
<li><em>Is-a</em> relationships</li>
</ul></li>
</ul>
</section>
<section id="section" class="slide level1">
<h1>1</h1>
<p>Inheriting from multiple classes:</p>
<pre ><code class="java">class A {
  void f() { } // concrete by default
}

class B {
  void f() { }
}

class AB extends A, B { }

new AB().f(); // which is called?</code></pre>
</section>
<section id="section-1" class="slide level1">
<h1>1</h1>
<p>Implementing multiple interfaces:</p>
<pre ><code class="java">interface A {
  void f(); // abstract by default
}

interface B {
  void f();
}

class AB implements A, B { }

new AB().f(); // AB satisfies both interfaces</code></pre>
</section>
<section id="section-2" class="slide level1">
<h1>1</h1>
<p>Default methods:</p>
<pre ><code class="java">interface A {
  default void f() { }
}

interface B {
  default void f() { }
}

class AB implements A, B { } // same problem</code></pre>
<pre ><code class="text wrap">|  Error:
|  types A and B are incompatible;
|    class AB inherits unrelated defaults for f() from types A and B</code></pre>
</section>
<section id="section-3" class="slide level1">
<h1>1</h1>
<p>What if only one is abstract?</p>
<pre ><code class="java">interface A {
  void f(); // abstract now
}

interface B {
  default void f() { }
}

class AB implements A, B { }</code></pre>
<pre ><code class="text wrap">Error:
|  AB is not abstract and does not override abstract method f() in A</code></pre>
</section>
<section id="section-4" class="slide level1">
<h1>1</h1>
<p>Solution: disambiguate</p>
<pre ><code class="java">interface A {
  default void f() { }
}

interface B {
  default void f() { }
}

class AB implements A, B {
  @Override
  public void f() {
    A.super.f(); // say which we want, or both
  }
}</code></pre>
</section>
<section id="section-5" class="slide level1">
<h1>1</h1>
<p>Works for interfaces as well</p>
<pre ><code class="java">interface A {
  default void f() { }
}

interface B {
  default void f() { }
}

interface AB extends A, B {
  @Override
  default void f() {
    A.super.f();
  }
}</code></pre>
<!--
# LSP

Anywhere we can use the parent, we should be able to use the child

$\implies$ child should not violate properties expected to hold of the parent

# 2

``` {.java data-line-numbers="*"}
FormattedText f1 = new FormattedText();
FormattedText f2 = f1.copy();
assert f1.equals(f2);
f1.toggleUnderline();
assert !f1.equals(f2);
```

Property: `toggleUnderline` changes the state of the `isUnderlined` field

# 2

``` {.java data-line-numbers="1|*"}
FormattedText f1 = new URL(); // changed
FormattedText f2 = f1.copy();
assert f1.equals(f2);
f1.toggleUnderline();
assert !f1.equals(f2); // oops
```

We can't replace every `FormattedText` with a `URL`, so this does violate the LSP... but is that a bad thing?

- It's certainly surprising
- Perhaps inheritance is the wrong tool if we want to ensure that URLs are always underlined?
- "Defensive programming"...
-->
</section>
<section id="section-6" class="slide level1">
<h1>2</h1>
<pre ><code class="java">class Animal {
    public Animal call() { // swap this...
      return new Animal();
    }
}
</code></pre>
<pre ><code class="java">class Dog extends Animal {
    @Override
    public Dog call() { // ... with this
      return new Dog();
    }

    public void wag() {
      // ...
    }
}</code></pre>
</section>
<section id="section-7" class="slide level1">
<h1>2</h1>
<pre ><code class="java">class Animal {
    public Dog call() {
      return new Dog();
    }
}
</code></pre>
<pre ><code class="java">class Dog extends Animal {
    @Override
    public Animal call() {
      return new Animal();
    }

    public void wag() {
      // ...
    }
}</code></pre>
</section>
<section id="section-8" class="slide level1">
<h1>2</h1>
<p>Fails to compile, but why?</p>
<p>Suppose it were allowed:</p>
<pre ><code class="java">// upcast, which is fine
Animal a = new Dog();

// returns Animal, but has compile-time type Dog
Dog d = a.call();

// doesn't work because d is an Animal
d.wag();</code></pre>
<p>We’re not guaranteed that <code>d</code> is a <code>Dog</code> because <code>call</code> returns an <code>Animal</code> when overriden, which can’t <code>wag</code>.</p>
</section>
<section id="section-9" class="slide level1">
<h1>2</h1>
<p>This applies as long as the overriden method returns any superclass of <code>Animal</code>:</p>
<pre ><code class="java" data-line-numbers="*">class Animal {
    public Animal call() {
      return new Animal();
    }
}
</code></pre>
<pre ><code class="java" data-line-numbers="3|*">class Dog extends Animal {
    @Override
    public Object call() {
      return new Object();
    }
}</code></pre>
<p>It follows that overriden methods <em>must</em> return the same class or a subclass, which brings us to…</p>
</section>
<section id="variance" class="slide level1">
<h1>Variance</h1>
<div id="variance1">
<p>Given the relationships between simple types, what can we say about those of compound types?</p>
<p><img data-src="3-variance1.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<p>(with <span class="math inline">→</span> denoting <code>&lt;:</code> or <code>extends</code>)</p>
</div>
</section>
<section id="variance-1" class="slide level1">
<h1>Variance</h1>
<div id="variance2">
<p><img data-src="3-variance2.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<ul>
<li>Covariant = relationship in same direction as that of smaller types</li>
<li>Intuitively, captures idea of substitutability</li>
</ul>
</div>
</section>
<section id="covariant-arrays" class="slide level1">
<h1>Covariant arrays</h1>
<div id="variance3">
<pre ><code class="java">public class A {
  public static void main(String[] args) {
    Integer[] numbers = {1, 2};

    // upcast allowed because Integer[] &lt;: Object[]
    Object[] objects = numbers;

    String s = "asd"; // String &lt;: Object
    Object so = (Object) s;

    objects[1] = so; // mutability
  }
}</code></pre>
<pre ><code class="text wrap">$ javac A.java

$ java A
Exception in thread "main" java.lang.ArrayStoreException: java.lang.String
  at A.main(A.java:13)</code></pre>
</div>
</section>
<section id="invariant-generics" class="slide level1">
<h1>Invariant generics</h1>
<div id="variance4">
<pre ><code class="java">import java.util.*;

public class A {
  public static void main(String[] args) {
    List&lt;Integer&gt; numbers = Arrays.asList(1, 2);

    List&lt;Object&gt; objects = numbers; // nope
  }
}</code></pre>
<pre ><code class="text wrap">$ javac A.java
A.java:7: error: incompatible types: List&lt;Integer&gt; cannot be converted to List&lt;Object&gt;
    List&lt;Object&gt; objects = numbers;
                           ^
1 error</code></pre>
<p>More incorrect programs are rightly rejected, but some correct programs too…</p>
</div>
</section>
<section id="more-on-variance" class="slide level1">
<h1>More on variance</h1>
<ul>
<li><a href="http://blog.ezyang.com/2014/11/tomatoes-are-a-subtype-of-vegetables/" class="uri">http://blog.ezyang.com/2014/11/tomatoes-are-a-subtype-of-vegetables/</a></li>
<li><a href="https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance" class="uri">https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance</a></li>
</ul>
</section>
<section id="generics" class="slide level1">
<h1>Generics</h1>
<p>Generics are type parameters, e.g. <code>List</code> is a function that takes some (type) <code>T</code> and returns <code>List&lt;T&gt;</code> (a type)</p>
<p>Methods can also have type parameters.</p>
<pre ><code class="java">public static &lt;T&gt; T[] appendToArray(T[] array, T item) {
  // ...
}</code></pre>
</section>
<section id="generics-1" class="slide level1">
<h1>Generics</h1>
<p>Before generics (pre-Java 5), people simply used <code>Object</code> in place of <code>T</code> and would use <code>instanceof</code> and casts.</p>
<pre ><code class="java">public static Object[] appendToArray(
  Object[] array, Object item) {
  // ...
}
</code></pre>
<pre ><code class="java">// 1. array covariance in action
// 2. cast required even for local cases
Animal[] moreAnimals =
  (Animal[]) appendToArray(animals, new Dog());</code></pre>
</section>
<section id="generics-2" class="slide level1">
<h1>Generics</h1>
<p>Generics are implemented in Java only at compile-time for backward compatibility with older <code>Object</code>-using code:</p>
<ul>
<li>They are <em>erased</em> at runtime and replaced with <code>Object</code></li>
<li>Only reference types can be used in parameters (wrapper types/boxing)</li>
</ul>
</section>
<section id="section-10" class="slide level1">
<h1>3</h1>
<ol type="a">
<li>Invalid because generic types cannot be primitives</li>
<li>Valid, will be inferred (or fail to compile)</li>
<li>Valid, will be <code>A&lt;Object&gt;</code> (backward compatibility)</li>
</ol>
</section>
<section id="a-5" class="slide level1">
<h1>4a</h1>
<pre ><code class="java">import java.util.List;

class A {
  void foo(List&lt;Integer&gt; integerList) {}
  void foo(List&lt;String&gt; StringList) {}
}</code></pre>
<pre ><code class="text wrap">|  Error:
|  name clash: foo(java.util.List&lt;java.lang.String&gt;) and foo(java.util.List&lt;java.lang.Integer&gt;) have the same erasure
|  void foo(List&lt;String&gt; StringList) {}
|  ^----------------------------------^</code></pre>
<p>After type erasure, both methods have signature <code>foo(List)</code>, which cannot be distinguished at runtime.</p>
</section>
<section id="b-2" class="slide level1">
<h1>4b</h1>
<pre ><code class="java">class B&lt;T&gt; {
  T x;
  static T y;
}</code></pre>
<pre ><code class="text wrap">|  Error:
|  non-static type variable T cannot be referenced from a static context
|  static T y;
|         ^</code></pre>
<p><code>B</code> may be instantiated with many types (e.g. <code>B&lt;Integer&gt;</code>, <code>B&lt;String&gt;</code>), so there’s no single type <code>T</code> that may be shared across all accesses of <code>B.y</code>.</p>
<p><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#createStatic" class="small">https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#createStatic</a></p>
</section>
<section id="c-6" class="slide level1">
<h1>4c</h1>
<pre ><code class="java">class C&lt;T&gt; {
  static int b = 0;
  C() {
    this.b++;
  }
}</code></pre>
<pre ><code >jshell&gt; C.main(null);
2
2</code></pre>
<ul>
<li><code>this.b</code> denotes <code>C.b</code> when <code>b</code> is static.</li>
<li>The code thus increments the value of a shared static field</li>
<li>Notice the parameter <code>T</code> isn’t actually used. This is fine because it doesn’t exist at runtime.</li>
</ul>
</section>
<section id="recitation-4-week-6" class="slide level1">
<h1>Recitation 4 (week 6)</h1>
</section>
<section id="consultation" class="slide level1">
<h1>Consultation</h1>
<p>Office hours: 11am to 12pm, Thursdays, AS3-06-09</p>
<ol type="1">
<li>Office hours (on-demand)?</li>
<li>Zoom (on-demand)?</li>
</ol>
</section>
<section id="variance-2" class="slide level1">
<h1>Variance</h1>
<p><img data-src="Java_wildcard_subtyping.svg" class="center" /></p>
<p><a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)" class="credit small">https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)</a></p>
</section>
<section id="variance-3" class="slide level1">
<h1>Variance</h1>
<p>Given the relationships between simple types, what can we say about those of compound types?</p>
<p><img data-src="3-variance1.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<p>(with <span class="math inline">→</span> denoting <code>&lt;:</code> or <code>extends</code>)</p>
</section>
<section id="variance-4" class="slide level1">
<h1>Variance</h1>
<p><img data-src="3-variance2.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<ul>
<li>Covariant = relationship in same direction as that of smaller types</li>
<li>Intuitively, captures idea of substitutability</li>
</ul>
</section>
<section id="covariant-arrays-1" class="slide level1">
<h1>Covariant arrays</h1>
<pre ><code class="java">public class A {
  public static void main(String[] args) {
    Integer[] numbers = {1, 2};

    // upcast allowed because Integer[] &lt;: Object[]
    Object[] objects = numbers;

    String s = "asd"; // String &lt;: Object
    Object so = (Object) s;

    objects[1] = so; // mutability
  }
}</code></pre>
<pre ><code class="text wrap">$ javac A.java

$ java A
Exception in thread "main" java.lang.ArrayStoreException: java.lang.String
  at A.main(A.java:13)</code></pre>
</section>
<section id="invariant-generics-1" class="slide level1">
<h1>Invariant generics</h1>
<pre ><code class="java">import java.util.*;

public class A {
  public static void main(String[] args) {
    List&lt;Integer&gt; numbers = Arrays.asList(1, 2);

    List&lt;Object&gt; objects = numbers; // nope
  }
}</code></pre>
<pre ><code class="text wrap">$ javac A.java
A.java:7: error: incompatible types: List&lt;Integer&gt; cannot be converted to List&lt;Object&gt;
    List&lt;Object&gt; objects = numbers;
                           ^
1 error</code></pre>
<p>More incorrect programs are rightly rejected, but some correct programs too…</p>
</section>
<section id="functions-methods" class="slide level1">
<h1>Functions (methods)</h1>
<blockquote>
<p>Be conservative in what you do, be liberal in what you accept from others</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Robustness_principle" class="credit">https://en.wikipedia.org/wiki/Robustness_principle</a></p>
</section>
<section id="functions-methods-1" class="slide level1">
<h1>Functions (methods)</h1>
<p>The robustness principle originates in the context of network protocol design.</p>
<p>Idea: it’s always safe to assume people don’t follow specs, and follow specs more than people expect you to</p>
</section>
<section id="functions-methods-2" class="slide level1">
<h1>Functions (methods)</h1>
<p>The robustness principle originates in the context of network protocol design.</p>
<p><strong>Idea: it’s always safe to accept something more general and return something more specific</strong></p>
</section>
<section id="operationally" class="slide level1">
<h1>Operationally</h1>
<p><img data-src="4-variance-fun1.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<p>“If I need a function <span class="math inline"><em>A</em><em>n</em><em>i</em><em>m</em><em>a</em><em>l</em> → <em>A</em><em>n</em><em>i</em><em>m</em><em>a</em><em>l</em></span>, I can use a function <span class="math inline"><em>A</em><em>n</em><em>i</em><em>m</em><em>a</em><em>l</em> → <em>D</em><em>o</em><em>g</em></span> instead, then upcast the result.”</p>
<p>(Covariant in return type)</p>
</section>
<section id="operationally-1" class="slide level1">
<h1>Operationally</h1>
<p><img data-src="4-variance-fun2.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<p>“If I need a function <span class="math inline"><em>D</em><em>o</em><em>g</em> → <em>A</em><em>n</em><em>i</em><em>m</em><em>a</em><em>l</em></span>, I must already have a <span class="math inline"><em>D</em><em>o</em><em>g</em></span> argument. I can upcast it, then use a function <span class="math inline"><em>A</em><em>n</em><em>i</em><em>m</em><em>a</em><em>l</em> → <em>A</em><em>n</em><em>i</em><em>m</em><em>a</em><em>l</em></span> instead.”</p>
<p>(Contravariant in parameter types)</p>
</section>
<section id="variance-so-far" class="slide level1">
<h1>Variance so far</h1>
<p><img data-src="3-variance2.svg" class="center" /></p>
<p>Today: “what do we do about the missing arrow?”</p>
</section>
<section id="the-missing-arrow" class="slide level1">
<h1>The missing arrow</h1>
<p>Idea: have a common supertype of both <code>List&lt;Animal&gt;</code> and <code>List&lt;Dog&gt;</code></p>
<p><img data-src="4-variance1.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<p>This would allow us to write code that works for both kinds of lists.</p>
</section>
<section id="the-missing-arrow-1" class="slide level1">
<h1>The missing arrow</h1>
<p>Idea: allow writing constraints on what type parameters can be</p>
<p><img data-src="4-variance1.svg" class="center" /></p>
<p>Now we can express <code>List&lt;"Dog or Animal"&gt;</code>!</p>
</section>
<section id="wildcards" class="slide level1">
<h1>Wildcards</h1>
<p>Upper-bounded wildcards, e.g. “Animal <strong>or</strong> any subtype”</p>
<pre ><code class="java">List&lt;? extends Animal&gt;</code></pre>
<p>Lower-bounded wildcards, e.g. “Dog <strong>or</strong> any supertype”</p>
<pre ><code class="java">List&lt;? super Dog&gt;</code></pre>
<p>Unbounded, i.e. anything</p>
<pre ><code class="java">List&lt;?&gt;</code></pre>
</section>
<section id="wildcards-1" class="slide level1">
<h1>Wildcards</h1>
<p><code>List&lt;? extends Animal&gt;</code> is more permissive than <code>List&lt;Animal&gt;</code>, but we can guarantee less about it.</p>
<p><br /></p>
<p><code>List&lt;? extends Animal&gt;</code> is <em>less</em> permissive than <code>List&lt;?&gt;</code>, so we can guarantee <em>more</em>.</p>
<p><br /></p>
<p>“More guarantees” (fewer disjuncts) <span class="math inline">⟹</span> substitutable</p>
</section>
<section id="wildcards-2" class="slide level1">
<h1>Wildcards</h1>
<p><img data-src="4-variance-wildcards1.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
</section>
<section id="wildcards-3" class="slide level1">
<h1>Wildcards</h1>
<p><img data-src="4-variance-wildcards2.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<div class="right">
<p><a href="#/variance-2" class="small">Diagram from earlier</a></p>
</div>
</section>
<section id="nesting" class="slide level1">
<h1>Nesting</h1>
<p><img data-src="4-variance-nesting1.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
</section>
<section id="nesting-1" class="slide level1">
<h1>Nesting</h1>
<p><img data-src="4-variance-nesting2.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
</section>
<section id="section-11" class="slide level1">
<h1>1</h1>
<p><code>Comparable</code> defines a <em>relation</em></p>
<pre ><code class="java">static &lt;T extends Comparable&lt;T&gt;&gt; T max3(T[] arr) {
    T max = arr[0];
    if (arr[1].compareTo(max) &gt; 0) {
        max = arr[1];
    }
    if (arr[2].compareTo(max) &gt; 0) {
        max = arr[2];
    }
    return max;
}</code></pre>
<pre ><code class="text">jshell&gt; Integer a = max3(new Integer[] {1, 2, 3});
a ==&gt; 3</code></pre>
</section>
<section id="a-6" class="slide level1">
<h1>1a</h1>
<pre ><code class="java">// Bound removed, parameter type changed
static &lt;T&gt; Comparable&lt;T&gt; max3(Comparable&lt;T&gt;[] arr) {
    Comparable&lt;T&gt; max = arr[0]; // T &lt;/: Comparable&lt;T&gt;
    if (arr[1].compareTo((T) max) &gt; 0) { // cast
        max = arr[1];
    }
    if (arr[2].compareTo((T) max) &gt; 0) {
        max = arr[2];
    }
    return max;
}</code></pre>
<pre ><code class="text">jshell&gt; Integer a = max3(new Integer[] {1, 2, 3});
|  Error:
|  incompatible types: no instance(s) of type variable(s) T exist so that java.lang.Comparable&lt;T&gt; conforms to java.lang.Integer
|  Integer a = max3(new Integer[] {1, 2, 3});
|              ^---------------------------^

jshell&gt; Integer a = (Integer) max3(new Integer[] {1, 2, 3});
a ==&gt; 3</code></pre>
</section>
<section id="b-3" class="slide level1">
<h1>1b</h1>
<pre ><code class="java">// 1a, but return type changed as well
static &lt;T&gt; T max3(Comparable&lt;T&gt;[] arr) {
    T max = (T) arr[0]; // back to T because returned
    if (arr[1].compareTo(max) &gt; 0) {
        max = (T) arr[1]; // casts required
    }
    if (arr[2].compareTo(max) &gt; 0) {
        max = (T) arr[2];
    }
    return max;
}</code></pre>
<pre ><code class="text">jshell&gt; Integer a = max3(new Integer[] {1, 2, 3});
a ==&gt; 3</code></pre>
</section>
<section id="c-7" class="slide level1">
<h1>1c</h1>
<pre ><code class="java">// All type parameters dropped
static Comparable max3(Comparable[] arr) {
    Comparable max = arr[0]; // changed
    if (arr[1].compareTo(max) &gt; 0) {
        max = arr[1];
    }
    if (arr[2].compareTo(max) &gt; 0) {
        max = arr[2];
    }
    return max;
}</code></pre>
<pre ><code class="text">jshell&gt; Integer a = max3(new Integer[] {1, 2, 3});
|  Error:
|  incompatible types: java.lang.Comparable cannot be converted to java.lang.Integer
|  Integer a = max3(new Integer[] {1, 2, 3});
|              ^---------------------------^

jshell&gt; Integer a = (Integer) max3(new Integer[] {1, 2, 3});
a ==&gt; 3</code></pre>
</section>
<section id="section-12" class="slide level1">
<h1>2</h1>
<pre ><code class="java">class Fruit implements Comparable&lt;Fruit&gt; {
    @Override
    public int compareTo(Fruit f) { return 0; }
}
class Orange extends Fruit { }</code></pre>
<p><img data-src="4-fruit.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<pre ><code class="java">static &lt;T extends Comparable&lt;T&gt;&gt; T max3(List&lt;T&gt; list) {
  // ...
}</code></pre>
</section>
<section id="section-13" class="slide level1">
<h1>2</h1>
<p>“Maximally flexible” = this works:</p>
<pre ><code class="java">List&lt;Fruit&gt; f = ...;
max3(f);

List&lt;Orange&gt; o = ...;
max3(o);</code></pre>
</section>
<section id="section-14" class="slide level1">
<h1>2</h1>
<p>However…</p>
<pre ><code class="java">List&lt;Fruit&gt; f = ...;
max3(f); // ok

List&lt;Orange&gt; o = ...;
max3(o); // compile error</code></pre>
<p>Why?</p>
</section>
<section id="section-15" class="slide level1">
<h1>2</h1>
<!-- ![](4-fruit.svg) -->
<p>We “play compiler” and try to find some <code>T</code> such that the constraints are met.</p>
<pre ><code class="java">static &lt;T extends Comparable&lt;T&gt;&gt; T max3(List&lt;T&gt; list)</code></pre>
<p>If <code>T</code> = <code>Fruit</code>,</p>
<p><code>Fruit &lt;: Comparable&lt;Fruit&gt;</code> does hold.</p>
<p>If <code>T</code> = <code>Orange</code>,</p>
<p><code>Orange &lt;: Comparable&lt;Orange&gt;</code> does not!</p>
</section>
<section id="section-16" class="slide level1">
<h1>2</h1>
<p>Solution 1:</p>
<pre ><code class="java">static &lt;T extends Comparable&lt;T&gt;&gt; T max3(List&lt;? extends T&gt; list)</code></pre>
<p>Now there are many possible values for <code>T</code> the compiler could use.</p>
<p>If <code>T</code> = <code>Orange</code>,</p>
<p><code>Orange &lt;: Comparable&lt;Orange&gt;</code> does not hold!</p>
</section>
<section id="section-17" class="slide level1">
<h1>2</h1>
<p>Solution 1:</p>
<pre ><code class="java">static &lt;T extends Comparable&lt;T&gt;&gt; T max3(List&lt;? extends T&gt; list)</code></pre>
<p>But if <code>T = Fruit</code>,</p>
<p><code>Fruit &lt;: Comparable&lt;Fruit&gt;</code> does hold.</p>
<p><code>List&lt;Orange&gt; &lt;: List&lt;? extends Fruit&gt;</code> also.</p>
<p>(<u>PE</u>CS because we only read from the list)</p>
</section>
<section id="section-18" class="slide level1">
<h1>2</h1>
<pre ><code class="text">jshell&gt; /set feedback verbose
|  Feedback mode: verbose

jshell&gt; max3(o)
$2 ==&gt; Orange@41975e01
|  created scratch variable $2 : Fruit</code></pre>
<p>We’ve forgotten that an orange was passed in!</p>
</section>
<section id="section-19" class="slide level1">
<h1>2</h1>
<p>Solution 2:</p>
<pre ><code class="java">static &lt;T extends Comparable&lt;? super T&gt;&gt; T max3(List&lt;T&gt; list)</code></pre>
<p>Given <code>T</code> = <code>Orange</code>,</p>
<p><code>Orange &lt;: Comparable&lt;? super Orange&gt;</code> is true!</p>
<p>Also works for <code>T</code> = <code>Fruit</code>.</p>
<!--
``` {.generate cmd="dot -Tsvg -o $out" file="4-fruit1.svg" .center}
digraph G {
  rankdir=BT;
  Fruit -> cf;
  cf [label="Comparable<Fruit>"];
  Orange -> Fruit;
  co [label="Comparable<Orange>"];
  cso [label="Comparable<? super Orange>"];
  cf -> cso;
}
```
-->
<p>(PE<u>CS</u> because we only pass things into <code>compareTo</code>)</p>
</section>
<section id="section-20" class="slide level1">
<h1>2</h1>
<pre ><code class="text">jshell&gt; max3(f)
$2 ==&gt; Fruit@1963006a
|  created scratch variable $2 : Fruit

jshell&gt; max3(o)
$3 ==&gt; Orange@368102c8
|  created scratch variable $3 : Orange</code></pre>
<p>This is better!</p>
</section>
<section id="section-21" class="slide level1">
<h1>2</h1>
<p>Solution 1 + 2:</p>
<pre ><code class="java">static &lt;T extends Comparable&lt;? super T&gt;&gt; T
  max3(List&lt;? extends T&gt; list)</code></pre>
<p>(<u>PECS</u>)</p>
<p>More general than 2, but functionally the same</p>
</section>
<section id="a-7" class="slide level1">
<h1>3a</h1>
<pre ><code class="java">void foo(List&lt;?&gt; list) { }

foo(new ArrayList&lt;String&gt;());</code></pre>
</section>
<section id="a-8" class="slide level1">
<h1>3a</h1>
<pre ><code class="java">void foo(List&lt;?&gt; list) { }

foo(new ArrayList&lt;String&gt;());</code></pre>
<p>This works!</p>
<pre ><code class="text">ArrayList&lt;String&gt; &lt;: List&lt;String&gt;
                  &lt;: List&lt;?&gt;</code></pre>
</section>
<section id="b-4" class="slide level1">
<h1>3b</h1>
<pre ><code class="java">void foo(List&lt;? super Integer&gt; list) { }

foo(new List&lt;Object&gt;());</code></pre>
</section>
<section id="b-5" class="slide level1">
<h1>3b</h1>
<pre ><code class="java">void foo(List&lt;? super Integer&gt; list) { }

foo(new List&lt;Object&gt;());</code></pre>
<p><code>List</code> is an interface. We can’t instantiate it.</p>
<p>It would work if we changed it to <code>ArrayList&lt;Object&gt;</code>:</p>
<pre ><code class="text">ArrayList&lt;Object&gt; &lt;: List&lt;Object&gt;
                  &lt;: List&lt;? super Object&gt;
                  &lt;: List&lt;? super Integer&gt;</code></pre>
</section>
<section id="c-8" class="slide level1">
<h1>3c</h1>
<pre ><code class="java">void foo(List&lt;? extends Object&gt; list) { }

foo(new ArrayList&lt;Object&gt;());</code></pre>
</section>
<section id="c-9" class="slide level1">
<h1>3c</h1>
<pre ><code class="java">void foo(List&lt;? extends Object&gt; list) { }

foo(new ArrayList&lt;Object&gt;());</code></pre>
<p>This works, since</p>
<pre ><code class="text">ArrayList&lt;Object&gt; &lt;: ArrayList&lt;? extends Object&gt;
                  &lt;: List&lt;? extends Object&gt;</code></pre>
</section>
<section id="d-1" class="slide level1">
<h1>3d</h1>
<pre ><code class="java">void foo(List&lt;? super Integer&gt; list) { }

foo(new ArrayList&lt;int&gt;());</code></pre>
</section>
<section id="d-2" class="slide level1">
<h1>3d</h1>
<pre ><code class="java">void foo(List&lt;? super Integer&gt; list) { }

foo(new ArrayList&lt;int&gt;());</code></pre>
<p>A type parameter cannot be a primitive type.</p>
</section>
<section id="e-1" class="slide level1">
<h1>3e</h1>
<pre ><code class="java">void foo(List&lt;? super Integer&gt; list) { }

foo(new ArrayList());</code></pre>
</section>
<section id="e-2" class="slide level1">
<h1>3e</h1>
<pre ><code class="java">void foo(List&lt;? super Integer&gt; list) { }

foo(new ArrayList());</code></pre>
<p>Compiles, but with a warning.</p>
<p>Raw types are for interop with legacy code and shouldn’t be used in new code.</p>
</section>
<section id="recitation-5-week-7" class="slide level1">
<h1>Recitation 5 (week 7)</h1>
</section>
<section id="consultation-1" class="slide level1">
<h1>Consultation</h1>
<ul>
<li>Zoom by default
<ul>
<li>Thursday 11-12</li>
<li>Link on Luminus &gt; Module Details</li>
</ul></li>
<li>Face-to-face on demand
<ul>
<li>Ideally, groups of 2-3</li>
</ul></li>
</ul>
</section>
<section id="midterm" class="slide level1">
<h1>Midterm</h1>
<ul>
<li>Overloading and overriding: 12-15</li>
<li>Variance: 16-27</li>
<li>OO principles: 28-30</li>
<li>Anything else that is unclear</li>
</ul>
</section>
<section id="section-22" class="slide level1">
<h1>12-15</h1>
<!--
``` {.generate cmd="dot -Tsvg -o $out" file="5-overloading.svg" .center}
digraph G {
  rankdir=BT;

  subgraph cluster_0 {
    D -> C -> B -> A;
  }
  subgraph cluster_1 {
    aa [label="A::foo(A)"];
    ba [label="B::foo(A)"];
    bb [label="B::foo(B)"];
    cc [label="C::foo(C)"];
    db [label="D::foo(B)"];
    ba -> aa;
    db -> bb;
  }
  A -> aa [style=dashed arrowhead=none];
  B -> ba [style=dashed arrowhead=none];
  B -> bb [style=dashed arrowhead=none];
  C -> cc [style=dashed arrowhead=none];
  //C -> ba [style=dashed arrowhead=none];
  //C -> bb [style=dashed arrowhead=none];
  D -> db [style=dashed arrowhead=none];
  //D -> cc [style=dashed arrowhead=none];
  //D -> ba [style=dashed arrowhead=none];
}
```
-->
<p><img data-src="5-overloading0.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
</section>
<section id="section-23" class="slide level1">
<h1>12-15</h1>
<pre ><code class="java">A a = new D();
B b = new D();
C c = new D();
D d = new D();</code></pre>
<pre ><code class="java">a.foo(d);
b.foo(d);
c.foo(d);
d.foo(d);</code></pre>
</section>
<section id="section-24" class="slide level1">
<h1>12-15</h1>
<p><img data-src="5-overloading1.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
</section>
<section id="section-25" class="slide level1">
<h1>12-15</h1>
<p><img data-src="5-overloading2.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
</section>
<section id="section-26" class="slide level1">
<h1>12-15</h1>
<p><img data-src="5-overloading3.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
</section>
<section id="section-27" class="slide level1">
<h1>12-15</h1>
<p><img data-src="5-overloading4.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
</section>
<section id="section-28" class="slide level1">
<h1>16</h1>
<p><img data-src="5-shihtzu.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<p><code>Animal &lt;: Trainable</code>? False</p>
</section>
<section id="section-29" class="slide level1">
<h1>17</h1>
<p><img data-src="5-shihtzu.svg" class="center" /></p>
<p><code>Dog &lt;: Comparable&lt;Animal&gt;</code>? False</p>
</section>
<section id="section-30" class="slide level1">
<h1>18</h1>
<p><img data-src="5-shihtzu.svg" class="center" /></p>
<p><code>ShihTzu &lt;: Comparable&lt;Mammal&gt;</code>? True</p>
</section>
<section id="section-31" class="slide level1">
<h1>19</h1>
<p><img data-src="5-shihtzu1.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<p><code>ShihTzu &lt;: Comparable&lt;? extends Animal&gt;</code>? True</p>
</section>
<section id="section-32" class="slide level1">
<h1>20</h1>
<p><img data-src="5-shihtzu2.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<p><code>ShihTzu &lt;: Comparable&lt;? super ShihTzu&gt;</code>? True</p>
</section>
<section id="section-33" class="slide level1">
<h1>21</h1>
<p><img data-src="5-shihtzu3.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<p><code>Comparable&lt;ShihTzu&gt; &lt;: Comparable&lt;? extends Trainable&gt;</code>? True, same as 19</p>
</section>
<section id="section-34" class="slide level1">
<h1>22-27</h1>
<pre ><code class="java">class A {
  static &lt;U, T extends U&gt; U foo(List&lt;? super T&gt; list) {
    U u = null;
    return u;
  }
}</code></pre>
<pre ><code class="java">Dog dog = new Dog();
List&lt;Dog&gt; dogList = List.of(dog);</code></pre>
<p>Induced constraints:</p>
<p><img data-src="5-22.svg" class="generate center" style="float: right" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<ul>
<li><code>T &lt;: U</code></li>
<li><code>T &lt;:</code> argument parameter</li>
<li>Returns a <code>U</code></li>
</ul>
</section>
<section id="section-35" class="slide level1">
<h1>22</h1>
<pre ><code class="java">dog = A.&lt;Mammal,Dog&gt;foo(dogList);</code></pre>
<p>Additional constraint: <code>U &lt;: Dog</code></p>
<pre ><code class="text">U = Mammal
T = Dog
arg = Dog</code></pre>
<p><img data-src="5-22-1.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<p>False because of the return type</p>
</section>
<section id="section-36" class="slide level1">
<h1>23</h1>
<pre ><code class="java">dog = A.&lt;Dog,ShihTzu&gt;foo(dogList);</code></pre>
<pre ><code class="text">U = Dog
T = ShihTzu
arg = Dog</code></pre>
<p><img data-src="5-23.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<p><code>ShihTzu &lt;: Dog</code>, so true</p>
</section>
<section id="section-37" class="slide level1">
<h1>24</h1>
<pre ><code class="java">dog = A.&lt;ShihTzu,ShihTzu&gt;foo(dogList);</code></pre>
<pre ><code class="text">U = ShihTzu
T = ShihTzu
arg = Dog</code></pre>
<p><img data-src="5-24.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<p><code>ShihTzu &lt;: ShihTzu</code> and <code>ShihTzu &lt;: Dog</code>, so true</p>
</section>
<section id="section-38" class="slide level1">
<h1>25</h1>
<pre ><code class="java">dog = A.&lt;ShihTzu,Dog&gt;foo(dogList);</code></pre>
<pre ><code class="text">U = ShihTzu
T = Dog
arg = Dog</code></pre>
<p><img data-src="5-25.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<p><code>Dog &lt;/: ShihTzu</code>, so false</p>
</section>
<section id="section-39" class="slide level1">
<h1>26</h1>
<pre ><code class="java">dog = A.&lt;Dog,Dog&gt;foo(dogList);</code></pre>
<pre ><code class="text">U = Dog
T = Dog
arg = Dog</code></pre>
<p><img data-src="5-26.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<p><code>Dog &lt;: Dog</code>, true</p>
</section>
<section id="section-40" class="slide level1">
<h1>27</h1>
<pre ><code class="java">&lt;U, T extends U&gt; U foo(List&lt;? super T&gt; list)</code></pre>
<pre ><code class="text">T &lt;: U
T &lt;: Dog</code></pre>
<p>Possible answers:</p>
<ul>
<li><code>T=Dog, U=Dog</code> (Q26)</li>
<li><code>T=ShihTzu, U=ShihTzu</code> (Q24)</li>
<li><code>T=Dog, U=ShihTzu</code> (Q23)</li>
</ul>
<p>If ambiguous, the lower bound/more specific one is chosen, so the answer is ShihTzu, ShihTzu</p>
<p><a href="https://stackoverflow.com/a/46126309" class="credit">https://stackoverflow.com/a/46126309</a></p>
</section>
<section id="recitation-6-week-8" class="slide level1">
<h1>Recitation 6 (week 8)</h1>
</section>
<section id="today-3" class="slide level1">
<h1>Today</h1>
<p>Beyond mutable OOP</p>
<ul>
<li>Nested and anonymous classes (<span class="math inline"><em>λ</em></span> soon)</li>
<li>Refresher on immutable data structures</li>
</ul>
</section>
<section id="metaspace" class="slide level1">
<h1>Metaspace</h1>
<p>Java requires type information to kept around at runtime for dynamic dispatch, i.e. some <em>metadata</em> about classes has to be somewhere in memory while the JVM is executing programs.</p>
<p>This place is distinct from the stack and the heap.</p>
<p><a href="https://stuefe.de/posts/metaspace/what-is-metaspace/" class="credit">https://stuefe.de/posts/metaspace/what-is-metaspace/</a></p>
</section>
<section id="a-9" class="slide level1">
<h1>1a</h1>
<p><img data-src="6-0.svg" class="generate" style="float: right" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="">class B {
    static int x = 0;

    void f() {
        A a = new A();
    }

    static class A {
        int y = 0;

        A() {
            y = x + 1;
        }
    }
}</code></pre>
<pre ><code class="java">B b = new B();
b.f();</code></pre>
</div>
</section>
<section id="static-nested-classes" class="slide level1">
<h1>Static nested classes</h1>
<pre ><code class="java">class Person {
  static class Pet {
  }
}</code></pre>
<pre ><code class="text">jshell&gt; new Person.Pet()
$2 ==&gt; Person$Pet@246b179d</code></pre>
</section>
<section id="a-10" class="slide level1">
<h1>1a</h1>
<p><img data-src="6-1.svg" class="generate" style="float: right" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="4">class B {
    static int x = 0;

    void f() {
        A a = new A();
    }

    static class A {
        int y = 0;

        A() {
            y = x + 1;
        }
    }
}</code></pre>
<pre ><code class="java">B b = new B();
b.f();</code></pre>
</div>
<p><a href="#/diagrams-the-stack" class="right" style="float: right;">Diagrams?</a></p>
</section>
<section id="a-11" class="slide level1">
<h1>1a</h1>
<p><img data-src="6-2-1.svg" class="generate" style="float: right" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="11">class B {
    static int x = 0;

    void f() {
        A a = new A();
    }

    static class A {
        int y = 0;

        A() {
            y = x + 1;
        }
    }
}</code></pre>
<pre ><code class="java">B b = new B();
b.f();</code></pre>
</div>
</section>
<section id="a-12" class="slide level1">
<h1>1a</h1>
<p><img data-src="6-2.svg" class="generate" style="float: right" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="5">class B {
    static int x = 0;

    void f() {
        A a = new A();
    }

    static class A {
        int y = 0;

        A() {
            y = x + 1;
        }
    }
}</code></pre>
<pre ><code class="java">B b = new B();
b.f();</code></pre>
</div>
</section>
<section id="b-6" class="slide level1">
<h1>1b</h1>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="">class B {
    void f() {
        int x = 0;

        class A {
            int y = 0;
            A() {
                y = x + 1;
            }
        }

        A a = new A();
    }
}</code></pre>
<pre ><code class="java">B b = new B();
b.f();</code></pre>
</div>
</section>
<section id="nested-inner-classes" class="slide level1">
<h1>Nested (inner) classes</h1>
<p>Have an accompanying <em>instance</em> of the enclosing class</p>
<pre ><code class="java">class Person {
  class Pet {
  }
}</code></pre>
<pre ><code class="text">jshell&gt; new Person.Pet()
|  Error:
|  an enclosing instance that contains Person.Pet is required
|  new Person.Pet()
|  ^--------------^

jshell&gt; Person p = new Person()
p ==&gt; Person@5a10411

jshell&gt; p.new Pet()
$2 ==&gt; Person$Pet@306a30c7</code></pre>
</section>
<section id="b-7" class="slide level1">
<h1>1b</h1>
<p><img data-src="6-3.svg" class="generate" style="float: right" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="3">class B {
    void f() {
        int x = 0;

        class A {
            int y = 0;
            A() {
                y = x + 1;
            }
        }

        A a = new A();
    }
}</code></pre>
<pre ><code class="java">B b = new B();
b.f();</code></pre>
</div>
</section>
<section id="b-8" class="slide level1">
<h1>1b</h1>
<p><img data-src="6-4.svg" class="generate" style="float: right" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="12">class B {
    void f() {
        int x = 0;

        class A {
            int y = 0;
            A() {
                y = x + 1;
            }
        }

        A a = new A();
    }
}</code></pre>
<pre ><code class="java">B b = new B();
b.f();</code></pre>
</div>
</section>
<section id="b-9" class="slide level1">
<h1>1b</h1>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="">class B {
    void f() {
        int x = 0;

        class A {
            int y = 0;
            A() {
                // y = x + 1;
                x = x + 1;
            }
        }

        A a = new A();
    }
}</code></pre>
</div>
<pre ><code class="text wrap">|  Error:
|  local variables referenced from an inner class must be final or effectively final
|                  x = x + 1;
|                  ^</code></pre>
</section>
<section id="c-10" class="slide level1">
<h1>1c</h1>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="">class B {
    int x = 1;

    void f() {
        int y = 2;

        class A {
            void g() {
                x = y; // ?
            }
        }

        A a = new A();
        a.g();
    }
}</code></pre>
</div>
<p>Why does this compile?</p>
</section>
<section id="c-11" class="slide level1">
<h1>1c</h1>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="">class B {
    int x = 1;

    void f() {
        int y = 2;

        class A {
            void g() {
                // x = y;
                y = 3;
            }
        }

        A a = new A();
        a.g();
    }
}</code></pre>
</div>
<pre ><code class="text wrap">|  Error:
|  local variables referenced from an inner class must be final or effectively final
|                  y = 3;
|                  ^</code></pre>
</section>
<section id="c-12" class="slide level1">
<h1>1c</h1>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="">class B {
    int x = 1;

    void f() {
        int y = 2;

        class A {
            void g() {
                B.this.x = y;
            }
        }

        A a = new A();
        a.g();
    }
}</code></pre>
</div>
<p><code>x</code> is actually a field of the enclosing class B</p>
</section>
<section id="c-13" class="slide level1">
<h1>1c</h1>
<p><img data-src="6-5.svg" class="generate" style="float: right" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="5">class B {
    int x = 1;

    void f() {
        int y = 2;

        class A {
            void g() {
                x = y;
            }
        }

        A a = new A();
        a.g();
    }
}</code></pre>
<pre ><code class="java">B b = new B();
b.f();</code></pre>
</div>
</section>
<section id="c-14" class="slide level1">
<h1>1c</h1>
<p><img data-src="6-6.svg" class="generate" style="float: right" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<div style="width: 60%">
<pre ><code class="java" data-line-numbers="13">class B {
    int x = 1;

    void f() {
        int y = 2;

        class A {
            void g() {
                x = y;
            }
        }

        A a = new A();
        a.g();
    }
}</code></pre>
<pre ><code class="java">B b = new B();
b.f();</code></pre>
</div>
</section>
<section id="section-41" class="slide level1">
<h1>2</h1>
<pre ><code class="java">interface BooleanCondition&lt;T&gt; {
  boolean test(T t);
}</code></pre>
<pre ><code class="text">jshell&gt; BooleanCondition&lt;String&gt; notEmpty = new BooleanCondition&lt;&gt;()
|  Error:
|  BooleanCondition is abstract; cannot be instantiated
|  BooleanCondition&lt;String&gt; notEmpty = new BooleanCondition&lt;&gt;();
|                                      ^----------------------^</code></pre>
<p>We can provide an implementation inline:</p>
<pre ><code class="java">BooleanCondition&lt;String&gt; notEmpty = new BooleanCondition&lt;&gt;() {
    @Override
    public boolean test(String str) {
        return str.length() &gt; 0;
    }
};</code></pre>
</section>
<section id="section-42" class="slide level1">
<h1>2</h1>
<pre ><code class="java">interface Transformer&lt;T, U&gt; {
  U transform(T t);
}</code></pre>
<pre ><code class="java">Transformer&lt;String,Integer&gt; firstSpace = new Transformer&lt;&gt;() {
    @Override
    public Integer transform(String str) {
        return str.indexOf(' ');
    }
};</code></pre>
</section>
<section id="anonymous-classes" class="slide level1">
<h1>Anonymous classes</h1>
<p>We’ve gained most of the expressiveness of <span class="math inline"><em>λ</em></span></p>
<ul>
<li>Closing over environment immutably (Q1)</li>
<li>Being usable inline (Q2)</li>
</ul>
<p>Now we just need better syntax…</p>
<!--
# "Double brace initialization"

```java
List<String> animals = new ArrayList<String>() {{
  add("Dog");
  add("Cat");
}};
```

```java
class MyArrayList extends ArrayList<String> {
  { // initializer block; runs before constructor
    add("Dog");
    add("Cat");
  }
}
List<String> animals = new MyArrayList();
```

This creates a new class every time we initialize a list...
-->
</section>
<section id="section-43" class="slide level1">
<h1>3</h1>
<pre ><code class="java">Stack&lt;Integer&gt; s = Stack.getEmptyStack();
s.push(1);
s.push(2);
s.push(3);
s.head(); // 3
s.pop();
s.head(); // 2
s.pop();
s.head(); // 1
s.pop();</code></pre>
<pre ><code class="java">ImmutableStack&lt;Integer&gt; s = ImmutableStack.getEmptyStack();
s = s.push(1).push(2).push(3);
s.head();             // 3
s.pop().head();       // 2
s.pop().pop().head(); // 1
s.head();             // we can still read 3</code></pre>
</section>
<section id="section-44" class="slide level1">
<h1>3</h1>
<pre ><code class="java">public class ImmutableStack&lt;T&gt; {
    private final T head;
    private final ImmutableStack&lt;T&gt; tail;
    private final static ImmutableStack&lt;?&gt; EMPTYSTACK = 
                                  new ImmutableStack&lt;&gt;(null,null);
    
    public static &lt;T&gt; ImmutableStack&lt;T&gt; getEmptyStack(){
        @SuppressWarnings("unchecked")
        ImmutableStack&lt;T&gt; emptyStack = (ImmutableStack&lt;T&gt;) EMPTYSTACK;
        return emptyStack;
    }

    // ...
}</code></pre>
<p>What’s with <code>getEmptyStack</code>?</p>
</section>
<section id="getemptystack" class="slide level1">
<h1>getEmptyStack</h1>
<pre ><code class="text">jshell&gt; /set feedback verbose
|  Feedback mode: verbose

jshell&gt; ImmutableStack&lt;Integer&gt; i = ImmutableStack.getEmptyStack()
i ==&gt; ImmutableStack@533ddba
|  created variable i : ImmutableStack&lt;Integer&gt;

jshell&gt; ImmutableStack&lt;String&gt; s = ImmutableStack.getEmptyStack()
s ==&gt; ImmutableStack@533ddba
|  created variable s : ImmutableStack&lt;String&gt;</code></pre>
<p>We can have empty stacks of different types, depending on use</p>
</section>
<section id="mutable-pushpop" class="slide level1">
<h1>Mutable push/pop</h1>
<pre ><code class="java">public void push(T t) {
    this.tail = new Stack&lt;&gt;(this.head, this.tail);
    this.head = t;
}

public void pop() {
    if (this.tail == null) {
        throw new RuntimeException("Stack is empty");
    }
    this.head = this.tail.head();
    this.tail = this.tail.tail;
}</code></pre>
</section>
<section id="mutable-pushpop-1" class="slide level1">
<h1>Mutable push/pop</h1>
<p><img data-src="6-stack.svg" class="generate" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
</section>
<section id="mutable-pushpop-2" class="slide level1">
<h1>Mutable push/pop</h1>
<p><img data-src="6-stack-m-1.svg" class="generate" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
</section>
<section id="mutable-pushpop-3" class="slide level1">
<h1>Mutable push/pop</h1>
<p><img data-src="6-stack-m-2.svg" class="generate" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
</section>
<section id="immutable-pushpop" class="slide level1">
<h1>Immutable push/pop</h1>
<pre ><code class="java">public ImmutableStack&lt;T&gt; push(T t) {
    return new ImmutableStack&lt;&gt;(t, this);
}

public ImmutableStack&lt;T&gt; pop() {
    if (this.tail == null) {
        throw new RuntimeException("Stack is empty");
    }
    return tail;
}</code></pre>
</section>
<section id="immutable-pushpop-1" class="slide level1">
<h1>Immutable push/pop</h1>
<p><img data-src="6-stack-i-1.svg" class="generate" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
</section>
<section id="immutable-pushpop-2" class="slide level1">
<h1>Immutable push/pop</h1>
<p><img data-src="6-stack-i.svg" class="generate" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
</section>
<section id="why-make-things-immutable" class="slide level1">
<h1>Why make things immutable?</h1>
<ul>
<li>Concurrency</li>
<li>No <a href="#/c-14">aliasing</a></li>
<li>Undo for free (“persistence”)</li>
<li>Simpler reasoning (covariant!)</li>
</ul>
<p>Hopefully, fewer bugs</p>
</section>
<section id="why-not" class="slide level1">
<h1>Why not?</h1>
<ul>
<li>Efficiency
<ul>
<li>Despite sharing, <span class="math inline"><em>O</em>(<em>l</em><em>o</em><em>g</em>(<em>n</em>))</span> space overhead</li>
<li>More pressure on garbage collector</li>
<li>Chasing heap pointers doesn’t play well with processor caching</li>
</ul></li>
<li>Legacy code</li>
</ul>
</section>
<section id="recitation-7-week-9" class="slide level1">
<h1>Recitation 7 (week 9)</h1>
</section>
<section id="today-4" class="slide level1">
<h1>Today</h1>
<p>Functional programming in Java</p>
<ul>
<li>Pure functions</li>
<li>Currying</li>
<li>Tail recursion</li>
</ul>
</section>
<section id="pure-functions" class="slide level1">
<h1>Pure functions</h1>
<ul>
<li>No side effects (state, exceptions, I/O, randomness)</li>
<li>Executes predictably (deterministic)</li>
<li>Return value is identical for identical arguments (<em>referentially transparent</em>)</li>
</ul>
<p>We have more guarantees about what pure functions <em>don’t</em> do, so can freely compose, memoize, reorder, parallelize…</p>
</section>
<section id="pure-functions-1" class="slide level1">
<h1>Pure functions</h1>
<p>“But side effects are the point of writing programs!”</p>
<p>The idea is to keep most of the program pure and localize side effects.</p>
</section>
<section id="a-13" class="slide level1">
<h1>1a</h1>
<pre ><code class="java">int f(int i) {
  if (i &lt; 0) {
    throw new IllegalArgumentException();
  } else {
    return i + 1;
}</code></pre>
<p>Not pure, can throw. Exceptions don’t always compose:</p>
<pre ><code class="text wrap">jshell&gt; Function&lt;Integer, Integer&gt; f = x -&gt; { throw new Exception(); }
|  Error:
|  unreported exception java.lang.Exception; must be caught or declared to be thrown
|  Function&lt;Integer, Integer&gt; f = x -&gt; { throw new Exception(); };
|                                        ^--------------------^</code></pre>
</section>
<section id="b-10" class="slide level1">
<h1>1b</h1>
<pre ><code class="java">int g(int i) {
  System.out.println(i);
  return i + 1;
}</code></pre>
<p>Not pure, I/O. Cannot be memoized.</p>
</section>
<section id="c-15" class="slide level1">
<h1>1c</h1>
<pre ><code class="java">int h(int i) {
  return new Random().nextInt() + i;
}</code></pre>
<p>Not pure, nondeterministic. Seeded with the current system time (which also isn’t a pure function!).</p>
<p>Making the seed a parameter would make this pure.</p>
</section>
<section id="d-3" class="slide level1">
<h1>1d</h1>
<pre ><code class="java">int k(int i) {
  return Math.abs(i);
}</code></pre>
<p>Pure!</p>
</section>
<section id="section-45" class="slide level1">
<h1>2</h1>
<pre ><code class="java">x -&gt; y -&gt; z -&gt; f(x, y, z)</code></pre>
<ul>
<li>A chain of nested <em>unary</em> (single-argument) functions</li>
<li>Each successive one closes over parameters of previous ones</li>
</ul>
</section>
<section id="section-46" class="slide level1">
<h1>2</h1>
<pre ><code class="java">x -&gt; y -&gt; z -&gt; f(x, y, z)</code></pre>
<p>is short for</p>
<pre ><code class="java">new Function&lt;Integer, Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt;&gt;() {
  @Override
  public Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt; apply(Integer x) {
    return new Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt;() {
      @Override
      public Function&lt;Integer, Integer&gt; apply(Integer y) {
        return new Function&lt;Integer, Integer&gt;() {
          @Override
          public Integer apply(Integer z) {
            return f(x, y, z);
          }
        };
      }
    };
  }
}</code></pre>
</section>
<section id="section-47" class="slide level1">
<h1>2</h1>
<pre ><code class="java wrap">Transformer&lt;Integer,
  Transformer&lt;Integer,
    Transformer&lt;Integer, Integer&gt;&gt;&gt; trisum =
      x -&gt; y -&gt; z -&gt; (x + y + z);</code></pre>
<pre ><code class="java">trisum.transform(3).transform(1).transform(2)</code></pre>
<pre ><code class="text">jshell&gt; Function&lt;Integer, Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt;&gt; trisum = x -&gt; y -&gt; z -&gt; (x + y + z);
trisum ==&gt; $Lambda$27/0x0000000800b8f440@6267c3bb

jshell&gt; trisum.apply(3).apply(1).apply(2)
$2 ==&gt; 6

jshell&gt; trisum.apply(3).apply(1)
$3 ==&gt; $Lambda$29/0x0000000800b90440@3d646c37</code></pre>
<p><em>Partially-applied</em> functions are values, i.e. we can <em>specialize</em> functions for different contexts</p>
</section>
<section id="section-48" class="slide level1">
<h1>2</h1>
<pre ><code class="java">Transformer&lt;Integer,
  Transformer&lt;Integer,
    Transformer&lt;Integer, Integer&gt;&gt;&gt; trisum =
      A::transform;</code></pre>
<pre ><code class="java">class A {
  static Transformer&lt;Integer, Transformer&lt;Integer, Integer&gt;&gt;
    transform(Integer x) {
      return y -&gt; z -&gt; (x + y + z);
  }
}</code></pre>
<p>Method references are another way to name functions</p>
</section>
<section id="tail-recursion" class="slide level1">
<h1>Tail recursion</h1>
<pre ><code class="java">static long sum(long n, long result) {
    if (n == 0) {
        return result;
    } else {
        return sum(n - 1, n + result);
    }
}</code></pre>
<pre ><code class="text">jshell&gt; sum(10, 0)
$5 ==&gt; 55

jshell&gt; sum(100000, 0)
|  Exception java.lang.StackOverflowError
|        at sum (#4:4)
|        at sum (#4:4)
|        at sum (#4:4)</code></pre>
</section>
<section id="using-the-stack" class="slide level1">
<h1>Using the stack</h1>
<p><img data-src="7-stack1.svg" class="generate" style="float: right" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<div style="width: 60%">
<pre ><code class="java">static long sum(long n, long result) {
    if (n == 0) {
        return result;
    } else {
        return sum(n - 1, n + result);
    }
}</code></pre>
<pre ><code class="java">sum(10, 0);</code></pre>
</div>
</section>
<section id="using-the-stack-1" class="slide level1">
<h1>Using the stack</h1>
<p><img data-src="7-stack2.svg" class="generate" style="float: right" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<div style="width: 60%">
<pre ><code class="java">static long sum(long n, long result) {
    if (n == 0) {
        return result;
    } else {
        return sum(n - 1, n + result);
    }
}</code></pre>
<pre ><code class="java">sum(10, 0);</code></pre>
</div>
</section>
<section id="using-the-stack-2" class="slide level1">
<h1>Using the stack</h1>
<p><img data-src="7-stack3.svg" class="generate" style="float: right" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<div style="width: 60%">
<pre ><code class="java">static long sum(long n, long result) {
    if (n == 0) {
        return result;
    } else {
        return sum(n - 1, n + result);
    }
}</code></pre>
<pre ><code class="java">sum(10, 0);</code></pre>
</div>
<p>At some point, we’ll run out of stack space.</p>
<p>The problem is that the size of the stack is linear in the size of the input!</p>
</section>
<section id="using-the-heap" class="slide level1">
<h1>Using the heap?</h1>
<p>The heap typically grows much larger than the stack.</p>
<pre ><code class="java">jshell&gt; Runtime.getRuntime().maxMemory() / 1024 / 1024
$1 ==&gt; 4096</code></pre>
<p>On my computer, the default heap size is 4 GB (¼ physical memory), while the default stack size is <a href="https://github.com/openjdk/jdk/blob/master/src/hotspot/os_cpu/bsd_x86/globals_bsd_x86.hpp">1 MB</a> (macOS).</p>
</section>
<section id="compute" class="slide level1">
<h1>Compute</h1>
<p>Idea: represent an in-progress recursive computation as a (heap) object!</p>
<p>We just have to ensure that it captures enough information to resume the computation.</p>
<p>While overflow is still possible, it’s much less likely.</p>
</section>
<section id="compute-1" class="slide level1">
<h1>Compute</h1>
<pre ><code class="java" data-line-numbers="1">static long sum(long n, long result) {
    if (n == 0) {
        return result;
    } else {
        return sum(n - 1, n + result);
    }
}</code></pre>
<pre ><code class="java" data-line-numbers="1">static Compute&lt;Long&gt; sum(long n, long result) {
    if (n == 0) {
        return new Base&lt;&gt;(() -&gt; result);
    } else {
        return new Recursive&lt;&gt;(() -&gt; sum(n - 1, n + result));
    }
}</code></pre>
</section>
<section id="compute-2" class="slide level1">
<h1>Compute</h1>
<pre ><code class="java" data-line-numbers="3">static long sum(long n, long result) {
    if (n == 0) {
        return result;
    } else {
        return sum(n - 1, n + result);
    }
}</code></pre>
<pre ><code class="java" data-line-numbers="3">static Compute&lt;Long&gt; sum(long n, long result) {
    if (n == 0) {
        return new Base&lt;&gt;(() -&gt; result);
    } else {
        return new Recursive&lt;&gt;(() -&gt; sum(n - 1, n + result));
    }
}</code></pre>
</section>
<section id="compute-3" class="slide level1">
<h1>Compute</h1>
<pre ><code class="java" data-line-numbers="5">static long sum(long n, long result) {
    if (n == 0) {
        return result;
    } else {
        return sum(n - 1, n + result);
    }
}</code></pre>
<pre ><code class="java" data-line-numbers="5">static Compute&lt;Long&gt; sum(long n, long result) {
    if (n == 0) {
        return new Base&lt;&gt;(() -&gt; result);
    } else {
        return new Recursive&lt;&gt;(() -&gt; sum(n - 1, n + result));
    }
}</code></pre>
</section>
<section id="compute-4" class="slide level1">
<h1>Compute</h1>
<pre ><code class="java" data-line-numbers="*">static long sum(long n, long result) {
    if (n == 0) {
        return result;
    } else {
        return sum(n - 1, n + result);
    }
}</code></pre>
<pre ><code class="java" data-line-numbers="*">static Compute&lt;Long&gt; sum(long n, long result) {
    if (n == 0) {
        return new Base&lt;&gt;(() -&gt; result);
    } else {
        return new Recursive&lt;&gt;(() -&gt; sum(n - 1, n + result));
    }
}</code></pre>
</section>
<section id="driving-compute" class="slide level1">
<h1>Driving Compute</h1>
<pre ><code class="java">static long summer(long n) {
    Compute&lt;Long&gt; result = sum(n, 0);

    while (result.isRecursive()) {
        result = result.recurse();
    }

    return result.evaluate();
}</code></pre>
</section>
<section id="using-the-heap-1" class="slide level1">
<h1>Using the heap</h1>
<pre ><code class="java">static long summer(long n) {
    Compute&lt;Long&gt; result = sum(n, 0);

    while (result.isRecursive()) {
        result = result.recurse();
    }

    return result.evaluate();
}</code></pre>
<p><img data-src="7-stack4-1.svg" class="generate center" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<p><code>Recursive</code> contains…</p>
</section>
<section id="using-the-heap-2" class="slide level1">
<h1>Using the heap</h1>
<pre ><code class="java">static Compute&lt;Long&gt; sum(long n, long result) {
    if (n == 0) {
        return new Base&lt;&gt;(() -&gt; result);
    } else {
        return new Recursive&lt;&gt;(() -&gt; sum(n - 1, n + result));
    }
}</code></pre>
<p><img data-src="7-stack4.svg" class="generate center" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<p>… the next step of the computation (as a Producer), which has captured the expressions it needs.</p>
</section>
<section id="using-the-heap-3" class="slide level1">
<h1>Using the heap</h1>
<pre ><code class="java">static Compute&lt;Long&gt; sum(long n, long result) {
    if (n == 0) {
        return new Base&lt;&gt;(() -&gt; result);
    } else {
        return new Recursive&lt;&gt;(() -&gt; sum(n - 1, n + result));
    }
}</code></pre>
<p><img data-src="7-stack4-2.svg" class="generate center" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<p><code>summer</code> resumes the computation, loading the captured expressions back onto the stack via the parameters of <code>sum</code>…</p>
</section>
<section id="using-the-heap-4" class="slide level1">
<h1>Using the heap</h1>
<pre ><code class="java">static Compute&lt;Long&gt; sum(long n, long result) {
    if (n == 0) {
        return new Base&lt;&gt;(() -&gt; result);
    } else {
        return new Recursive&lt;&gt;(() -&gt; sum(n - 1, n + result));
    }
}</code></pre>
<p><img data-src="7-stack5.svg" class="generate center" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<p>… to create the <em>next</em> step.</p>
</section>
<section id="using-the-heap-5" class="slide level1">
<h1>Using the heap</h1>
<pre ><code class="java">static Compute&lt;Long&gt; sum(long n, long result) {
    if (n == 0) {
        return new Base&lt;&gt;(() -&gt; result);
    } else {
        return new Recursive&lt;&gt;(() -&gt; sum(n - 1, n + result));
    }
}</code></pre>
<p><img data-src="7-stack5-1.svg" class="generate center" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<p>Only one stack frame is ever used…</p>
</section>
<section id="using-the-heap-6" class="slide level1">
<h1>Using the heap</h1>
<pre ><code class="java">static Compute&lt;Long&gt; sum(long n, long result) {
    if (n == 0) {
        return new Base&lt;&gt;(() -&gt; result);
    } else {
        return new Recursive&lt;&gt;(() -&gt; sum(n - 1, n + result));
    }
}</code></pre>
<p><img data-src="7-stack6.svg" class="generate center" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<p>… but the heap grows linearly.</p>
</section>
<section id="trampolining" class="slide level1">
<h1>Trampolining</h1>
<p>A <em>tail call</em> is a recursive call as the last thing a function does (no <em>deferred operations</em>).</p>
<p><em>Tail call optimization</em> makes it so tail calls don’t consume extra stack space.</p>
<p><em>Trampolining</em> is a way to have this in languages without TCO.</p>
<p><a href="https://en.wikipedia.org/wiki/Tail_call#Through_trampolining" class="credit">https://en.wikipedia.org/wiki/Tail_call#Through_trampolining</a></p>
</section>
<section id="compute-5" class="slide level1">
<h1>Compute</h1>
<pre ><code class="java">public interface Compute&lt;T&gt; {
    public boolean isRecursive();

    public Compute&lt;T&gt; recurse();

    public T evaluate();
}</code></pre>
</section>
<section id="base" class="slide level1">
<h1>Base</h1>
<pre ><code class="java">public class Base&lt;T&gt; implements Compute&lt;T&gt; {
    private Producer&lt;T&gt; producer;

    public Base(Producer&lt;T&gt; producer) {
       this.producer = producer;
    }

    public boolean isRecursive() {
       return false;
    }

    public T evaluate() {
       return producer.produce();
    }

    public Compute&lt;T&gt; recurse() { 
       throw new IllegalStateException("Invalid recursive call in base case");
    }

}</code></pre>
</section>
<section id="recursive" class="slide level1">
<h1>Recursive</h1>
<pre ><code class="java">public class Recursive&lt;T&gt; implements Compute&lt;T&gt; {
    private Producer&lt;Compute&lt;T&gt;&gt; producer;

    public Recursive(Producer&lt;Compute&lt;T&gt;&gt; producer) {
       this.producer = producer;
    }

    public boolean isRecursive() {
       return true;
    }

    public Compute&lt;T&gt; recurse() {
       return producer.produce();
    }

    public T evaluate() {
       throw new IllegalStateException("Invalid evaluation in recursive case");
    }
}</code></pre>
</section>
<section id="main" class="slide level1">
<h1>Main</h1>
<pre ><code class="java">import java.util.Scanner;

class Main {
    static long summer(long n) {
      // ...
    }

    static Compute&lt;Long&gt; sum(long n, long result) {
      // ...
    }

    public static void main(String[] args) {
        System.out.println(summer(new Scanner(System.in).nextLong()));
    }
}</code></pre>
<p>This is an example of <a href="#/pure-functions-1">localizing side effects</a>.</p>
</section>
<section id="factorial" class="slide level1">
<h1>Factorial</h1>
<pre ><code class="java">import java.util.Scanner;

class Main {
    static Compute&lt;Long&gt; fact(long n, long result) {
        if (n == 0) {
            return new Base&lt;&gt;(() -&gt; result);
        } else {
            return new Recursive&lt;&gt;(() -&gt; fact(n - 1, n * result));
        }
    }

    public static void main(String[] args) {
        // ...
    }
}</code></pre>
</section>
<section id="recitation-8-week-10" class="slide level1">
<h1>Recitation 8 (week 10)</h1>
</section>
<section id="today-5" class="slide level1">
<h1>Today</h1>
<ul>
<li>Infinite lists and streams</li>
<li>Primitive specialization</li>
<li>Programming with streams</li>
<li><code>flatMap</code></li>
</ul>
</section>
<section id="infinite-lists" class="slide level1">
<h1>Infinite lists</h1>
<pre ><code class="java">class InfiniteList&lt;T&gt; {
  private Producer&lt;T&gt; head;
  private Producer&lt;InfiniteList&lt;T&gt;&gt; tail;

  public T head() {
    return this.head.produce();
  }

  public InfiniteList&lt;T&gt; tail() {
    return this.tail.produce();
  }

  // ...
}</code></pre>
<!--
  public InfiniteList(Producer<T> head,
                      Producer<InfiniteList<T>> tail) {
    this.head = head;
    this.tail = tail;
  }

-->
<p>aka CS1101S “streams”… with lazy <code>head</code>, and without the empty stream</p>
<!-- so no computation is done at all until forced, not even for the first element -->
</section>
<section id="a-14" class="slide level1">
<h1>1a</h1>
<pre ><code class="java">InfiniteList&lt;Integer&gt; fib(int a, int b) {
  return new InfiniteList&lt;&gt;(() -&gt; a, () -&gt; fib(b, a + b));
}</code></pre>
<pre ><code class="text">jshell&gt; fib(1, 1).tail().tail().tail().tail().head()
$12 ==&gt; 5</code></pre>
<p>The parameters maintain enough state across the stream to compute the current element <code>a</code> and the next state <code>(b, a + b)</code>.</p>
</section>
<section id="b-11" class="slide level1">
<h1>1b</h1>
<pre ><code class="java">int fibonacci(int n) {
    InfiniteList&lt;Integer&gt; il = fib(1, 1);

    for (int i = 0; i &lt; n; i++) {
        il = il.tail();
    }
    return il.head();
}</code></pre>
<pre ><code class="text">jshell&gt; fibonacci(5)
$14 ==&gt; 8

jshell&gt; fibonacci(9)
$15 ==&gt; 55</code></pre>
<p>Is <code>fibonacci</code> is a pure function?</p>
</section>
<section id="c-16" class="slide level1">
<h1>1c</h1>
<pre ><code class="java">class Pair&lt;T&gt; {
    T a;
    T b;

    Pair(T a, T b) {
        this.a = a;
        this.b = b;
    }
}</code></pre>
</section>
<section id="c-17" class="slide level1">
<h1>1c</h1>
<pre ><code class="java">// Returns a Stream.of(seed, f(seed), f(f(seed)), ...)
static &lt;T&gt; Stream&lt;T&gt; iterate​(T seed, UnaryOperator&lt;T&gt; f)</code></pre>
<pre ><code class="java">@FunctionalInterface
public interface UnaryOperator&lt;T&gt; extends Function&lt;T,​ T&gt; { ... }</code></pre>
<p>We’ll let <code>seed</code> contain the state as a <code>Pair</code>.</p>
<p><code>seed.a</code> is the current element and <code>f(seed)</code> will compute the next state.</p>
</section>
<section id="c-18" class="slide level1">
<h1>1c</h1>
<pre ><code class="java">Stream&lt;Integer&gt; fibonacci(int n) {
    return Stream.iterate(
        new Pair&lt;&gt;(1, 1),
        s -&gt; new Pair&lt;&gt;(s.b, s.a + s.b))
      .map(s -&gt; s.a)
      .limit(n);
}</code></pre>
<pre ><code class="text">jshell&gt; fibonacci(10).collect(Collectors.toList())
$18 ==&gt; [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</code></pre>
<p>Compare with:</p>
<pre ><code class="java">InfiniteList&lt;Integer&gt; fib(int a, int b) {
  return new InfiniteList&lt;&gt;(() -&gt; a, () -&gt; fib(b, a + b));
}</code></pre>
<pre ><code class="text">jshell&gt; fib(1, 1).tail().tail().tail().tail().head()
$12 ==&gt; 5</code></pre>
</section>
<section id="primitive-specialization" class="slide level1">
<h1>Primitive specialization</h1>
<p><code>int[]</code> and <code>ArrayList&lt;Integer&gt;</code> have different memory representations due to boxing.</p>
<p><img data-src="8-intstream1.svg" class="generate" style="float: right;" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<p><img data-src="8-intstream2.svg" class="generate" style="float: right;" data-cmd="$extras/stack-heap.py | dot -Tsvg -o $out" alt="" /></p>
<p><code>IntStream</code> and <code>Stream&lt;Integer&gt;</code> have a similar relationship.</p>
</section>
<section id="section-49" class="slide level1">
<h1>2</h1>
<p>The <span class="math inline"><em>i</em><sup><em>t</em><em>h</em></sup></span> omega number is the number of distinct prime factors for <span class="math inline"><em>i</em></span>.</p>
<p><code>omega(n)</code> returns the first <code>n</code> omega numbers.</p>
<pre ><code class="java">LongStream omega(int n) {
    return IntStream
        .range(1, n + 1)
        .mapToLong(i -&gt; primeFactorsOf(i).count());
}</code></pre>
<!-- correspondence with mathematical functions -->
</section>
<section id="section-50" class="slide level1">
<h1>2</h1>
<pre ><code class="java">IntStream primeFactorsOf(int x) {
    return factors(x)
        .filter(d -&gt; isPrime(d));
}</code></pre>
<pre ><code class="java">IntStream factors(int x) {
    return IntStream
        .rangeClosed(2, x)
        .filter(d -&gt; x % d == 0); // trial division
}</code></pre>
<pre ><code class="java">boolean isPrime(int n); // given</code></pre>
<pre ><code class="text">jshell&gt; omega(10).toArray()
$27 ==&gt; long[10] { 0, 1, 1, 1, 1, 2, 1, 1, 1, 2 }</code></pre>
</section>
<section id="section-51" class="slide level1">
<h1>3</h1>
<pre ><code class="java">public static &lt;T, U, R&gt; Stream&lt;R&gt; product(
        List&lt;T&gt; list1,
        List&lt;U&gt; list2,
        BiFunction&lt;T, U, R&gt; f)</code></pre>
<p>Given two lists, computes cartesian product of elements and returns a stream.</p>
<ul>
<li>The first list contains <code>T</code>s, the second contains <code>U</code>s</li>
<li><code>R</code> is the type of <code>f(T, U)</code></li>
</ul>
</section>
<section id="section-52" class="slide level1">
<h1>3</h1>
<pre ><code class="java">public static &lt;T, U, R&gt; Stream&lt;R&gt; product(
        List&lt;? extends T&gt; list1,
        List&lt;? extends U&gt; list2,
        BiFunction&lt;? super T, ? super U, R&gt; f)</code></pre>
<p>Given two lists, computes cartesian product of elements and returns a stream.</p>
<ul>
<li>The first list contains <code>T</code>s, the second contains <code>U</code>s</li>
<li><code>R</code> is the type of <code>f(T, U)</code></li>
<li>We only read from the lists (<u>PE</u>CS) and pass things into <code>f</code> (PE<u>CS</u>)</li>
</ul>
<p>What should the constraint of <code>R</code> be?</p>
</section>
<section id="section-53" class="slide level1">
<h1>3</h1>
<pre ><code class="java">public static &lt;T, U, R&gt; Stream&lt;R&gt; product(
        List&lt;? extends T&gt; list1,
        List&lt;? extends U&gt; list2,
        BiFunction&lt;? super T, ? super U, ? extends R&gt; f) {

    return list1.stream()
        .flatMap(x -&gt; list2.stream()
                .map(y -&gt; f.apply(x,y)));
}</code></pre>
<pre ><code class="text">jshell&gt; product(List.of(1,2,3,4), List.of("A","B"), (str1, str2) -&gt; str1 + str2).collect(Collectors.toList())
$5 ==&gt; [1A, 1B, 2A, 2B, 3A, 3B, 4A, 4B]</code></pre>
<p>Why do we need <code>flatMap</code>? Why not <code>map</code>?</p>
</section>
<section id="section-54" class="slide level1">
<h1>3</h1>
<pre ><code class="java">public static &lt;T, U, R&gt; Stream&lt;Stream&lt;R&gt;&gt; product(
        List&lt;? extends T&gt; list1,
        List&lt;? extends U&gt; list2,
        BiFunction&lt;? super T, ? super U, ? extends R&gt; f) {

    return list1.stream()
        .map(x -&gt; list2.stream()
                .map(y -&gt; f.apply(x,y)));
}</code></pre>
<pre ><code class="text">jshell&gt; product(List.of(1,2,3,4), List.of("A","B"), (str1, str2) -&gt; str1 + str2).map(s -&gt; s.collect(Collectors.toList())).collect(Collectors.toList())
$8 ==&gt; [[1A, 1B], [2A, 2B], [3A, 3B], [4A, 4B]]</code></pre>
<p>If we used <code>map</code>.</p>
<p>What if we have 3 lists – where would the <code>flatMaps</code> go?</p>
</section>
<section id="flatmap" class="slide level1">
<h1><code>flatMap</code></h1>
<p>Operationally, <code>map</code>, then flatten, so types match.</p>
<p>Like <code>accumulate</code>, we can change the structure of the thing we’re mapping over – we can implement both <code>map</code> and <code>filter</code> with it.</p>
<p>Lots of other types support <code>flatMap</code>-like operations.</p>
<p><a href="https://en.paqmind.com/blog/reduce-is-flatmap" class="credit">https://en.paqmind.com/blog/reduce-is-flatmap</a></p>
</section>
<section id="recitation-9-week-11" class="slide level1">
<h1>Recitation 9 (week 11)</h1>
</section>
<section id="today-6" class="slide level1">
<h1>Today</h1>
<ul>
<li>Monads, functors, and laws</li>
<li>Parallel streams</li>
</ul>
</section>
<section id="monads" class="slide level1">
<h1>Monads?!</h1>
<p>How did we get here?</p>
</section>
<section id="recap-1" class="slide level1">
<h1>Recap</h1>
<ul>
<li>Functional programming redux
<ul>
<li>Immutability</li>
<li>Lambda expressions</li>
<li>Laziness</li>
</ul></li>
<li>Some common types
<ul>
<li><code>Maybe</code>, <code>InfiniteList</code>, <code>Loggable</code></li>
<li>Today: at some abstract level, all of these are the same thing<span class="math inline">*</span>!</li>
</ul></li>
</ul>
<div class="credit">
<p><span class="math inline">*</span> <em>they implement a common interface</em></p>
</div>
</section>
<section id="monads-1" class="slide level1">
<h1>Monads</h1>
<ul>
<li>Interface: <code>of</code> and <code>flatMap</code></li>
<li><a href="https://maciejpirog.github.io/fishy/">Laws</a>
<ul>
<li>Right/left identity</li>
<li>Associative</li>
</ul></li>
</ul>
<p>This definition is always safe to fall back on.</p>
</section>
<section id="monads-2" class="slide level1">
<h1>Monads</h1>
<p>The definition is simple but opaque, so:</p>
<ul>
<li>What is a monad, intuitively?</li>
<li>Why are the laws needed?</li>
<li>What are some examples of monads and what do they represent?</li>
<li>Why is this interface useful?</li>
</ul>
</section>
<section id="intuition" class="slide level1">
<h1>Intuition</h1>
<p>Monads are an <em>encoding</em> of <em>computations with side effects</em> using pure functions.</p>
<p>The laws are just sanity checks that composing computations behaves as we would expect.</p>
</section>
<section id="intuition-1" class="slide level1">
<h1>Intuition</h1>
<p><code>flatMap</code> is a very abstract <code>;</code></p>
<p>Compare:</p>
<pre ><code class="java">Loggable.of(1).flatMap(a -&gt;
  Loggable.of(2).flatMap(b -&gt;
    new Loggable&lt;&gt;(a + 1, "the value of a was " + a)))</code></pre>
<pre ><code class="java">int a = 1;
int b = 2;
System.out.println("the value of a was " + a);
return a + 1;</code></pre>
</section>
<section id="intuition-2" class="slide level1">
<h1>Intuition</h1>
<p><code>flatMap</code> is a very abstract <code>;</code></p>
<p>Compare:</p>
<pre ><code class="java">Maybe.some(1).flatMap(a -&gt;
  Maybe.some(a + 1)).flatMap(b -&gt;
    Maybe.none()).flatMap(c -&gt;
      Maybe.some(2))</code></pre>
<pre ><code class="java">int a = 1;
int b = a + 1;
throw new Exception();
int c = null;
return 2;</code></pre>
<p>The former is a <em>value</em> instead of a block of code</p>
</section>
<section id="why" class="slide level1">
<h1>Why?</h1>
<p>In Java, this seems a little pointless. Don’t we already have side effects built-in?</p>
<pre ><code class="java">int a = 1;
System.out.println(a);
a = a / 0; // throws ArithmeticException</code></pre>
</section>
<section id="why-1" class="slide level1">
<h1>Why</h1>
<p>Monads are great for writing <em>libraries</em> that are structured as mini-languages with side effects. We know they’ll compose nicely because of the laws.</p>
<ul>
<li><code>Loggable</code>: computations which log something as a side effect (I/O, kind of)</li>
<li><code>Maybe</code>: computations which may fail halfway (exceptions)</li>
</ul>
</section>
<section id="why-2" class="slide level1">
<h1>Why</h1>
<p>Monads are great for writing <em>libraries</em> that are structured as mini-languages with side effects. We know they’ll compose nicely because of the laws.</p>
<ul>
<li><code>InfiniteList</code>: computations which return many possible values (backtracking)</li>
</ul>
<p>Counting change, <code>permutations</code>…</p>
</section>
<section id="why-3" class="slide level1">
<h1>Why</h1>
<p>A few others:</p>
<ul>
<li>State: computations with mutation</li>
<li>Promises: computations which finish later</li>
</ul>
<!-- intentionally not mentioning random and reader and cont -->
<p>With the monad interface, we can write a <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html">library of functions</a> which work for these computations.</p>
</section>
<section id="functor" class="slide level1">
<h1>Functor</h1>
<p>Things which can be mapped over without changing their structure.</p>
<ul>
<li>Interface: <code>map</code></li>
<li>Laws: identity, composition</li>
</ul>
<p>A monad <em>is a</em> functor.</p>
<p>LSP: a monad should not violate <del>properties</del> <strong>laws</strong> expected to hold of functors!</p>
</section>
<section id="section-55" class="slide level1">
<h1>1</h1>
<p>What does complying with the laws look like?</p>
<p>Approach:</p>
<ol type="1">
<li>Specialize each law to the given type</li>
<li>Think of some counterexample (values of <code>x</code> and <code>f</code>) which shows that the law does <em>not</em> hold</li>
</ol>
<p>(To show that the law holds, we’d have to show it for all values of <code>x</code> and <code>f</code>, i.e. prove it)</p>
</section>
<section id="section-56" class="slide level1">
<h1>1</h1>
<p>Left Identity:</p>
<p><code>Monad.of(x).flatMap(y -&gt; f(y))</code> <span class="math inline">≡</span> <code>f(x)</code></p>
<pre ><code class="text">jshell&gt; Maybe.&lt;Integer&gt;some(null).flatMap(y -&gt; bar(y))
$12 ==&gt; null

jshell&gt; bar(null)
$13 ==&gt; null</code></pre>
<p>Law-abiding! (for this choice of value)</p>
</section>
<section id="section-57" class="slide level1">
<h1>1</h1>
<p>Left Identity:</p>
<p><code>Monad.of(x).flatMap(y -&gt; f(y))</code> <span class="math inline">≡</span> <code>f(x)</code></p>
<pre ><code class="text">jshell&gt; Optional.&lt;Integer&gt;ofNullable(null).flatMap(y -&gt; foo(y))
$14 ==&gt; Optional.empty

jshell&gt; foo(null)
$15 ==&gt; null</code></pre>
<p>Violated, wrapping then applying is different from just applying!</p>
</section>
<section id="section-58" class="slide level1">
<h1>1</h1>
<p>Right Identity:</p>
<p><code>monad.flatMap(y -&gt; Monad.of(y))</code> <span class="math inline">≡</span> <code>monad</code></p>
<pre ><code class="text">jshell&gt; Maybe&lt;Integer&gt; monad = Maybe.&lt;Integer&gt;some(null)
monad ==&gt; [null]

jshell&gt; monad.flatMap(y -&gt; Maybe.&lt;Integer&gt;some(y))
$18 ==&gt; [null]</code></pre>
<p>This is fine</p>
</section>
<section id="section-59" class="slide level1">
<h1>1</h1>
<p>Right Identity:</p>
<p><code>monad.flatMap(y -&gt; Monad.of(y))</code> <span class="math inline">≡</span> <code>monad</code></p>
<pre ><code class="text">jshell&gt; Optional&lt;Integer&gt; monad = Optional.&lt;Integer&gt;ofNullable(null)
monad ==&gt; Optional.empty

jshell&gt; monad.flatMap(y -&gt; Optional.&lt;Integer&gt;ofNullable(y))
$21 ==&gt; Optional.empty</code></pre>
<p>Also fine</p>
</section>
<section id="section-60" class="slide level1">
<h1>1</h1>
<p>Associative:</p>
<div style="font-size: 0.8em">
<p><code>monad.flatMap(x -&gt; f(x)).flatMap(x -&gt; g(x))</code> <span class="math inline">≡</span> <code>monad.flatMap(x -&gt; f(x).flatMap(x -&gt; g(x)))</code></p>
</div>
<pre ><code class="text">jshell&gt; Maybe&lt;Integer&gt; monad = Maybe.&lt;Integer&gt;some(5)
monad ==&gt; [5]

jshell&gt; monad.flatMap(x -&gt; bar(x)).flatMap(y -&gt; bar(y))
$24 ==&gt; [20]

jshell&gt; monad.flatMap(x -&gt; bar(x).flatMap(y -&gt; bar(y)))
$25 ==&gt; [20]</code></pre>
<p>Fine</p>
</section>
<section id="section-61" class="slide level1">
<h1>1</h1>
<p>Associative:</p>
<div style="font-size: 0.8em">
<p><code>monad.flatMap(x -&gt; f(x)).flatMap(x -&gt; g(x))</code> <span class="math inline">≡</span> <code>monad.flatMap(x -&gt; f(x).flatMap(x -&gt; g(x)))</code></p>
</div>
<pre ><code class="text">jshell&gt; Optional&lt;Integer&gt; monad = Optional.&lt;Integer&gt;ofNullable(5)
monad ==&gt; Optional[5]

jshell&gt; monad.flatMap(x -&gt; foo(x)).flatMap(y -&gt; foo(y))
$27 ==&gt; Optional[20]

jshell&gt; monad.flatMap(x -&gt; foo(x).flatMap(y -&gt; foo(y)))
$28 ==&gt; Optional[20]</code></pre>
<p>Fine</p>
</section>
<section id="section-62" class="slide level1">
<h1>1</h1>
<p>Functor identity:</p>
<p><code>functor.map(x -&gt; x)</code> <span class="math inline">≡</span> <code>functor</code></p>
<pre ><code class="text">jshell&gt; Maybe&lt;Integer&gt; functor = Maybe.&lt;Integer&gt;some(5)
functor ==&gt; [5]

jshell&gt; functor.map(x -&gt; x)
$30 ==&gt; [5]</code></pre>
<p>Fine</p>
</section>
<section id="section-63" class="slide level1">
<h1>1</h1>
<p>Functor identity:</p>
<p><code>functor.map(x -&gt; x)</code> <span class="math inline">≡</span> <code>functor</code></p>
<pre ><code class="text">jshell&gt; Optional&lt;Integer&gt; functor = Optional.&lt;Integer&gt;ofNullable(5)
functor ==&gt; Optional[5]

jshell&gt; functor.map(y -&gt; y)
$32 ==&gt; Optional[5]</code></pre>
<p>Fine</p>
</section>
<section id="section-64" class="slide level1">
<h1>1</h1>
<p>Functor composition:</p>
<p><code>functor.map(x -&gt; f(x)).map(x -&gt; g(x))</code> <span class="math inline">≡</span> <code>functor.map(x -&gt; g(f(x))</code></p>
<pre ><code class="java">Integer foo(Integer x) {
  if (x == null) {
    return 0;
  } 
  return null;
}</code></pre>
<p>Here’s our counterexample</p>
</section>
<section id="section-65" class="slide level1">
<h1>1</h1>
<p>Functor composition:</p>
<p><code>functor.map(x -&gt; f(x)).map(x -&gt; g(x))</code> <span class="math inline">≡</span> <code>functor.map(x -&gt; g(f(x))</code></p>
<pre ><code class="text">jshell&gt; Maybe.of(0).map(x -&gt; foo(x)).map(x -&gt; foo(x))
$34 ==&gt; [0]

jshell&gt; Maybe.of(0).map(x -&gt; foo(foo(x)))
$35 ==&gt; [0]</code></pre>
<p>Fine</p>
</section>
<section id="section-66" class="slide level1">
<h1>1</h1>
<p>Functor composition:</p>
<p><code>functor.map(x -&gt; f(x)).map(x -&gt; g(x))</code> <span class="math inline">≡</span> <code>functor.map(x -&gt; g(f(x))</code></p>
<pre ><code class="text">jshell&gt; Optional.ofNullable(0).map(x -&gt; foo(x)).map(x -&gt; foo(x))
$36 ==&gt; Optional.empty

jshell&gt; Optional.ofNullable(0).map(x -&gt; foo(foo(x)))
$37 ==&gt; Optional[0]</code></pre>
<p>Violated</p>
</section>
<section id="conclusions" class="slide level1">
<h1>Conclusions</h1>
<p><code>Maybe</code> is a monad and functor, <code>Optional</code> is neither.</p>
<p>The root cause of the problem is</p>
<pre ><code class="java">Optional.ofNullable(null) == Optional.empty</code></pre>
<p>but avoiding null is the point of <code>Optional</code>.</p>
<p><a href="https://www.sitepoint.com/how-optional-breaks-the-monad-laws-and-why-it-matters/" class="credit small">https://www.sitepoint.com/how-optional-breaks-the-monad-laws-and-why-it-matters/</a></p>
</section>
<section id="section-67" class="slide level1">
<h1>2</h1>
<pre ><code class="java">Stream.of(1, 2, 3, 4)
  .reduce(0, (result, x) -&gt; result * 2 + x);</code></pre>
<p>What happens if this is run in parallel?</p>
</section>
<section id="section-68" class="slide level1">
<h1>2</h1>
<pre ><code class="java">Stream.of(1, 2, 3, 4)
  .reduce(0, (result, x) -&gt; {
    System.out.printf("%d * 2 + %d = %d\n",
      result, x, result * 2 + x);
    return result * 2 + x;
  });</code></pre>
<pre ><code class="text">0 * 2 + 1 = 1
1 * 2 + 2 = 4
4 * 2 + 3 = 11
11 * 2 + 4 = 26
$51 ==&gt; 26</code></pre>
</section>
<section id="section-69" class="slide level1">
<h1>2</h1>
<p><img data-src="9-g1.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
</section>
<section id="section-70" class="slide level1">
<h1>2</h1>
<pre ><code class="java">Stream.of(1, 2, 3, 4).parallel()
  .reduce(0, (result, x) -&gt; {
    System.out.printf("%d * 2 + %d = %d\n",
      result, x, result * 2 + x);
    return result * 2 + x;
  });</code></pre>
<pre ><code class="text">0 * 2 + 3 = 3
0 * 2 + 1 = 1
0 * 2 + 2 = 2
0 * 2 + 4 = 4   // all elements reduced with identity value
3 * 2 + 4 = 10  // reduce 3 and 4
1 * 2 + 2 = 4   // reduce 1 and 2
4 * 2 + 10 = 18 // reduce 4 and 10
$52 ==&gt; 18</code></pre>
<p><code>result * 2 + x</code> is not associative</p>
<p>(order of reduction matters)</p>
</section>
<section id="section-71" class="slide level1">
<h1>2</h1>
<p><img data-src="9-g2.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
</section>
<section id="section-72" class="slide level1">
<h1>3</h1>
<pre ><code class="text">fib(n + 2) = fib(n + 1) + fib(n)
fib(n + 3) = fib(n + 1) + fib(n + 2)
fib(n + 4) = fib(n + 2) + fib(n + 3)
fib(n + 5) = fib(n + 3) + fib(n + 4)
fib(n + 6) = fib(n + 4) + fib(n + 5)</code></pre>
</section>
<section id="section-73" class="slide level1">
<h1>3</h1>
<pre ><code class="text">fib(n + 2) = fib(n + 1) + fib(n)
fib(n + 3) = fib(n + 1) + fib(n + 2) = fib(n + 1) * 2 + fib(n)
fib(n + 4) = fib(n + 2) + fib(n + 3)
fib(n + 5) = fib(n + 3) + fib(n + 4)
fib(n + 6) = fib(n + 4) + fib(n + 5)</code></pre>
</section>
<section id="section-74" class="slide level1">
<h1>3</h1>
<pre ><code class="text">fib(n + 2) = fib(n + 1) + fib(n)
fib(n + 3) = fib(n + 1) + fib(n + 2) = fib(n + 1) * 2 + fib(n)
fib(n + 4) = fib(n + 2) + fib(n + 3) = fib(n + 1) * 3 + fib(n) * 2
fib(n + 5) = fib(n + 3) + fib(n + 4) = fib(n + 1) * 5 + fib(n) * 3
fib(n + 6) = fib(n + 4) + fib(n + 5) = fib(n + 1) * 8 + fib(n) * 5</code></pre>
</section>
<section id="section-75" class="slide level1">
<h1>3</h1>
<pre ><code class="text">fib(n + 2) = fib(n + 1) + fib(n)
fib(n + 3) = fib(n + 1) * 2 + fib(n)
fib(n + 4) = fib(n + 1) * 3 + fib(n) * 2
fib(n + 5) = fib(n + 1) * 5 + fib(n) * 3
fib(n + 6) = fib(n + 1) * 8 + fib(n) * 5</code></pre>
</section>
<section id="section-76" class="slide level1">
<h1>3</h1>
<pre ><code class="text">fib(n + 2) = fib(n + 1)          + fib(n)
fib(n + 3) = fib(n + 1) * 2      + fib(n)
fib(n + 4) = fib(n + 1) * 3      + fib(n) * 2
fib(n + 5) = fib(n + 1) * 5      + fib(n) * 3
fib(n + 6) = fib(n + 1) * 8      + fib(n) * 5</code></pre>
<pre ><code class="text">fib(n + k) = fib(n + 1) * fib(k) + fib(n) * fib(k - 1)</code></pre>
<p>Given the first <code>k</code> Fibonacci numbers, we can compute the next <code>k</code> in parallel, i.e. the <code>(n + k)</code>th number doesn’t depend on <code>fib(n + k - 1)</code>.</p>
</section>
<section id="section-77" class="slide level1">
<h1>3</h1>
<pre ><code class="java">static BigInteger findFibTerm(int n) {
    List&lt;BigInteger&gt; fibList = new ArrayList&lt;&gt;();
    fibList.add(BigInteger.ONE);
    fibList.add(BigInteger.ONE);

    while (fibList.size() &lt; n) {
        generateFib(fibList);
    }
    return fibList.get(n-1);
}</code></pre>
</section>
<section id="a-15" class="slide level1">
<h1>3a</h1>
<pre ><code class="java">static void generateFib(List&lt;BigInteger&gt; fibs) {
    // k is constant
    int k = fibs.size();
    fibs.addAll(Stream
            // n goes from 0 to k-1
            .iterate(0, n -&gt; n &lt; k - 1, n -&gt; n + 1).parallel()
            .map(n -&gt;
                // 0-indexed
                fibs.get(n+1).multiply(fibs.get(k-1)).add(
                    fibs.get(n).multiply(fibs.get(k-2))))
            .collect(Collectors.toList()));
}</code></pre>
<pre ><code class="text">fib(n + k) = fib(n + 1) * fib(k) + fib(n) * fib(k - 1)</code></pre>
<!--
digraph G {
    

    node [shape=none];
    n1 [label="1"]
    n2 [label="1"]
    n3 [label="2"]
    n4 [label="3"]
    
    {rank=same; n1 n2 n3 n4}
    n1 -> n2 -> n3 -> n4 [style="invis"];
    n1 -> n3;
  
}

-->
</section>
<section id="b-12" class="slide level1">
<h1>3b</h1>
<pre ><code class="java">static BigInteger findFibTerm(int n) {
    List&lt;BigInteger&gt; fibList = new ArrayList&lt;&gt;();
    fibList.add(BigInteger.ONE); fibList.add(BigInteger.ONE);

    Instant start = Instant.now();
    while (fibList.size() &lt; n) {
        generateFib(fibList);
    }
    Instant stop = Instant.now();
    System.out.println(
      Duration.between(start,stop).toMillis() + "ms");

    return fibList.get(n-1);
}</code></pre>
</section>
<section id="b-13" class="slide level1">
<h1>3b</h1>
<pre ><code class="text">jshell&gt; Fib.main(null)
50000
3705ms</code></pre>
<pre ><code class="text">jshell&gt; FibSequential.main(null)
50000
4793ms</code></pre>
<p>The parallel one is faster despite doing more work</p>
</section>
<section id="recitation-10-week-12" class="slide level1">
<h1>Recitation 10 (week 12)</h1>
</section>
<section id="today-7" class="slide level1">
<h1>Today</h1>
<ul>
<li>Whirlwind tour of asynchronous programming</li>
<li>Promises
<ul>
<li>Semicolons, function composition</li>
<li>If, exceptions</li>
<li>Control</li>
</ul></li>
<li>Fork-join pools</li>
</ul>
</section>
<section id="threads" class="slide level1">
<h1>Threads</h1>
<p>Most programs we have written so far have run <em>synchronously</em>, on a single <em>thread</em>.</p>
<p><em>(Synchronous: each statement only executes when the previous statement is finished)</em></p>
<p>Each thread has a stack.</p>
</section>
<section id="the-problem" class="slide level1">
<h1>The problem</h1>
<p>Modern computers have multiple cores. We would like to take advantage of them by writing programs which use multiple threads.</p>
<p>But programming with threads directly is hard!</p>
</section>
<section id="problems-with-threads" class="slide level1">
<h1>Problems with threads</h1>
<p>Threads often have to communicate to cooperate. But communicating via shared memory is tricky.</p>
<pre ><code class="java">class Box {
  int x = 0;
}</code></pre>
<pre ><code class="java">void test() {
  Box b = new Box();
  new Thread(() -&gt; b.x++).start();
  new Thread(() -&gt; b.x++).start();
  System.out.println(b.x);
}</code></pre>
<pre ><code class="text">jshell&gt; test()
1

jshell&gt; test()
0</code></pre>
</section>
<section id="problems-with-threads-1" class="slide level1">
<h1>Problems with threads</h1>
<pre ><code class="java">void test() {
  Box b = new Box();
  new Thread(() -&gt; b.x++).start();
  new Thread(() -&gt; b.x++).start();
  System.out.println(b.x);
}</code></pre>
<p><code>b.x++</code> is not <em>atomic</em>; it reads <code>x</code>, then writes <code>x + 1</code> into it. But the value of <code>x</code> could have changed in the meantime!</p>
<p>This situation is called a <em>race condition</em>.</p>
<p><code>Box</code> is said to not be <em>thread-safe</em>, and the threads in this program execute <em>asynchronously</em>.</p>
</section>
<section id="problems-with-threads-2" class="slide level1">
<h1>Problems with threads</h1>
<p>To ensure correctness when using threads, <em>synchronization</em> is typically required.</p>
<p><em>(e.g. the second thread should wait for the first to finish writing before it reads)</em></p>
<p>But improper synchronization could lead to multiple threads waiting for each other, and the whole system getting stuck – <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/deadlock.html">a <em>deadlock</em> situation</a>.</p>
</section>
<section id="problems-with-threads-3" class="slide level1">
<h1>Problems with threads</h1>
<p>Threads aren’t free, so we can’t have too many of them, and they don’t always speed up programs.</p>
<p>After doing some profiling, it’d be nice if we could easily change the number of threads and what is executed on which <em>without having to rewrite code</em>.</p>
<p>How do we solve all these problems?</p>
</section>
<section id="solutions" class="slide level1">
<h1>Solutions</h1>
<ul>
<li>Race conditions
<ul>
<li>Use pure functions, minimize state</li>
</ul></li>
<li>Communication and deadlock
<ul>
<li>Better building blocks</li>
</ul></li>
<li>Thread limits
<ul>
<li>Abstractions like thread pools, scheduler</li>
</ul></li>
</ul>
</section>
<section id="structured-asynchrony" class="slide level1">
<h1>Structured asynchrony</h1>
<p>Idea: instead of threads, we’ll use <em>asynchronous computations</em> as a building block.</p>
<p>A <code>Promise&lt;Integer&gt;</code> is a <em>computation</em> that will produce an integer <em>later</em>.</p>
<p><em>(The monad abstraction is useful for making computations compose well)</em></p>
</section>
<section id="promises" class="slide level1">
<h1>Promises</h1>
<p>We now have an asynchronous <code>;</code></p>
<pre ><code class="java">Promise.of(1).flatMap(a -&gt;
  Promise.of(a + 1)).flatMap(b -&gt; {
    if (b &gt; 2) {
      return b - 3;
    } else {
      return b + 2;
    }
  });</code></pre>
<pre ><code class="java">int a = 1; // async
           // &lt;- other threads can run here
int b = a + 1; // async
               // &lt;- and here
if (b &gt; 2) {
  return b - 3;
} else {
  return b + 2; // regular Java ;
}</code></pre>
</section>
<section id="communication" class="slide level1">
<h1>Communication</h1>
<p>To avoid fiddling with shared variables and manual synchronization, we’ll build graphs of promises that represent <em>what</em> we want to compute, rather than <em>how</em>.</p>
<p><img data-src="9-g2.svg" class="center" /></p>
</section>
<section id="java" class="slide level1">
<h1>Java</h1>
<ul>
<li><code>Promise</code> <span class="math inline">→</span> <code>CompletableFuture</code></li>
<li><code>of</code> <span class="math inline">→</span> <code>completedFuture</code>, <code>supplyAsync</code></li>
<li><code>flatMap</code> <span class="math inline">→</span> <code>thenCompose</code></li>
<li><code>map</code> <span class="math inline">→</span> <code>thenApply</code></li>
</ul>
<p>Done: <code>get</code>, <code>join</code></p>
<p>Exceptions: <code>handle</code>, <code>exceptionally</code></p>
</section>
<section id="mnemonics" class="slide level1">
<h1>Mnemonics</h1>
<table>
<thead>
<tr class="header">
<th><!-- --></th>
<th><!-- --></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>then</td>
<td>sequencing</td>
</tr>
<tr class="even">
<td>apply</td>
<td>map, Function</td>
</tr>
<tr class="odd">
<td>compose, combine</td>
<td>flattening</td>
</tr>
<tr class="even">
<td>async</td>
<td>another thread</td>
</tr>
<tr class="odd">
<td>run</td>
<td>Runnable</td>
</tr>
<tr class="even">
<td>accept</td>
<td>Consumer</td>
</tr>
<tr class="odd">
<td>supply</td>
<td>Supplier</td>
</tr>
</tbody>
</table>
</section>
<section id="ai-function-composition" class="slide level1">
<h1>1ai: function composition</h1>
<pre ><code class="java">static A foo(A a) {
    return a.incr().decr();
}</code></pre>
<pre ><code class="java">static CompletableFuture&lt;A&gt; foo(A a) {
    return CompletableFuture.supplyAsync(() -&gt; a.incr().decr());
}</code></pre>
<p><code>supplyAsync</code> only</p>
</section>
<section id="aii-function-composition" class="slide level1">
<h1>1aii: function composition</h1>
<pre ><code class="java">static A foo(A a) {
    return a.incr().decr();
}</code></pre>
<pre ><code class="java">static CompletableFuture&lt;A&gt; foo(A a) {
    return CompletableFuture.supplyAsync(() -&gt; a.incr()) 
        .thenApply(x -&gt; x.decr());
}</code></pre>
<p><code>supplyAsync</code> and <code>thenApply</code></p>
<p>Meaning is the same</p>
</section>
<section id="aiii-function-composition" class="slide level1">
<h1>1aiii: function composition</h1>
<pre ><code class="java">static A foo(A a) {
    return a.incr().decr();
}</code></pre>
<pre ><code class="java">static CompletableFuture&lt;A&gt; foo(A a) {
    return CompletableFuture.supplyAsync(() -&gt; a.incr()) 
        .thenApplyAsync(x -&gt; x.decr());
}</code></pre>
<p><code>supplyAsync</code> and <code>thenApplyAsync</code></p>
<p><code>decr</code> could run on another thread</p>
</section>
<section id="aiii-function-composition-1" class="slide level1">
<h1>1aiii: function composition</h1>
<pre ><code class="java">A a = foo(new A());
// do something else
a.join();</code></pre>
<p>Waiting for the result</p>
</section>
<section id="b-function-composition" class="slide level1">
<h1>1b: function composition</h1>
<pre ><code class="java">static CompletableFuture&lt;A&gt; foo(A a)</code></pre>
<pre ><code class="java">static A bar(A a) {
    return a.incr();
}</code></pre>
<pre ><code class="java">bar(foo(new A()))</code></pre>
</section>
<section id="b-function-composition-1" class="slide level1">
<h1>1b: function composition</h1>
<pre ><code class="java">static CompletableFuture&lt;A&gt; foo(A a)</code></pre>
<pre ><code class="java">static CompletableFuture&lt;A&gt; bar(A a) {
    return CompletableFuture.supplyAsync(() -&gt; a.incr());
}</code></pre>
<pre ><code class="java">foo(new A()).thenCompose(x -&gt; bar(x));</code></pre>
</section>
<section id="b-function-composition-2" class="slide level1">
<h1>1b: function composition</h1>
<pre ><code class="java">static CompletableFuture&lt;A&gt; foo(A a)</code></pre>
<pre ><code class="java">class B {
  static CompletableFuture&lt;A&gt; bar(A a) {
      return CompletableFuture.supplyAsync(() -&gt; a.incr());
  }
}</code></pre>
<pre ><code class="java">foo(new A()).thenCompose(B::bar);</code></pre>
</section>
<section id="c-if" class="slide level1">
<h1>1c: if</h1>
<pre ><code class="java">static A baz(A a, int x) {
    if (x == 0) {
        return new A();
    } else {
        return a.incr().decr();
    }
}</code></pre>
<pre ><code class="java">static CompletableFuture&lt;A&gt; baz(A a, int x) {
    if (x == 0) {
        return CompletableFuture.completedFuture(new A());
    } else {
        return CompletableFuture.supplyAsync(() -&gt; a.incr().decr());
    }
}</code></pre>
<pre ><code class="java">CompletableFuture&lt;A&gt; c = baz1(new A(), 1);
System.out.println(c.join());</code></pre>
</section>
<section id="d-allof" class="slide level1">
<h1>1d: allOf</h1>
<pre ><code class="java">CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(
    foo(new A()), 
    bar(new A()), 
    baz(new A(), 1));
all.join(); // can only be null; no useful result
System.out.println("done!");</code></pre>
<p><code>Void</code> is a type without any values (except <code>null</code>). It denotes that <code>allOf</code> does not have a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html#allOf-java.util.concurrent.CompletableFuture...-">useful</a> result.</p>
</section>
<section id="e-exceptions" class="slide level1">
<h1>1e: exceptions</h1>
<pre ><code class="java">CompletableFuture&lt;A&gt; exc = CompletableFuture
    .supplyAsync(() -&gt; new A().decr())
    .handle((result, exception) -&gt; {
        if (result == null) {
            System.out.println("ERROR: " + exception);
            return new A();
        } else {
            return result;
        }
    });

System.out.println(exc.join());</code></pre>
</section>
<section id="e-exceptions-1" class="slide level1">
<h1>1e: exceptions</h1>
<pre ><code class="java">CompletableFuture&lt;A&gt; exc = CompletableFuture
    .supplyAsync(() -&gt; new A().decr())
    .exceptionally(exception -&gt; {
        System.out.println("ERROR: " + exception);
        return new A();
    });

System.out.println(exc.join());</code></pre>
</section>
<section id="a-16" class="slide level1">
<h1>2a: <code>;</code></h1>
<pre ><code class="java">A a = new A();

B b = f(a);
C c = g(b);
D d = h(c);</code></pre>
<p>This is</p>
<pre ><code class="java">h(g(f(a)))</code></pre>
<p>so <code>thenApply</code> will work as a more restricted <code>;</code></p>
<pre ><code class="java">CompletableFuture&lt;D&gt; cf = CompletableFuture.supplyAsync(() -&gt;
  f(a)).thenApply(b -&gt;
    g(b)).thenApply(c -&gt;
      h(c));

D d = cf.join();</code></pre>
</section>
<section id="b-14" class="slide level1">
<h1>2b: <code>;</code></h1>
<pre ><code class="java">B b = f(a);
C c = g(b);
h(c); // no return value</code></pre>
<pre ><code class="java">CompletableFuture&lt;Void&gt; cf = CompletableFuture.supplyAsync(() -&gt;
    f(a)).thenApply(b -&gt;
    g(b)).thenAccept(c -&gt; // &lt;- Consumer
      h(c));
cf.join();</code></pre>
</section>
<section id="c-19" class="slide level1">
<h1>2c: <code>;</code></h1>
<pre ><code class="java">B b = f(a);
C c = g(b);
D d = h(b);
E e = i(c, d);</code></pre>
<p><img data-src="10-f.svg" class="generate center" data-cmd="dot -Tsvg -o $out" alt="" /></p>
<pre ><code class="java">CompletableFuture&lt;B&gt; cfb =
  CompletableFuture.supplyAsync(() -&gt; f(a));
CompletableFuture&lt;C&gt; cfc = cfb.thenApply(b -&gt; g(b));
CompletableFuture&lt;D&gt; cfd = cfb.thenApply(b -&gt; h(b));
CompletableFuture&lt;E&gt; cfe = cfc
  .thenCombine(cfd, (c, d) -&gt; i(c, d));
cfe.join();</code></pre>
</section>
<section id="recursivetask" class="slide level1">
<h1><code>RecursiveTask</code></h1>
<p>A mechanism for defining a task that can be split into parallelizable subproblems</p>
</section>
<section id="the-rules" class="slide level1">
<h1><a href="https://nus-cs2030s.github.io/2021-s2/37-forkjoin.html">The rules</a></h1>
<ul>
<li><code>compute</code>: do the work</li>
<li><code>fork</code>: let someone else do the work</li>
<li><code>join</code>
<ul>
<li>work not done <span class="math inline">⟹</span> do the work</li>
<li>work stolen <span class="math inline">⟹</span> do other work or steal</li>
<li>work done <span class="math inline">⟹</span> read result</li>
</ul></li>
</ul>
<p>Not the same as <code>CompletableFuture</code>’s <code>join</code>!</p>
<p><code>fork</code> and <code>join</code> should always be paired.</p>
</section>
<section id="section-78" class="slide level1">
<h1>3</h1>
<pre ><code class="java">import java.util.concurrent.RecursiveTask;
import java.util.concurrent.ForkJoinPool;

class B {
    static class Task extends RecursiveTask&lt;Integer&gt; { 
        int count;
        Task(int count) { 
            this.count = count; 
        }

        @Override
        public Integer compute() {
            System.out.println(spaces(count)
                    + Thread.currentThread().getName()
                    + " " + this.count); 
            if (this.count == 4) { 
                return this.count; 
            } 
            Task t = new Task(this.count + 1); 
            t.fork();
            Integer r = t.join();
            System.out.printf("%sdone %s %d\n",
              spaces(count),
              Thread.currentThread().getName(),
              this.count);
            return r;
        }
    }

    public static void main(String[] args) { 
        ForkJoinPool.commonPool().invoke(new Task(0)); 
    }

    private static String spaces(int h) {
      String s = "";
      for (int i=0; i&lt;h; i++) {
        s += "  ";
      }
      return s;
    }
}</code></pre>
</section>
<section id="section-79" class="slide level1">
<h1>3</h1>
<pre ><code class="text">jshell&gt; new ForkJoinPool(1).invoke(new B.Task(0))
ForkJoinPool-1-worker-3 0
  ForkJoinPool-1-worker-3 1
    ForkJoinPool-1-worker-3 2
      ForkJoinPool-1-worker-3 3
        ForkJoinPool-1-worker-3 4
      done ForkJoinPool-1-worker-3 3
    done ForkJoinPool-1-worker-3 2
  done ForkJoinPool-1-worker-3 1
done ForkJoinPool-1-worker-3 0
$4 ==&gt; 4</code></pre>
<p>The point is all of this <em>can</em> be done by a single thread, which doesn’t just block on <code>join</code>; it does work if there is any to be done.</p>
</section>
<section id="a-17" class="slide level1">
<h1>4a</h1>
<pre ><code class="java">static int fib(int n) {
    if (n &lt;= 1) {
        return n;
    } else {
        return fib(n - 1) + fib(n - 2);
    }
}</code></pre>
</section>
<section id="a-18" class="slide level1">
<h1>4a</h1>
<pre ><code class="java">class Fib extends RecursiveTask&lt;Integer&gt; {
    @Override
    protected Integer compute() {
        if (n &lt;= 1) {
            return n;
        }

        Fib f1 = new Fib(n - 1);
        Fib f2 = new Fib(n - 2);

        // try different variants here...
    }
}</code></pre>
</section>
<section id="ba" class="slide level1">
<h1>4ba</h1>
<pre ><code class="java">class Fib extends RecursiveTask&lt;Integer&gt; {
    @Override
    protected Integer compute() {
        if (n &lt;= 1) {
            return n;
        }

        Fib f1 = new Fib(n - 1);
        Fib f2 = new Fib(n - 2);

        // usual recursive implementation
        return f1.compute() + f2.compute();
    }
}</code></pre>
<pre ><code class="java">new Fib(10).compute()</code></pre>
<p>Sleeping 200ms in each task, 35s</p>
</section>
<section id="ba-1" class="slide level1">
<h1>4ba</h1>
<pre ><code class="text">main : 5
  main : 4
    main : 3
      main : 2
        main : 1
        main : 0
      main : 1
    main : 2
      main : 1
      main : 0
  main : 3
    main : 2
      main : 1
      main : 0
    main : 1</code></pre>
</section>
<section id="bb" class="slide level1">
<h1>4bb</h1>
<pre ><code class="java">class Fib extends RecursiveTask&lt;Integer&gt; {
    @Override
    protected Integer compute() {
        if (n &lt;= 1) {
            return n;
        }

        Fib f1 = new Fib(n - 1);
        Fib f2 = new Fib(n - 2);

        f1.fork(); // allow another thread to take over
        return f2.compute() // main thread starts working
          + f1.join(); // then combines it this result
    }
}</code></pre>
<pre ><code class="java">new Fib(10).compute()</code></pre>
<p>Sleeping 200ms in each task, 6s</p>
</section>
<section id="bb-1" class="slide level1">
<h1>4bb</h1>
<pre ><code class="text">main : 5
  main : 3
  ForkJoinPool.commonPool-worker-3 : 4
    main : 1
    ForkJoinPool.commonPool-worker-5 : 3
    ForkJoinPool.commonPool-worker-3 : 2
    ForkJoinPool.commonPool-worker-7 : 2
      ForkJoinPool.commonPool-worker-7 : 0
      ForkJoinPool.commonPool-worker-3 : 0
      ForkJoinPool.commonPool-worker-9 : 1
      ForkJoinPool.commonPool-worker-5 : 1
      ForkJoinPool.commonPool-worker-11 : 2
      ForkJoinPool.commonPool-worker-13 : 1
        ForkJoinPool.commonPool-worker-5 : 1
        ForkJoinPool.commonPool-worker-11 : 0</code></pre>
</section>
<section id="bc-1" class="slide level1">
<h1>4bc</h1>
<pre ><code class="java">class Fib extends RecursiveTask&lt;Integer&gt; {
    @Override
    protected Integer compute() {
        if (n &lt;= 1) {
            return n;
        }

        Fib f1 = new Fib(n - 1);
        Fib f2 = new Fib(n - 2);

        f1.fork(); // allow another thread to take over...
        return f1.join() // ... but do the work anyway
          + f2.compute();
    }
}</code></pre>
<pre ><code class="java">new Fib(10).compute()</code></pre>
<p>Sleeping 200ms in each task, 35s</p>
</section>
<section id="bc-2" class="slide level1">
<h1>4bc</h1>
<pre ><code class="text">main : 5
  main : 4
    main : 3
      main : 2
        main : 1
        main : 0
      main : 1
    main : 2
      main : 1
      main : 0
  main : 3
    main : 2
      main : 1
      main : 0
    main : 1</code></pre>
</section>
<section id="bd" class="slide level1">
<h1>4bd</h1>
<pre ><code class="java">class Fib extends RecursiveTask&lt;Integer&gt; {
    @Override
    protected Integer compute() {
        if (n &lt;= 1) {
            return n;
        }

        Fib f1 = new Fib(n - 1);
        Fib f2 = new Fib(n - 2);

        f1.fork(); // let other threads do everything
        f2.fork();
        return f2.join() + f1.join();
    }
}</code></pre>
<pre ><code class="java">new Fib(10).compute()</code></pre>
<p>Sleeping 200ms in each task, 5s</p>
</section>
<section id="bd-1" class="slide level1">
<h1>4bd</h1>
<pre ><code class="text">main : 5
  main : 3
  ForkJoinPool.commonPool-worker-5 : 4
    main : 1
    ForkJoinPool.commonPool-worker-7 : 3
    ForkJoinPool.commonPool-worker-3 : 2
    ForkJoinPool.commonPool-worker-5 : 2
      ForkJoinPool.commonPool-worker-3 : 0
      ForkJoinPool.commonPool-worker-7 : 1
      ForkJoinPool.commonPool-worker-11 : 2
      ForkJoinPool.commonPool-worker-9 : 1
      ForkJoinPool.commonPool-worker-5 : 0
      ForkJoinPool.commonPool-worker-13 : 1
        ForkJoinPool.commonPool-worker-9 : 1
        ForkJoinPool.commonPool-worker-11 : 0</code></pre>
</section>
<section id="be" class="slide level1">
<h1>4be</h1>
<pre ><code class="java">class Fib extends RecursiveTask&lt;Integer&gt; {
    @Override
    protected Integer compute() {
        if (n &lt;= 1) {
            return n;
        }

        Fib f1 = new Fib(n - 1);
        Fib f2 = new Fib(n - 2);

        f1.fork(); // different join order
        f2.fork();
        return f1.join() + f2.join();
    }
}</code></pre>
<pre ><code class="java">new Fib(10).compute()</code></pre>
<p>Sleeping 200ms in each task, 7s</p>
</section>
<section id="be-1" class="slide level1">
<h1>4be</h1>
<pre ><code class="text">main : 5
  ForkJoinPool.commonPool-worker-3 : 4
  ForkJoinPool.commonPool-worker-5 : 3
    ForkJoinPool.commonPool-worker-5 : 2
    ForkJoinPool.commonPool-worker-7 : 3
    ForkJoinPool.commonPool-worker-9 : 2
    ForkJoinPool.commonPool-worker-11 : 1
      ForkJoinPool.commonPool-worker-9 : 1
      ForkJoinPool.commonPool-worker-13 : 1
      ForkJoinPool.commonPool-worker-7 : 2
      ForkJoinPool.commonPool-worker-5 : 1
      ForkJoinPool.commonPool-worker-15 : 0
      ForkJoinPool.commonPool-worker-11 : 0
        ForkJoinPool.commonPool-worker-11 : 0
        ForkJoinPool.commonPool-worker-13 : 1</code></pre>
</section>
<section id="code" class="slide level1">
<h1>Code</h1>
<pre ><code class="java">import java.util.concurrent.RecursiveTask;
import java.util.concurrent.ForkJoinPool;
import java.time.Instant;
import java.time.Duration;

class Fib extends RecursiveTask&lt;Integer&gt; {

    final int n;
    final int h;

    Fib(int n) { 
      this(0, n);
    }

    Fib(int h, int n) { 
        this.h = h;
        this.n = n; 
    }

    private void waitOneSec() {
        try {
            Thread.sleep(200);
            // Thread.sleep(1000);
        } catch (InterruptedException e) { }
    }

    @Override
    protected Integer compute() {
        System.out.println(spaces(h) + Thread.currentThread().getName() + " : " + n);
        waitOneSec();
        
        if (n &lt;= 1) {
            return n;
        }

        Fib f1 = new Fib(h + 1, n - 1);
        Fib f2 = new Fib(h + 1, n - 2);

        // return f1.compute() + f2.compute();
        
        f1.fork();
        // return f2.compute() + f1.join();
        // return f1.join() + f2.compute();

        f2.fork();
        // return f2.join() + f1.join();

        return f1.join() + f2.join();
    }

    public static void main(String[] args) {
        Instant start = Instant.now();
        int result = new Fib(5).compute();
        // int result = new ForkJoinPool(1).invoke(new Fib(5));
        System.out.println("Result: " + result);
        // System.out.println("Result: " + new Fib(10).compute());
        Instant end = Instant.now();

        System.out.println("Time taken: " + (Duration.between(start, end).toMillis() / 1000) + "s");
    }

    private static String spaces(int h) {
      String s = "";
      for (int i=0; i&lt;h; i++) {
        s += "  ";
      }
      return s;
    }
}</code></pre>
</section>
<section id="questions" class="slide level1">
<h1>Questions?</h1>
<p><a href="mailto:dariusf@comp.nus.edu.sg" class="email">dariusf@comp.nus.edu.sg</a></p>
<p>Consultation: Zoom/F2F, groups of 2-3</p>
</section>
<section id="office-hours" class="slide level1">
<h1>Office Hours</h1>
<p>No agenda, feel free to ask me any questions.</p>
</section>
    </div>
  </div>

  <script src="https://unpkg.com/reveal.js@4.1.0//dist/reveal.js"></script>

  <script src="https://unpkg.com/reveal.js@4.1.0//plugin/notes/notes.js"></script>
  <script src="https://unpkg.com/reveal.js@4.1.0//plugin/search/search.js"></script>
  <script src="https://unpkg.com/reveal.js@4.1.0//plugin/zoom/zoom.js"></script>
  <script src="https://unpkg.com/reveal.js@4.1.0//plugin/highlight/highlight.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,
        // Vertical centering of slides
        center: false,
        // Transition style
        transition: 'none', // none/fade/slide/convex/concave/zoom
        // Transition speed
        transitionSpeed: 'fast', // default/fast/slow

        plugins: [
          RevealHighlight,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    </body>
</html>
