<!doctype html><html lang=en-US><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://dariusf.github.io/images/favicon.png><title>Ordering events across live loops in Sonic Pi | Darius Foo</title>
<meta name=title content="Ordering events across live loops in Sonic Pi"><meta name=description content="Sonic Pi has an elegant and well-thought temporal semantics. Using the following program as an example,
sample :drum_bass_hard
play :c
sleep 1
sample :drum_cowbell
The drum sample and note can be thought of as starting simultaneously, and the cowbell will play precisely one second1 after.
In other words, sleep there isn't actually POSIX's sleep - it can be thought of as delimiting a section on a virtual timeline, a section which does not include the time taken to start playing the sample and note."><meta name=keywords content><meta property="og:url" content="https://dariusf.github.io/sonic-pi-time/"><meta property="og:site_name" content="Darius Foo"><meta property="og:title" content="Ordering events across live loops in Sonic Pi"><meta property="og:description" content="Sonic Pi has an elegant and well-thought temporal semantics. Using the following program as an example,
sample :drum_bass_hard play :c sleep 1 sample :drum_cowbell The drum sample and note can be thought of as starting simultaneously, and the cowbell will play precisely one second1 after. In other words, sleep there isn't actually POSIX's sleep - it can be thought of as delimiting a section on a virtual timeline, a section which does not include the time taken to start playing the sample and note."><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-06-03T14:50:17+08:00"><meta property="article:modified_time" content="2023-06-03T14:50:17+08:00"><meta property="og:image" content="https://dariusf.github.io/images/favicon.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dariusf.github.io/images/favicon.png"><meta name=twitter:title content="Ordering events across live loops in Sonic Pi"><meta name=twitter:description content="Sonic Pi has an elegant and well-thought temporal semantics. Using the following program as an example,
sample :drum_bass_hard play :c sleep 1 sample :drum_cowbell The drum sample and note can be thought of as starting simultaneously, and the cowbell will play precisely one second1 after. In other words, sleep there isn't actually POSIX's sleep - it can be thought of as delimiting a section on a virtual timeline, a section which does not include the time taken to start playing the sample and note."><meta itemprop=name content="Ordering events across live loops in Sonic Pi"><meta itemprop=description content="Sonic Pi has an elegant and well-thought temporal semantics. Using the following program as an example,
sample :drum_bass_hard play :c sleep 1 sample :drum_cowbell The drum sample and note can be thought of as starting simultaneously, and the cowbell will play precisely one second1 after. In other words, sleep there isn't actually POSIX's sleep - it can be thought of as delimiting a section on a virtual timeline, a section which does not include the time taken to start playing the sample and note."><meta itemprop=datePublished content="2023-06-03T14:50:17+08:00"><meta itemprop=dateModified content="2023-06-03T14:50:17+08:00"><meta itemprop=wordCount content="659"><meta itemprop=image content="https://dariusf.github.io/images/favicon.png"><meta name=referrer content="no-referrer-when-downgrade"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Code"><style>@media(prefers-color-scheme:light){:root{--bright-text-color:#222;--link-color:#3273dc;--link-visited-color:#6e4bbe;--background-color:#fff;--text-color:#444;--faded-text-color:#777;--blockquote-text-color:var(--bright-text-color);--faint-color:#ccc}.chroma{background-color:#fff}.chroma .x{}.chroma .err{color:#000}.chroma .lntd{vertical-align:top;padding:0;margin:0;border:0}.chroma .lntable{border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block}.chroma .hl{display:block;width:100%;background-color:#ffc}.chroma .lnt{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .ln{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .k{color:#a90d91}.chroma .kc{color:#a90d91}.chroma .kd{color:#a90d91}.chroma .kn{color:#a90d91}.chroma .kp{color:#a90d91}.chroma .kr{color:#a90d91}.chroma .kt{color:#a90d91}.chroma .n{color:#000}.chroma .na{color:#836c28}.chroma .nb{color:#a90d91}.chroma .bp{color:#5b269a}.chroma .nc{color:#3f6e75}.chroma .no{color:#000}.chroma .nd{color:#000}.chroma .ni{color:#000}.chroma .ne{color:#000}.chroma .nf{color:#000}.chroma .fm{color:#000}.chroma .nl{color:#000}.chroma .nn{color:#000}.chroma .nx{color:#000}.chroma .py{color:#000}.chroma .nt{color:#000}.chroma .nv{color:#000}.chroma .vc{color:#000}.chroma .vg{color:#000}.chroma .vi{color:#000}.chroma .vm{color:#000}.chroma .l{color:#1c01ce}.chroma .ld{color:#1c01ce}.chroma .s{color:#c41a16}.chroma .sa{color:#c41a16}.chroma .sb{color:#c41a16}.chroma .sc{color:#2300ce}.chroma .dl{color:#c41a16}.chroma .sd{color:#c41a16}.chroma .s2{color:#c41a16}.chroma .se{color:#c41a16}.chroma .sh{color:#c41a16}.chroma .si{color:#c41a16}.chroma .sx{color:#c41a16}.chroma .sr{color:#c41a16}.chroma .s1{color:#c41a16}.chroma .ss{color:#c41a16}.chroma .m{color:#1c01ce}.chroma .mb{color:#1c01ce}.chroma .mf{color:#1c01ce}.chroma .mh{color:#1c01ce}.chroma .mi{color:#1c01ce}.chroma .il{color:#1c01ce}.chroma .mo{color:#1c01ce}.chroma .o{color:#000}.chroma .ow{color:#000}.chroma .p{}.chroma .c{color:#177500}.chroma .ch{color:#177500}.chroma .cm{color:#177500}.chroma .c1{color:#177500}.chroma .cs{color:#177500}.chroma .cp{color:#633820}.chroma .cpf{color:#633820}.chroma .g{}.chroma .gd{}.chroma .ge{}.chroma .gr{}.chroma .gh{}.chroma .gi{}.chroma .go{}.chroma .gp{}.chroma .gs{}.chroma .gu{}.chroma .gt{}.chroma .gl{}.chroma .w{}}@media(prefers-color-scheme:dark){:root{--bright-text-color:#eee;--link-color:#8cc2dd;--link-visited-color:#b9a9e0;--background-color:#333;--text-color:#ddd;--faded-text-color:#aaa;--slightly-dimmer-text-color:#ccc;--blockquote-text-color:var(--slightly-dimmer-text-color);--faint-color:#666;color-scheme:dark}img.theme-affected{filter:invert(.8)}.chroma{color:#e2e4e5;background-color:#282a36}.chroma .x{}.chroma .err{color:#ff5c57}.chroma .lntd{vertical-align:top;padding:0;margin:0;border:0}.chroma .lntable{border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block}.chroma .hl{display:block;width:100%;background-color:#ffc}.chroma .lnt{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .ln{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .k{color:#ff6ac1}.chroma .kc{color:#ff6ac1}.chroma .kd{color:#ff5c57}.chroma .kn{color:#ff6ac1}.chroma .kp{color:#ff6ac1}.chroma .kr{color:#ff6ac1}.chroma .kt{color:#9aedfe}.chroma .n{}.chroma .na{color:#57c7ff}.chroma .nb{color:#ff5c57}.chroma .bp{}.chroma .nc{color:#f3f99d}.chroma .no{color:#ff9f43}.chroma .nd{color:#ff9f43}.chroma .ni{}.chroma .ne{}.chroma .nf{color:#57c7ff}.chroma .fm{}.chroma .nl{color:#ff5c57}.chroma .nn{}.chroma .nx{}.chroma .py{}.chroma .nt{color:#ff6ac1}.chroma .nv{color:#ff5c57}.chroma .vc{color:#ff5c57}.chroma .vg{color:#ff5c57}.chroma .vi{color:#ff5c57}.chroma .vm{}.chroma .l{}.chroma .ld{}.chroma .s{color:#5af78e}.chroma .sa{color:#5af78e}.chroma .sb{color:#5af78e}.chroma .sc{color:#5af78e}.chroma .dl{color:#5af78e}.chroma .sd{color:#5af78e}.chroma .s2{color:#5af78e}.chroma .se{color:#5af78e}.chroma .sh{color:#5af78e}.chroma .si{color:#5af78e}.chroma .sx{color:#5af78e}.chroma .sr{color:#5af78e}.chroma .s1{color:#5af78e}.chroma .ss{color:#5af78e}.chroma .m{color:#ff9f43}.chroma .mb{color:#ff9f43}.chroma .mf{color:#ff9f43}.chroma .mh{color:#ff9f43}.chroma .mi{color:#ff9f43}.chroma .il{color:#ff9f43}.chroma .mo{color:#ff9f43}.chroma .o{color:#ff6ac1}.chroma .ow{color:#ff6ac1}.chroma .p{}.chroma .c{color:#78787e}.chroma .ch{color:#78787e}.chroma .cm{color:#78787e}.chroma .c1{color:#78787e}.chroma .cs{color:#78787e}.chroma .cp{color:#78787e}.chroma .cpf{color:#78787e}.chroma .g{}.chroma .gd{color:#ff5c57}.chroma .ge{text-decoration:underline}.chroma .gr{color:#ff5c57}.chroma .gh{font-weight:700}.chroma .gi{font-weight:700}.chroma .go{color:#43454f}.chroma .gp{}.chroma .gs{font-style:italic}.chroma .gu{font-weight:700}.chroma .gt{}.chroma .gl{text-decoration:underline}.chroma .w{}}:root{--heading-font:ui-rounded, 'Hiragino Maru Gothic ProN', Quicksand, Comfortaa, Manjari, 'Arial Rounded MT', 'Arial Rounded MT Bold', Calibri, source-sans-pro, sans-serif;--text-font-size:17px;--text-font:system-ui, sans-serif}*{margin:0}body{}main{margin-top:.75em}sup{vertical-align:top;font-size:.7em}p{margin-bottom:1em}html{overflow-x:hidden;margin-right:calc(-1 * (100vw - 100%))}body{font-family:var(--text-font);font-size:var(--text-font-size);margin:auto;padding:20px;max-width:720px;text-align:left;background-color:var(--background-color);color:var(--text-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5}h1,h2,h3,h4,h5,h6{font-family:var(--heading-font);color:var(--bright-text-color);font-weight:400}.blog-content h1,.blog-content h2,.blog-content h3,.blog-content h4,.blog-content h5,.blog-content h6{margin-top:.5em}hr,ul,ol{margin-bottom:.5em}div>iframe{margin-bottom:.5em}.blog-timestamp{font-size:.9em}.blog-content{margin-top:1.5em}a{color:var(--link-color);text-decoration:none}.title{color:var(--text-color);font-size:1.5em;font-family:var(--heading-font);margin-right:10px}nav a{margin-right:8px;font-family:var(--heading-font)}.paper-item svg{width:16px;vertical-align:text-bottom}.menuactive{text-decoration:underline;text-decoration-thickness:2px}table{width:100%}img{max-width:100%;margin:auto;margin-bottom:.5em;display:block}code{padding:2px 5px;margin-bottom:1em;font-family:Fira Code,monospace;font-size:14px;line-height:1.4}pre code{display:block;padding:20px;white-space:pre-wrap;overflow-x:auto}pre{border-radius:10px}p code,ol code,ul code,summary code{border-radius:4px;border:solid var(--faint-color)1px;margin:0 2px;padding:1px 2px}blockquote{border-left:1px solid #999;color:var(--blockquote-text-color);padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.deemphasize{color:var(--faded-text-color)}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px;text-align:right;margin-right:20px}ul.blog-posts li a:visited{color:var(--link-visited-color)}</style></head><body><header><a href=/><span class=title>Darius Foo</span></a><nav style=display:inline-block><a href=/blog/>Blog</a>
<a href=/research/>Research</a>
<a href=/work/>Work</a>
<a href=/other/>Other</a></nav></header><main><h1>Ordering events across live loops in Sonic Pi</h1><div><time class=blog-timestamp datetime=2023-06-03 pubdate>3 Jun, 2023</time></div><div class=blog-content><p>Sonic Pi has an elegant and well-thought <a href=https://in-thread.sonic-pi.net/t/what-does-time-mean-in-sonic-pi/4509>temporal semantics</a>. Using the following program as an example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=n>sample</span> <span class=ss>:drum_bass_hard</span>
</span></span><span class=line><span class=cl><span class=n>play</span> <span class=ss>:c</span>
</span></span><span class=line><span class=cl><span class=nb>sleep</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=n>sample</span> <span class=ss>:drum_cowbell</span>
</span></span></code></pre></div><p>The drum sample and note can be thought of as starting simultaneously, and the cowbell will play precisely one second<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> after.
In other words, <code>sleep</code> there isn't actually POSIX's <code>sleep</code> - it can be thought of as delimiting a section on a virtual timeline, a section which <em>does not include the time taken to start playing the sample and note</em>.</p><p>This enables a simple and declarative programming model.
Setting up two live loops like the following works as you would expect, i.e. they won't drift out of sync. If the sound card is overloaded, some sounds may not play, but live loops will remain in phase.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=n>live_loop</span> <span class=ss>:hihat</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=n>sample</span> <span class=ss>:drum_cymbal_closed</span>
</span></span><span class=line><span class=cl>  <span class=nb>sleep</span> <span class=mi>0</span><span class=o>.</span><span class=mi>25</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>live_loop</span> <span class=ss>:drums</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=n>sample</span> <span class=ss>:drum_bass_hard</span>
</span></span><span class=line><span class=cl>  <span class=nb>sleep</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>Well, mostly.
Live loops are Ruby threads, which are scheduled nondeterministically. As a result, events across threads within one time "partition" are unordered.</p><p>Consider this simplified example, which features communication across live loops. It's a fairly common scenario: we have a control loop that determines the key we're playing in, and one or more loops which adapt accordingly.</p><p>We're using <code>set</code> and <code>get</code> for deterministic (timeline-synced) state updates, and the <code>sync:</code> parameter to ensure that <code>melody</code> only starts when receiving a <em>cue</em> from <code>control</code>. Cues are sent every time a live loop begins executing its block.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=n>live_loop</span> <span class=ss>:control</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=n>set</span> <span class=ss>:n</span><span class=p>,</span> <span class=o>[</span><span class=ss>:c</span><span class=p>,</span> <span class=ss>:d</span><span class=p>,</span> <span class=ss>:e</span><span class=o>].</span><span class=n>tick</span>
</span></span><span class=line><span class=cl>  <span class=nb>sleep</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>live_loop</span> <span class=ss>:melody</span><span class=p>,</span> <span class=ss>sync</span><span class=p>:</span> <span class=ss>:control</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=n>play</span> <span class=p>(</span><span class=n>get</span> <span class=ss>:n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nb>sleep</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>We observe two surprising things.</p><ol><li>The first note we hear is always <code>:d</code>, and always after a second of silence</li><li>The notes thereafter are some random subsequence of the ring <code>[:c, :d, :e]</code></li></ol><p>The <a href=https://in-thread.sonic-pi.net/t/live-loops-sync-questions/1172/13>fix</a> for the first issue is to make the control loop start after a short delay.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=n>live_loop</span> <span class=ss>:control</span><span class=p>,</span> <span class=ss>delay</span><span class=p>:</span> <span class=mi>0</span><span class=o>.</span><span class=mi>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=n>set</span> <span class=ss>:n</span><span class=p>,</span> <span class=o>[</span><span class=ss>:c</span><span class=p>,</span> <span class=ss>:d</span><span class=p>,</span> <span class=ss>:e</span><span class=o>].</span><span class=n>tick</span>
</span></span><span class=line><span class=cl>  <span class=nb>sleep</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>This happens because of Ruby's imperative nature and nondeterministic thread scheduling: when the first live loop starts executing in a thread, the cue it subsequently sends is unordered with respect to the second <code>live_loop</code> call (which executes on the main thread). Most of the time the cue is sent before the melody loop starts, causing it to miss playing the first note.
Thus the cue should be delayed until after the melody loop has (presumably<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>) started.</p><p>To address the second issue of notes missing, we could remove the <code>sync:</code> parameter and try using <code>sync</code> instead of <code>get</code>, which makes melody loop wait for the <a href=https://in-thread.sonic-pi.net/t/a-tiny-script-for-your-hipster-lounge/4448/10>next</a> note.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=n>live_loop</span> <span class=ss>:melody</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=n>play</span> <span class=p>(</span><span class=n>sync</span> <span class=ss>:n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nb>sleep</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>Now, however, we hear only every other note.
The problem is that it is possible for the melody loop to miss cues while it is sleeping. I'm not sure if this is due to the time abstraction leaking (where we can observe one thread sleeping while another acts, despite the time "partition" being the same), or the ordering of cues not being well-defined with respect to other events in live loops.</p><p>Nevertheless, the solution is to ensure that the melody loop is not asleep when control loop cues. A simple way is to make sure there is always less sleep time in the former loop.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=n>live_loop</span> <span class=ss>:control</span><span class=p>,</span> <span class=ss>delay</span><span class=p>:</span> <span class=mi>0</span><span class=o>.</span><span class=mi>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=n>set</span> <span class=ss>:n</span><span class=p>,</span> <span class=o>[</span><span class=ss>:c</span><span class=p>,</span> <span class=ss>:d</span><span class=p>,</span> <span class=ss>:e</span><span class=o>].</span><span class=n>tick</span>
</span></span><span class=line><span class=cl>  <span class=nb>sleep</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>live_loop</span> <span class=ss>:melody</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=n>play</span> <span class=p>(</span><span class=n>sync</span> <span class=ss>:n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=c1># we can do other things here, as long as we sleep &lt; 1</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><h1 id=conclusion>Conclusion</h1><p>These are awfully subtle issues for beginners to debug.
I wish Sonic Pi had a simpler, more synchronous concurrency model, or at least provided more guarantees about the interleaving of events within a time partition.
It's quite likely that this is difficult to implement efficiently with its wealth of features, though.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>One beat, actually, but at the default BPM of 60, one beat occurs every second.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Technically we're still not guaranteed that the second loop has started.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><p></p></main><footer></footer></body></html>